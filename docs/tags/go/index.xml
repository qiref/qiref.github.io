<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go on 大道至简</title>
    <link>https://qiref.github.io/tags/go/</link>
    <description>Recent content in Go on 大道至简</description>
    <generator>Hugo</generator>
    <language>cn-zh</language>
    <lastBuildDate>Wed, 15 May 2024 15:53:46 +0800</lastBuildDate>
    <atom:link href="https://qiref.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>关于锁的思考和总结(一)</title>
      <link>https://qiref.github.io/post/2024/05/15/%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93%E4%B8%80/</link>
      <pubDate>Wed, 15 May 2024 15:53:46 +0800</pubDate>
      <guid>https://qiref.github.io/post/2024/05/15/%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93%E4%B8%80/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add (a *int) *int { &#xA;  *a++ // 线程不安全&#xA;  return a&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这是一段很典型的线程不安全的代码示例, 在并发场景下, a 的结果是不确定的, 大概率会小于 1000, 原因是 &lt;code&gt;a++&lt;/code&gt; 并非原子操作, 会存在同时有两个协程读取到 a 的值是相同的情况, 执行 &lt;code&gt;a++&lt;/code&gt;之后再重新回写时, a的值也是相同的, 想要变为线程安全, 就需要在操作临界资源之前加锁;&lt;/p&gt;&#xA;&lt;h2 id=&#34;mutex&#34;&gt;Mutex&lt;/h2&gt;&#xA;&lt;p&gt;在操作共享资源之前加锁, 然后操作完临界资源之后释放锁, 保证同时只有一个协程操作临界资源;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var mu sync.Mutex&#xA;func addSafe(a *int) *int {&#xA;  mu.Lock() // 加锁&#xA;  defer mu.Unlock() // 释放锁&#xA;  *a++&#xA;  return a&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;锁在多线程或多进程环境中实现资源的互斥访问。当一个线程或进程想要访问某个共享资源（如数据结构、文件等）时，它必须首先尝试获取该资源对应的锁。如果锁未被其他线程或进程占用，那么请求的线程或进程将获得锁并继续执行；否则，它将等待，直到锁被释放。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// If the lock is already in use, the calling goroutine&#xA;// blocks until the mutex is available.&#xA;func (m *Mutex) Lock() {&#xA;  // Fast path: grab unlocked mutex.&#xA;  if atomic.CompareAndSwapInt32(&amp;amp;m.state, 0, mutexLocked) {&#xA;    if race.Enabled {&#xA;      race.Acquire(unsafe.Pointer(m))&#xA;    }&#xA;    return&#xA;  }&#xA;  // Slow path (outlined so that the fast path can be inlined)&#xA;  m.lockSlow()&#xA;}&#xA;&#xA;type Mutex struct {&#xA;  state int32 // state 表示当前互斥锁的状态&#xA;  sema  uint32 // sema 是用于控制锁状态的信号量&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;在 &lt;code&gt;golang&lt;/code&gt; 的实现中, 如果通过 &lt;code&gt;CompareAndSwapInt32&lt;/code&gt; 也就是 &lt;code&gt;CAS&lt;/code&gt; 能获取到锁, 表明协程已经能拿到锁了, 此时直接返回;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go ppfof工具使用</title>
      <link>https://qiref.github.io/post/2024/02/23/go-ppfof%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 23 Feb 2024 15:53:46 +0800</pubDate>
      <guid>https://qiref.github.io/post/2024/02/23/go-ppfof%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;h2 id=&#34;pprof&#34;&gt;pprof&lt;/h2&gt;&#xA;&lt;p&gt;pprof 是用于可视化和分析性能分析数据的工具;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;runtime/pprof：采集程序（非 Server）的运行数据进行分析&lt;/li&gt;&#xA;&lt;li&gt;net/http/pprof：采集 HTTP Server 的运行时数据进行分析&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;启用方式&#34;&gt;启用方式&lt;/h2&gt;&#xA;&lt;p&gt;在&lt;code&gt;main&lt;/code&gt;函数之前使用启动, &lt;code&gt;DoProfile(6060)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&#xA;import (&#xA;    &amp;quot;net/http&amp;quot;&#xA;    _ &amp;quot;net/http/pprof&amp;quot;&#xA;    &amp;quot;strconv&amp;quot;&#xA;)&#xA;&#xA;type ProfileServer struct {&#xA;}&#xA;&#xA;func (this *ProfileServer) DoProfile(port int) {&#xA;    go func() {&#xA;        err := http.ListenAndServe(&amp;quot;:&amp;quot;+strconv.FormatInt(int64(port), 10), nil)&#xA;        if err != nil {&#xA;            log.Errorf(&amp;quot;Failed to do profile on port: %d&amp;quot;, port)&#xA;        } else {&#xA;            log.Infof(&amp;quot;pprof start successfully on port %d&amp;quot;, port)&#xA;        }&#xA;    }()&#xA;}&#xA;  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl &#39;http://127.0.0.1:6060/debug/pprof/profile&#39; -o profile.20240223&#xA;curl &#39;http://127.0.0.1:6060/debug/pprof/heap&#39; -o heap.20240223&#xA;curl &#39;http://127.0.0.1:6060/debug/pprof/block&#39; -o block.20240223&#xA;curl &#39;http://127.0.0.1:6060/debug/pprof/mutex&#39; -o mutex.20240223&#xA;curl &#39;http://127.0.0.1:6060/debug/pprof/trace&#39; -o trace.20240223&#xA;  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;输出对应的pprof文件之后, 对文件进行分析;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言生产者消费者模型</title>
      <link>https://qiref.github.io/post/2023/04/28/go%E8%AF%AD%E8%A8%80%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 28 Apr 2023 15:57:51 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/04/28/go%E8%AF%AD%E8%A8%80%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&#xA;type Request struct {&#xA;    Name string&#xA;}&#xA;&#xA;type XxHandler struct {&#xA;    RequestQueue chan *Request&#xA;}&#xA;&#xA;func (o *XxHandler) String() string {&#xA;    if b, err := json.Marshal(o); err != nil {&#xA;        return &amp;quot;&amp;quot;&#xA;    } else {&#xA;        return string(b)&#xA;    }&#xA;}&#xA;&#xA;// Start 启动队列监听&#xA;func (o *XxHandler) Start() {&#xA;    go func() {&#xA;        for request := range o.RequestQueue {&#xA;            go o.Process(request)&#xA;        }&#xA;    }()&#xA;}&#xA;&#xA;// AppendTask 向队列中增加task&#xA;func (o *XxHandler) AppendTask(request *Request) {&#xA;    if request == nil {&#xA;        return&#xA;    }&#xA;    o.RequestQueue &amp;lt;- request&#xA;}&#xA;&#xA;// Stop 关闭队列&#xA;func (o *XxHandler) Stop() {&#xA;    close(o.RequestQueue)&#xA;}&#xA;&#xA;func newIns() *XxHandler {&#xA;    return &amp;amp;XxHandler{&#xA;        RequestQueue: make(chan *Request, 10),&#xA;    }&#xA;}&#xA;&#xA;var ins *XxHandler&#xA;&#xA;// GetXxHandler 获取 实例&#xA;func GetXxHandler() *XxHandler {&#xA;    if ins == nil {&#xA;        ins = newIns()&#xA;    }&#xA;    return ins&#xA;}&#xA;&#xA;// Process 处理队列中的任务&#xA;func (o *XxHandler) Process(request *Request) {&#xA;    // do something&#xA;}&#xA;&#xA;func TestXxHandler(t *testing.T) {&#xA;    GetXxHandler().Start()&#xA;&#xA;    GetXxHandler().AppendTask(&amp;amp;Request{Name: &amp;quot;xx&amp;quot;})&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Go语言实现 bitmap</title>
      <link>https://qiref.github.io/post/2023/04/28/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-bitmap/</link>
      <pubDate>Fri, 28 Apr 2023 11:24:38 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/04/28/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-bitmap/</guid>
      <description>&lt;h2 id=&#34;算法说明&#34;&gt;算法说明&lt;/h2&gt;&#xA;&lt;p&gt;Bitmap算法是一种基于位运算的数据结构，用于解决大规模数据的快速查找和统计问题。其基本原理是将一个大数据集合映射到一个二进制向量中，其中每个元素对应于数据集合中的一个元素，向量中的每一位表示该元素是否存在于集合中。&lt;/p&gt;&#xA;&lt;p&gt;具体来说，Bitmap算法通过使用一个位图（bitmap）来表示一个数据集合，其中每个元素对应一个位。如果某个元素在数据集合中出现，则将其对应的位设置为1，否则将其对应的位设置为0。通过这种方式，可以快速地进行集合操作，如并集、交集和差集等。&lt;/p&gt;&#xA;&lt;p&gt;Bitmap算法的主要优点在于其空间效率高，可以用较小的空间存储大规模数据集合。另外，Bitmap算法的时间复杂度也非常低，可以快速地进行集合操作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;如何用数组表示一个-bitmap&#34;&gt;如何用数组表示一个 bitmap&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/bitmap-index-cal.svg&#34; alt=&#34;bitmap-index-cal&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;以 1byte 为例：8位能表示8个元素， 0-7 号对应了 b[0] 下标， 8-15 号对应了 b[1] 下标，以此类推。&lt;/p&gt;&#xA;&lt;p&gt;因此，数组下标 n 跟bitmap元素序号 bitmapIdx 的关系为：&lt;code&gt;n = bitmapIdx &amp;gt;&amp;gt; 3&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;值如何映射到-bitmap-数组&#34;&gt;值如何映射到 bitmap 数组&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/bitmap-index-map.svg&#34; alt=&#34;bitmap-index-cal&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;当找到了 元素序号 n 在数组中的下标之后，如何给 b[n] 赋值呢？&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;1 &amp;lt;&amp;lt; (bitmapIdx &amp;amp; 7)&lt;/code&gt; 等同于 &lt;code&gt;1 &amp;lt;&amp;lt; (bitmapIdx % 8)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;(bitmapIdx % 8)&lt;/code&gt; 找到在了在数组 b[n] 中的第 &lt;code&gt;m&lt;/code&gt; 位，然后 &lt;code&gt;1 &amp;lt;&amp;lt; m&lt;/code&gt; 之后，就相当于给数组赋值，把第 &lt;code&gt;m&lt;/code&gt; 位 置为1。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;&#xA;&lt;p&gt;同样以 1byte 为例：借用上述结论，第 24 号元素，对应的数组下标 n 为：&lt;code&gt;n = 24 &amp;gt;&amp;gt; 3 &lt;/code&gt; 结果为3, b[3]；&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言实现 LRU</title>
      <link>https://qiref.github.io/post/2023/04/27/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-lru/</link>
      <pubDate>Thu, 27 Apr 2023 21:43:12 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/04/27/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-lru/</guid>
      <description>&lt;p&gt;LRU（Least Recently Used）算法，即最近最少使用算法;其基本思想是，如果一个数据最近被访问过，那么它在未来被访问的概率也会很高；反之，如果一个数据很久都没有被访问过，那么它在未来被访问的概率就相对较低。因此，LRU算法选择淘汰最近最少使用的数据，即选择最长时间没有被访问过的数据进行淘汰。&lt;/p&gt;&#xA;&lt;p&gt;具体来说，LRU算法通常使用一个双向链表和一个哈希表来实现。双向链表中的节点按照最近访问时间的顺序排列，最近访问的节点排在链表头部，最久未访问的节点排在链表尾部。哈希表中存储每个节点的地址，以便快速查找和删除。&lt;/p&gt;&#xA;&lt;p&gt;当需要访问一个数据时，LRU算法首先在哈希表中查找该数据，如果存在，则将对应的节点移动到链表头部；如果不存在，则将该数据添加到链表头部，并在哈希表中创建对应的节点。&lt;/p&gt;&#xA;&lt;p&gt;当需要淘汰数据时，LRU算法选择链表尾部的节点进行淘汰，并在哈希表中删除对应的节点。&lt;/p&gt;&#xA;&lt;p&gt;golang 实现 LRU 算法：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package lru&#xA;&#xA;import (&#xA;    &amp;quot;container/list&amp;quot;&#xA;    &amp;quot;errors&amp;quot;&#xA;    &amp;quot;sync&amp;quot;&#xA;)&#xA;&#xA;// LRU implements a non-thread safe fixed size LRU cache&#xA;type LRU struct {&#xA;    size      int&#xA;    evictList *list.List&#xA;    items     map[interface{}]*list.Element&#xA;}&#xA;&#xA;// entry is used to hold a value in the evictList&#xA;type entry struct {&#xA;    key   interface{}&#xA;    value interface{}&#xA;}&#xA;&#xA;// NewLRU constructs an LRU of the given size&#xA;func NewLRU(size int) (*LRU, error) {&#xA;    if size &amp;lt;= 0 {&#xA;        return nil, errors.New(&amp;quot;must provide a positive size&amp;quot;)&#xA;    }&#xA;    c := &amp;amp;LRU{&#xA;        size:      size,&#xA;        evictList: list.New(),&#xA;        items:     make(map[interface{}]*list.Element),&#xA;    }&#xA;    return c, nil&#xA;}&#xA;&#xA;// Add adds a value to the cache.  Returns true if an eviction occured.&#xA;func (c *LRU) Add(key, value interface{}) bool {&#xA;    // Check for existing item&#xA;    if ent, ok := c.items[key]; ok {&#xA;        c.evictList.MoveToFront(ent)&#xA;        ent.Value.(*entry).value = value&#xA;        return false&#xA;    }&#xA;&#xA;    // Add new item&#xA;    ent := &amp;amp;entry{key, value}&#xA;    entry := c.evictList.PushFront(ent)&#xA;    c.items[key] = entry&#xA;&#xA;    evict := c.evictList.Len() &amp;gt; c.size&#xA;    // Verify size not exceeded&#xA;    if evict {&#xA;        c.removeOldest()&#xA;    }&#xA;    return evict&#xA;}&#xA;&#xA;// Get looks up a key&#39;s value from the cache.&#xA;func (c *LRU) Get(key interface{}) (value interface{}, ok bool) {&#xA;    if ent, ok := c.items[key]; ok {&#xA;        c.evictList.MoveToFront(ent)&#xA;        return ent.Value.(*entry).value, true&#xA;    }&#xA;    return&#xA;}&#xA;&#xA;// Remove removes the provided key from the cache, returning if the&#xA;// key was contained.&#xA;func (c *LRU) Remove(key interface{}) bool {&#xA;    if ent, ok := c.items[key]; ok {&#xA;        c.removeElement(ent)&#xA;        return true&#xA;    }&#xA;    return false&#xA;}&#xA;&#xA;// removeOldest removes the oldest item from the cache.&#xA;func (c *LRU) removeOldest() {&#xA;    ent := c.evictList.Back()&#xA;    if ent != nil {&#xA;        c.removeElement(ent)&#xA;    }&#xA;}&#xA;&#xA;// removeElement is used to remove a given list element from the cache&#xA;func (c *LRU) removeElement(e *list.Element) {&#xA;    c.evictList.Remove(e)&#xA;    kv := e.Value.(*entry)&#xA;    delete(c.items, kv.key)&#xA;    if c.onEvict != nil {&#xA;        c.onEvict(kv.key, kv.value)&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;需要注意的是这个 LRU 实现并不是线程安全的，如果需要线程安全，需要在外层方法加锁，同时，由于 golang 的 lock 并不是可重入的，需要注意避免死锁问题。 以下实现中基于 LRU 做了一次封装，实现了线程安全的内存级 LRU-Cache：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言单例模式</title>
      <link>https://qiref.github.io/post/2023/03/24/go%E8%AF%AD%E8%A8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 24 Mar 2023 10:47:42 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/03/24/go%E8%AF%AD%E8%A8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;错误示例&#34;&gt;错误示例&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type singleton struct {}&#xA;&#xA;var instance *singleton&#xA;&#xA;func GetInstance() *singleton {&#xA;    if instance == nil {&#xA;        instance = &amp;amp;singleton{}   // 不是并发安全的&#xA;    }&#xA;    return instance&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;不优雅示例&#34;&gt;不优雅示例&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GetInstance() *singleton {&#xA;    mu.Lock()                    // 如果实例存在没有必要加锁&#xA;    defer mu.Unlock()&#xA;&#xA;    if instance == nil {&#xA;        instance = &amp;amp;singleton{}&#xA;    }&#xA;    return instance&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;加锁可以保证每次拿到相同实例，但是如果已经实例化，再调用函数，依然有锁存在，浪费性能，不够优雅；&lt;/p&gt;&#xA;&lt;h2 id=&#34;优雅示例&#34;&gt;优雅示例&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (&#xA;    &amp;quot;sync&amp;quot;&#xA;)&#xA;&#xA;type singleton struct {}&#xA;&#xA;var instance *singleton&#xA;var once sync.Once&#xA;&#xA;func GetInstance() *singleton {&#xA;    once.Do(func() {&#xA;        instance = &amp;amp;singleton{}&#xA;    })&#xA;    return instance&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;该实现利用&lt;code&gt;sync.Once&lt;/code&gt;类型去同步对&lt;code&gt;GetInstance()&lt;/code&gt;的访问，并确保我们的类型仅被初始化一次。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言cobra</title>
      <link>https://qiref.github.io/post/2022/02/19/go%E8%AF%AD%E8%A8%80cobra/</link>
      <pubDate>Sat, 19 Feb 2022 18:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/02/19/go%E8%AF%AD%E8%A8%80cobra/</guid>
      <description>&lt;p&gt;摘要：Go语言 cobra 框架使用说明，文中代码地址： &lt;a href=&#34;https://github.com/ArchieYao/clid&#34;&gt;https://github.com/ArchieYao/clid&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;cobra-简介&#34;&gt;cobra 简介&lt;/h2&gt;&#xA;&lt;p&gt;cobra是 Go 语言的一个命令行程序库，可以用来编写命令行程序。同时，它也提供了一个脚手架， 用于生成基于 cobra 的应用程序框架。非常多知名的开源项目使用了 cobra 库构建命令行，如Kubernetes、Hugo、etcd等。&lt;/p&gt;&#xA;&lt;h2 id=&#34;安装-cobra&#34;&gt;安装 cobra&lt;/h2&gt;&#xA;&lt;p&gt;cobra 是由大名鼎鼎的 spf13（golang 开发者） 开发的，GitHub 地址：&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;https://github.com/spf13/cobra&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 安装&#xA;go get -u github.com/spf13/cobra&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 检查是否安装成功&#xA;cobra -h&#xA;Cobra is a CLI library for Go that empowers applications.&#xA;This application is a tool to generate the needed files&#xA;to quickly create a Cobra application.&#xA;&#xA;Usage:&#xA;  cobra [command]&#xA;&#xA;Available Commands:&#xA;  add         Add a command to a Cobra Application&#xA;  completion  Generate the autocompletion script for the specified shell&#xA;  help        Help about any command&#xA;  init        Initialize a Cobra Application&#xA;&#xA;Flags:&#xA;  -a, --author string    author name for copyright attribution (default &amp;quot;YOUR NAME&amp;quot;)&#xA;      --config string    config file (default is $HOME/.cobra.yaml)&#xA;  -h, --help             help for cobra&#xA;  -l, --license string   name of license for the project&#xA;      --viper            use Viper for configuration&#xA;&#xA;Use &amp;quot;cobra [command] --help&amp;quot; for more information about a command.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;创建-cobra-工程&#34;&gt;创建 cobra 工程&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 创建 Go 工程&#xA;mkdir clid&#xA;cd clid&#xA;go mod init clid&#xA;&#xA;# 创建 cobra 工程&#xA;cobra init&#xA;# 可以得到如下工程目录&#xA;D:\WORKSPACE\GOLANG\TRAINNING\CLID&#xA;│   go.mod&#xA;│   go.sum&#xA;│   LICENSE&#xA;│   main.go&#xA;│&#xA;└───cmd&#xA;        root.go&#xA;&#xA;# 正常情况下，这个工程可以正常编译并且运行&#xA;go build -o ./bin/clid&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;增加自定义命令&#34;&gt;增加自定义命令&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cobra add version&#xA;&#xA;tree /f&#xA;D:.&#xA;│   go.mod&#xA;│   go.sum&#xA;│   LICENSE&#xA;│   main.go&#xA;│&#xA;└───cmd&#xA;        root.go&#xA;        version.go&#xA;&#xA;# 在 `cmd` 目录下新生成一个 `version.go` 的文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;从新生成的文件可以看出，核心方法就2个：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言实现httpServer</title>
      <link>https://qiref.github.io/post/2021/06/19/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0httpserver/</link>
      <pubDate>Sat, 19 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/19/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0httpserver/</guid>
      <description>&lt;p&gt;摘要：使用Go语言原生包实现Http Server。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;启动一个http-server&#34;&gt;启动一个Http Server&lt;/h2&gt;&#xA;&lt;p&gt;使用Go语言原生的net/http库可以很简单实现一个http server。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;log.Println(&amp;quot;start server&amp;quot;)&#xA;if err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil); err != nil {&#xA;    log.Println(&amp;quot;start server on 8080&amp;quot;)&#xA;}&#xA;log.Fatal(&amp;quot;start server failed.&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;没错，只要这么几行代码，就开启了一个http server，监听8080端口。&lt;/p&gt;&#xA;&lt;h2 id=&#34;接收http请求&#34;&gt;接收Http请求&lt;/h2&gt;&#xA;&lt;h3 id=&#34;httphandlefunc&#34;&gt;http.HandleFunc&lt;/h3&gt;&#xA;&lt;p&gt;开启了Http server后，无法处理Http请求这个就是个空的Server，下面给它加上处理Http Request的能力。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func init() {&#xA;    log.Println(&amp;quot;start server&amp;quot;)&#xA;    http.HandleFunc(&amp;quot;/hello_world&amp;quot;, HelloWorld)&#xA;    if err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil); err != nil {&#xA;        log.Println(&amp;quot;start server on 8080&amp;quot;)&#xA;    }&#xA;    log.Fatal(&amp;quot;start server failed.&amp;quot;)&#xA;}&#xA;&#xA;func HelloWorld(w http.ResponseWriter, r *http.Request) {&#xA;    _, err := w.Write([]byte(&amp;quot;hello world&amp;quot;))&#xA;    if err != nil {&#xA;        log.Println(err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;http.HandleFunc(&amp;quot;/hello_world&amp;quot;, HelloWorld)&lt;/code&gt; 这行代码指定了一个路由对应的方法，然后访问&lt;a href=&#34;http://127.0.0.1:8080/hello_world&#34;&gt;http://127.0.0.1:8080/hello_world&lt;/a&gt; 可以得到hello world的字符串，这段字符串也是&lt;code&gt;HelloWorld(w http.ResponseWriter, r *http.Request)&lt;/code&gt; 函数的输出。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言反射</title>
      <link>https://qiref.github.io/post/2021/06/17/go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Thu, 17 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/17/go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84/</guid>
      <description>&lt;p&gt;摘要：理解Go语言的反射机制，反射是指在程序运行期对程序本身进行访问和修改的能力。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;反射基础信息&#34;&gt;反射基础信息&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func reflectDemo() {&#xA;    str := &amp;quot;reflect&amp;quot;&#xA;    fmt.Println(reflect.ValueOf(str))&#xA;    fmt.Println(reflect.TypeOf(str))&#xA;}&#xA;// 结果&#xA;// reflect&#xA;// string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;reflect.ValueOf()获取数据运行时的值。&#xA;reflect.TypeOf()获取数据类型信息。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Type values are comparable, such as with the == operator,&#xA;// so they can be used as map keys.&#xA;// Two Type values are equal if they represent identical types.&#xA;type Type interface {&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// To compare two Values, compare the results of the Interface method.&#xA;// Using == on two Values does not compare the underlying values&#xA;// they represent.&#xA;type Value struct {&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;从源码中可以看出，Type是个interface，而Value是个struct。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言defer、panic、recover</title>
      <link>https://qiref.github.io/post/2021/06/15/go%E8%AF%AD%E8%A8%80deferpanicrecover/</link>
      <pubDate>Tue, 15 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/15/go%E8%AF%AD%E8%A8%80deferpanicrecover/</guid>
      <description>&lt;p&gt;摘要：理解Go语言defer、panic、recover。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;defer&#34;&gt;defer&lt;/h2&gt;&#xA;&lt;p&gt;Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源，总结一句话就是完成函数执行完的收尾工作。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func DeferDemo() {&#xA;    defer fmt.Println(&amp;quot;this is defer println&amp;quot;)&#xA;    fmt.Println(&amp;quot;this is println&amp;quot;)&#xA;}&#xA;// 输出&#xA;// this is println&#xA;// this is defer println&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;运行以上代码每次都是第二个println先输出，然后才是defer关键字修饰的println输出。&lt;/p&gt;&#xA;&lt;p&gt;如果有多个defer，输出顺序又会如何？&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func MultiDeferDemo() {&#xA;    for i := 0; i &amp;lt; 5; i++ {&#xA;        defer fmt.Println(&amp;quot; defer &amp;quot;, i)&#xA;    }&#xA;}&#xA;// 输出&#xA;// defer  4&#xA;// defer  3&#xA;// defer  2&#xA;// defer  1&#xA;// defer  0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;每次最先输出的都是循环的最后一个println，可以得出：多个defer，运行顺序遵循LIFO规则。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言包管理</title>
      <link>https://qiref.github.io/post/2021/06/10/go%E8%AF%AD%E8%A8%80%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 10 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/10/go%E8%AF%AD%E8%A8%80%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;p&gt;摘要：Go语言包管理。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;包使用规范&#34;&gt;包使用规范&lt;/h2&gt;&#xA;&lt;p&gt;包的习惯用法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;包名一般是小写的，使用一个简短且有意义的名称。&lt;/li&gt;&#xA;&lt;li&gt;包名一般要和所在的目录同名，也可以不同，包名中不能包含- 等特殊符号。&lt;/li&gt;&#xA;&lt;li&gt;包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到GOPATH/src/github.com/userName/projectName 目录下。&lt;/li&gt;&#xA;&lt;li&gt;包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。&lt;/li&gt;&#xA;&lt;li&gt;一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Go 语言中，所有的定义，比如函数、变量、结构体等，如果首字母是大写，那么就可以被其他包使用；同一包下，不存在引用问题。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;基于包的封装&#34;&gt;基于包的封装&lt;/h2&gt;&#xA;&lt;p&gt;在Go语言中封装就是把抽象出来的字段和对字段的操作封装在一起，数据被保护在内部，程序的其它包只能通过被授权的方法，才能对字段进行操作。&lt;/p&gt;&#xA;&lt;p&gt;封装的好处：&#xA;隐藏实现细节；&#xA;可以对数据进行验证，保证数据安全合理。&lt;/p&gt;&#xA;&lt;p&gt;封装的实现步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将结构体、字段的首字母小写；&lt;/li&gt;&#xA;&lt;li&gt;给结构体所在的包提供一个工厂模式的函数，首字母大写，类似一个构造函数；&lt;/li&gt;&#xA;&lt;li&gt;提供一个首字母大写的 Set 方法（类似其它语言的 public），用于对属性判断并赋值；&lt;/li&gt;&#xA;&lt;li&gt;提供一个首字母大写的 Get 方法（类似其它语言的 public），用于获取属性的值。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;包的初始化&#34;&gt;包的初始化&lt;/h2&gt;&#xA;&lt;p&gt;每个包都允许有一个 init 函数，当这个包被导入时，会执行该包的这个 init 函数，做一些初始化任务。&#xA;对于 init 函数的执行有两点需要注意:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;init 函数优先于 main 函数执行&lt;/li&gt;&#xA;&lt;li&gt;在一个包引用链中，包的初始化是深度优先的。比如，有这样一个包引用关系：main→A→B→C，那么初始化顺序为&#xA;C.init→B.init→A.init→main&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;封装引用实例&#34;&gt;封装引用实例&lt;/h2&gt;&#xA;&lt;p&gt;建立如下工程结构，在main包中需要访问model包中的内容。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;project&#xA;|---src&#xA;    |---main&#xA;        -main.go&#xA;    |---model&#xA;        -student.go&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;student.go&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type student struct {&#xA;    Name      string&#xA;    idCardNum string // 私有，外部包不可访问&#xA;    Age       int8&#xA;}&#xA;&#xA;func NewStudent(stuName string, age int8) *student {&#xA;    return &amp;amp;student{&#xA;        Name: stuName,&#xA;        Age:  age,&#xA;    }&#xA;}&#xA;&#xA;// 定义结构体方法&#xA;func (stu *student) SetIdCardNum(idCN string) {&#xA;    stu.idCardNum = idCN&#xA;}&#xA;&#xA;// 定义结构体方法&#xA;func (stu *student) GetIdCardNum() string {&#xA;    return stu.idCardNum&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;main.go&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言channel</title>
      <link>https://qiref.github.io/post/2021/06/09/go%E8%AF%AD%E8%A8%80channel/</link>
      <pubDate>Wed, 09 Jun 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/09/go%E8%AF%AD%E8%A8%80channel/</guid>
      <description>&lt;p&gt;摘要：Go语言中，协程之间通过channel相互通信，可以从一个Go协程将值发送到通道，然后在别的协程中接收。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;channel-定义&#34;&gt;channel 定义&lt;/h2&gt;&#xA;&lt;p&gt;定义channel的语法为：make(chan val-type)，val-type就是需要传递值的类型。 &lt;code&gt;chan1 &amp;lt;- val&lt;/code&gt; 表示将val发送到channel chann1中， &lt;code&gt;r := &amp;lt;- chann1&lt;/code&gt;表示从chann1中读取消息。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Ping(c *chan string, s string) {&#xA;    *c &amp;lt;- s&#xA;}&#xA;&#xA;func Pong(c *chan string) string {&#xA;    return &amp;lt;-*c&#xA;}&#xA;&#xA;// main&#xA;func main() {&#xA;&#xA;    c := make(chan string)&#xA;    go Ping(&amp;amp;c, &amp;quot;ping&amp;quot;)&#xA;    go func() {&#xA;        pong := Pong(&amp;amp;c)&#xA;        fmt.Println(pong)&#xA;    }()&#xA;&#xA;    time.Sleep(time.Second * 2)&#xA;}&#xA;&#xA;// 结果&#xA;// ping&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;需要注意的是，向通道中发送消息和从通道中接收消息，都是阻塞的，如果发送和接收不是成对出现，就会发生错误。&#xA;将上文中代码改成这样：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;c := make(chan string)&#xA;Ping(&amp;amp;c, &amp;quot;ping&amp;quot;)&#xA;//go func() {&#xA;//    pong := Pong(&amp;amp;c)&#xA;//    fmt.Println(pong)&#xA;//}()&#xA;&#xA;time.Sleep(time.Second * 2)&#xA;&#xA;//fatal error: all goroutines are asleep - deadlock!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;channel方向&#34;&gt;channel方向&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func pong(ping &amp;lt;-chan string, pong chan&amp;lt;- string) {&#xA;    msg := &amp;lt;-ping&#xA;    pong &amp;lt;- msg&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;在chan的定义中，箭头的方向是固定的，&lt;code&gt;&amp;lt;-&lt;/code&gt;箭头方向只能向左。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言接口</title>
      <link>https://qiref.github.io/post/2021/06/05/go%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 05 Jun 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/05/go%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3/</guid>
      <description>&lt;p&gt;摘要：Go支持接口，接口是方法特征的命名集合。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;go语言接口&#34;&gt;go语言接口&lt;/h1&gt;&#xA;&lt;p&gt;go语言中有接口的概念，接口是方法特征的命名集合。它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。&lt;/p&gt;&#xA;&lt;p&gt;注意，实现了这些方法就算实现了这个接口。&lt;/p&gt;&#xA;&lt;h2 id=&#34;定义接口&#34;&gt;定义接口&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 定义geometry接口&#xA;type geometry interface {&#xA;    area() float64&#xA;    peri() float64&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;接口的定义也比较简单。定义和实现规则如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/* 定义接口 */&#xA;type interface_name interface {&#xA;   method_name1 [return_type]&#xA;   method_name2 [return_type]&#xA;   method_name3 [return_type]&#xA;   ...&#xA;   method_namen [return_type]&#xA;}&#xA;&#xA;/* 定义结构体 */&#xA;type struct_name struct {&#xA;   /* variables */&#xA;}&#xA;&#xA;/* 实现接口方法 */&#xA;func (struct_name_variable struct_name) method_name1() [return_type] {&#xA;   /* 方法实现 */&#xA;}&#xA;...&#xA;func (struct_name_variable struct_name) method_namen() [return_type] {&#xA;   /* 方法实现*/&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;实现接口&#34;&gt;实现接口&lt;/h2&gt;&#xA;&lt;p&gt;Go语言中接口的实现都是隐式的，默认实现了接口的所有方法就隐式地实现了接口。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言指针</title>
      <link>https://qiref.github.io/post/2021/06/05/go%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</link>
      <pubDate>Sat, 05 Jun 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/05/go%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</guid>
      <description>&lt;p&gt;摘要：Go支持指针，允许在程序中通过引用传递值或者数据结构。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;go语言中的指针和C语言中的指针类似，但比C语言中的指针更简单。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Go语言取地址符号是&amp;amp;，放到变量前会返回对应变量的内存地址&#xA;var i1 int = 1&#xA;var j = i1&#xA;&#xA;fmt.Println(&amp;amp;i1)&#xA;fmt.Println(&amp;amp;j)&#xA;&#xA;// 定义指针变量 var var_name *var_type&#xA;s := &amp;quot;sss&amp;quot;&#xA;p := 2181&#xA;&#xA;var ip *string = &amp;amp;s&#xA;var port *int = &amp;amp;p&#xA;&#xA;fmt.Println(*ip)&#xA;fmt.Println(*port)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。&lt;/p&gt;&#xA;&lt;p&gt;通过&lt;code&gt;&amp;amp;&lt;/code&gt; 获取对应变量的内存地址。 通过&lt;code&gt;*&lt;/code&gt; 获取指针的值，也就是指针取值。取地址操作符 &lt;code&gt;&amp;amp;&lt;/code&gt; 和取值操作符 &lt;code&gt;*&lt;/code&gt; 是一对互补操作符，&lt;code&gt;&amp;amp;&lt;/code&gt; 取出地址，&lt;code&gt;*&lt;/code&gt; 根据地址取出地址指向的值。&lt;/p&gt;&#xA;&lt;p&gt;变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对变量进行取地址操作使用&amp;amp;操作符，可以获得这个变量的指针变量。&lt;/li&gt;&#xA;&lt;li&gt;指针变量的值是指针地址。&lt;/li&gt;&#xA;&lt;li&gt;对指针变量进行取值操作使用*操作符，可以获得指针变量指向的原变量的值。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;通过new创建指针&#34;&gt;通过New()创建指针&lt;/h2&gt;&#xA;&lt;p&gt;Go语言还提供了另外一种方法来创建指针变量，格式如下：&#xA;new(type) 这个type可以为int。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// create ptr by new()&#xA;func createPtr() {&#xA;    str := new(string)&#xA;    *str = &amp;quot;ssss&amp;quot;&#xA;&#xA;    fmt.Println(&amp;quot;str is : &amp;quot;, str)&#xA;    fmt.Println(&amp;quot;*str is : &amp;quot;, *str)&#xA;&#xA;    // str is :  0xc000116050&#xA;    // *str is :  ssss&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言goroutine</title>
      <link>https://qiref.github.io/post/2021/06/03/go%E8%AF%AD%E8%A8%80goroutine/</link>
      <pubDate>Thu, 03 Jun 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/03/go%E8%AF%AD%E8%A8%80goroutine/</guid>
      <description>&lt;p&gt;摘要：Go语言goroutine&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;goroutine协程&#34;&gt;goroutine协程&lt;/h2&gt;&#xA;&lt;p&gt;Go 协程 在执行上来说是轻量级的线程。go语言层面并不支持多进程或多线程，但是协程更好用，协程被称为用户态线程，不存在CPU上下文切换问题，效率非常高。&lt;/p&gt;&#xA;&lt;p&gt;go语言中启动一个协程非常简单，只需要在执行函数前加上go关键字，就可以启用goroutine。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {&#xA;&#xA;    // 使用匿名函数启用goroutine&#xA;    go func() {&#xA;        fmt.Println(&amp;quot;goroutine&amp;quot;)&#xA;    }()&#xA;&#xA;    // 调用函数启用goroutine&#xA;    go func1()&#xA;}&#xA;&#xA;func func1() {&#xA;    fmt.Println(&amp;quot;f1() was called.&amp;quot;)&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;没错就是这么简单，在go语言中，goroutine会被放到运行队列runtime.runqput中，然后由调度器调度。并非是每一个协程都会有一个对应的线程去执行，协程比线程的粒度更细。&lt;/p&gt;&#xA;&lt;p&gt;但是上述代码并不会有输出结果，因为还没等func1()函数执行完成，main()就已经执行完成了。所以在main()函数执行完成之前sleep一下就可以看到func1()的执行结果。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;time.Sleep(time.Second * 1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;waitgroup&#34;&gt;WaitGroup&lt;/h2&gt;&#xA;&lt;p&gt;sleep肯定是不靠谱的，go语言中可以等待协程执行完成后再回到主线程。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 定义全局变量&#xA;var WG = sync.WaitGroup{}&#xA;&#xA;func main() {&#xA;    WG.Add(1)&#xA;    go func1()&#xA;    WG.Wait()&#xA;}&#xA;&#xA;func func1() {&#xA;    fmt.Println(&amp;quot;f1() was called.&amp;quot;)&#xA;    WG.Done()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;在调用func1()之前，调用全局变量WG.Add()方法，然后启用goroutine调用func1()，然后调用WG.Wait()函数进行等待，fun1()调用结束后，调用WG.Done()。&#xA;通过试验可以发现：Add()方法中的数值与Done()方法的数量应该保持一致。当Add(2)时，Done()方法应该执行两次。直到 WaitGroup 计数器恢复为 0； 即所有协程的工作都已经完成。&#xA;看源码可以发现，Done()与Add()实际上是一个函数。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Done decrements the WaitGroup counter by one.&#xA;func (wg *WaitGroup) Done() {&#xA;    wg.Add(-1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;多个goroutine如何执行&#34;&gt;多个goroutine如何执行&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {&#xA;    loop := 5&#xA;    WG.Add(loop)&#xA;    for i := 0; i &amp;lt; loop; i++ {&#xA;        go func2(i)&#xA;    }&#xA;    WG.Wait()&#xA;}&#xA;&#xA;// define func2&#xA;func func2(i int) {&#xA;    fmt.Println(&amp;quot;func2() was called. i is : &amp;quot;, i)&#xA;    WG.Done()&#xA;}&#xA;&#xA;// 运行结果：&#xA;//func2() was called. i is : 4&#xA;//func2() was called. i is : 2&#xA;//func2() was called. i is : 3&#xA;//func2() was called. i is : 0&#xA;//func2() was called. i is : 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;每个goroutine的运行并不规则，每个协程在并发执行。&amp;#x1f914;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言基本数据结构</title>
      <link>https://qiref.github.io/post/2021/06/01/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 01 Jun 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/01/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;p&gt;摘要：Go语言基本数据结构&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;strings := [3]string{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;2&amp;quot;}&#xA;intArray := [8]int{1, 2, 3, 4, 5, 5, 5, 55}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;定义两个数组,&lt;code&gt;fmt.Println(len(strings))&lt;/code&gt; 可以使用&lt;code&gt;len()&lt;/code&gt;函数得到数组的长度，&lt;code&gt;strings[1]&lt;/code&gt;可以获取指定数组下标的元素。&lt;/p&gt;&#xA;&lt;p&gt;所以通过以下方式可以遍历数组：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i := 0; i &amp;lt; len(strings); i++ {&#xA;    fmt.Println(strings[i])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;下文提供了更加优雅的方式。&lt;/p&gt;&#xA;&lt;h2 id=&#34;slice&#34;&gt;slice&lt;/h2&gt;&#xA;&lt;p&gt;Go数组的长度不可变，Go提供了一种内置类型切片:slice，与数组相比，切片的长度不是固定的，可以动态扩容、添加元素。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;slice1 := make([]string, 2)&#xA;fmt.Println(slice1)&#xA;&#xA;slice1[0] = &amp;quot;22&amp;quot;&#xA;slice1[1] = &amp;quot;222&amp;quot;&#xA;fmt.Println(slice1)&#xA;&#xA;slice1 = append(slice1, &amp;quot;33&amp;quot;, &amp;quot;44&amp;quot;, &amp;quot;55&amp;quot;)&#xA;fmt.Println(slice1)&#xA;fmt.Println(len(slice1))&#xA;&#xA;// 裁剪，从index 2 到index 4&#xA;sliceSub := slice1[2:4]&#xA;fmt.Println(sliceSub)&#xA;&#xA;// 裁剪，从index 2 到最后&#xA;sliceSub2 := slice1[2:]&#xA;fmt.Println(sliceSub2)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;make()&lt;/code&gt; 方法可以构建一个slice，并可以指定初始化大小和容量；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;len()&lt;/code&gt; 可以获取slice的大小；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;append()&lt;/code&gt; 可以想slice中添加元素；&lt;/li&gt;&#xA;&lt;li&gt;可以通过裁剪，下标移动等方式删除slice。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;slice从头部删除&#34;&gt;slice从头部删除&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = []int{1, 2, 3}&#xA;a = a[1:] // 删除开头1个元素&#xA;a = a[N:] // 删除开头N个元素&#xA;&#xA;a = append(a[:0], a[1:]...) // 删除开头1个元素&#xA;a = append(a[:0], a[N:]...) // 删除开头N个元素&#xA;&#xA;a = a[:copy(a, a[1:])] // 删除开头1个元素&#xA;a = a[:copy(a, a[N:])] // 删除开头N个元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;slice从中间删除&#34;&gt;slice从中间删除&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a[:i], a[i+1:]...) // 删除中间1个元素&#xA;a = append(a[:i], a[i+N:]...) // 删除中间N个元素&#xA;a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素&#xA;a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;slice从尾部删除&#34;&gt;slice从尾部删除&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = a[:len(a)-1] // 删除尾部1个元素&#xA;a = a[:len(a)-N] // 删除尾部N个元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;slice-扩容&#34;&gt;slice 扩容&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;slice2 := make([]string, 1, 1)&#xA;// cap()函数, 计算slice长度可以达到多少&#xA;fmt.Println(&amp;quot;cap(slice1) is :&amp;quot;, cap(slice1))&#xA;&#xA;slice2[0] = &amp;quot;0&amp;quot;&#xA;&#xA;slice2 = append(slice2, &amp;quot;3&amp;quot;)&#xA;fmt.Println(&amp;quot;cap(slice2) is :&amp;quot;, cap(slice2))&#xA;&#xA;numbers := []int{0, 1, 2, 3, 4, 5}&#xA;&#xA;numbers = append(numbers, 6)&#xA;&#xA;fmt.Println(numbers)&#xA;fmt.Println(cap(numbers))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;通过&lt;code&gt;cap()&lt;/code&gt;函数可以获取slice的容量，容量是&lt;code&gt;make()&lt;/code&gt;函数的第三个参数，超过设置的容量再往slice中添加元素就会使slice扩容。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言变量</title>
      <link>https://qiref.github.io/post/2021/05/31/go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 31 May 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/05/31/go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/</guid>
      <description>&lt;p&gt;摘要：Go语言变量&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;Go语言中的变量定义相对严格，当定义一个局部变量为使用时，会编译报错，在go语言中，无需要多余的代码。但全局变量除外，定义全局变量允许暂不使用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;全局变量&#34;&gt;全局变量&lt;/h2&gt;&#xA;&lt;p&gt;全局变量可以被全局访问&lt;/p&gt;&#xA;&lt;p&gt;定义全局变量：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// global variable&#xA;var x, y int&#xA;&#xA;var (&#xA;    a int&#xA;    b bool&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;基本常量&#34;&gt;基本常量&lt;/h2&gt;&#xA;&lt;p&gt;常量一经被定义后无法被重新赋值，常量可以定义为全局的，也可以定义为局部的。&lt;/p&gt;&#xA;&lt;p&gt;定义常量：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 这是一个常量&#xA;const CONST1 = 111&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;iota常量&#34;&gt;iota常量&lt;/h2&gt;&#xA;&lt;p&gt;iota，特殊常量，可以认为是一个可以被编译器修改的常量。&#xA;iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (&#xA;    a = iota&#xA;    b = iota&#xA;    c = iota&#xA;)&#xA;&#xA;// 以上写法可以简写为&#xA;const (&#xA;    d = iota&#xA;    e&#xA;    f&#xA;)&#xA;&#xA;fmt.Println(a, b, c)&#xA;fmt.Println(d, e, f)&#xA;&#xA;// 输出结果：&#xA;&#xA;// 0 1 2&#xA;// 0 1 2 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;iota常量可以恢复计数&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
