<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kubernates on 大道至简</title>
    <link>https://qiref.github.io/tags/kubernates/</link>
    <description>Recent content in Kubernates on 大道至简</description>
    <generator>Hugo</generator>
    <language>cn-zh</language>
    <lastBuildDate>Tue, 29 Jun 2021 10:18:23 +0000</lastBuildDate>
    <atom:link href="https://qiref.github.io/tags/kubernates/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kubernates中的pod</title>
      <link>https://qiref.github.io/post/2021/06/29/kubernates%E4%B8%AD%E7%9A%84pod/</link>
      <pubDate>Tue, 29 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/29/kubernates%E4%B8%AD%E7%9A%84pod/</guid>
      <description>&lt;p&gt;摘要：运行在Kubernates中的容器：pod。由于不能将多个进程聚集在一个单独的容器中，我们需要一种更高级的结构将容器绑定在一起，将它们作为一个单元进行管理，这就是pod诞生的原因。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;pod基本概念&#34;&gt;pod基本概念&lt;/h2&gt;&#xA;&lt;p&gt;pod是Kubernetes中最重要的概念，pod是Kubernetes中部署的最小单元，一个pod中可以有一个或多个容器，pod有自己独立的私有IP和主机名。&lt;/p&gt;&#xA;&lt;p&gt;Kubernetes 集群中的 Pod 主要有两种用法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;运行单个容器的 Pod。&amp;ldquo;每个 Pod 一个容器&amp;quot;模型是最常见的 Kubernetes 用例； 在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。&lt;/li&gt;&#xA;&lt;li&gt;运行多个协同工作的容器的 Pod。 Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。 这些位于同一位置的容器可能形成单个内聚的服务单元，一个pod中的容器共享网络和volume，并且pod中的容器共享相同的命名空间。（由于一个pod中的容器共享网络，因此也就共享端口和IP。）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;一般情况下，如果不是多个容器需要共用net或volume，尽可能地把不同的容器放到不同的pod中，新建一个pod不需要耗费很多资源，Kubernetes可以很方便地对pod进行管理和扩容、缩容等操作，这种方式可以更好地利用基础资源。&lt;/p&gt;&#xA;&lt;p&gt;总结来说，pod就是逻辑上的主机。&lt;/p&gt;&#xA;&lt;h2 id=&#34;pod生命周期&#34;&gt;pod生命周期&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Pending：表示pod已经被同意创建，正在等待kube-scheduler选择合适的节点创建，一般是在准备镜像；&lt;/li&gt;&#xA;&lt;li&gt;Running：表示pod中所有的容器已经被创建，并且至少有一个容器正在运行或者是正在启动或者是正在重启；&lt;/li&gt;&#xA;&lt;li&gt;Succeeded：表示所有容器已经成功终止，并且不会再启动；&lt;/li&gt;&#xA;&lt;li&gt;Failed：表示pod中所有容器都是非0（不正常）状态退出；&lt;/li&gt;&#xA;&lt;li&gt;Unknown：表示无法读取Pod状态，通常是kube-controller-manager无法与Pod通信。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;创建pod流程&#34;&gt;创建pod流程&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;客户端提交Pod的配置信息（可以是yaml文件定义好的信息）到kube-apiserver；&lt;/li&gt;&#xA;&lt;li&gt;Apiserver收到指令后，通知给controller-manager创建一个资源对象；&lt;/li&gt;&#xA;&lt;li&gt;Controller-manager通过api-server将pod的配置信息存储到ETCD数据中心中；&lt;/li&gt;&#xA;&lt;li&gt;Kube-scheduler检测到pod信息会开始调度预选，会先过滤掉不符合Pod资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行pod的节点，然后将pod的资源配置单发送到node节点上的kubelet组件上。&lt;/li&gt;&#xA;&lt;li&gt;Kubelet根据scheduler发来的资源配置单运行pod，运行成功后，将pod的运行信息返回给scheduler，scheduler将返回的pod运行状况的信息存储到etcd数据中心。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;删除pod流程&#34;&gt;删除pod流程&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;pod从service的endpoint列表中被移除；&lt;/li&gt;&#xA;&lt;li&gt;如果该pod定义了一个停止前的钩子，其会在pod内部被调用，停止钩子一般定义了如何优雅的结束进程；&lt;/li&gt;&#xA;&lt;li&gt;进程被发送TERM信号（kill -14）；&lt;/li&gt;&#xA;&lt;li&gt;当超过优雅退出的时间后，Pod中的所有进程都会被发送SIGKILL信号（kill -9）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;pod常用命令&#34;&gt;pod常用命令&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl describe po cluster-admin-0 -n default # 获取指定namespaces下的pod详情，可以看出container信息&#xA;kubectl get pods --all-namespaces # 获取所有namespaces下的pod&#xA;kubectl get pods -n default # -n 获取指定namaspaces下的pod&#xA;kubectl get pod podname -nkube-system -oyaml # 获取pod的详情，-oyaml 以yaml格式输出，也可以 -ojson&#xA;kubectl exec -it taskcenter-0 -c loglistener -noceanus /bin/bash # 进入某个pod下的cotainer&#xA;kubectl logs tke-log-agent-2687c -c loglistener # 获取某个pod下cotainer的log，也可以加 -f 参数，类似于 tail -f&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;创建pod的方式&#34;&gt;创建pod的方式&lt;/h2&gt;&#xA;&lt;p&gt;pod本身不具备故障重启以及副本等功能，一般使用其他的资源创建pod。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernates组件</title>
      <link>https://qiref.github.io/post/2021/06/21/kubernates%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 21 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/21/kubernates%E7%BB%84%E4%BB%B6/</guid>
      <description>&lt;p&gt;摘要：Kubernates基础概念及其组件。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;Kubernetes是一个开源的容器编排引擎，用来对容器化应用进行自动化部署、扩缩容和管理，简称K8s，K8s 这个缩写是因为k和s之间有八个字符。Google 在 2014 年开源了 Kubernetes 项目。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/components-of-kubernetes.svg&#34; alt=&#34;kubernetes&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;控制面组件&#34;&gt;控制面组件&lt;/h2&gt;&#xA;&lt;h3 id=&#34;kube-apiserver&#34;&gt;kube-apiserver&lt;/h3&gt;&#xA;&lt;p&gt;apiserver是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。&lt;/p&gt;&#xA;&lt;h3 id=&#34;etcd&#34;&gt;etcd&lt;/h3&gt;&#xA;&lt;p&gt;etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。&lt;/p&gt;&#xA;&lt;h3 id=&#34;kube-scheduler&#34;&gt;kube-scheduler&lt;/h3&gt;&#xA;&lt;p&gt;负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。&lt;/p&gt;&#xA;&lt;p&gt;调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。&lt;/p&gt;&#xA;&lt;h3 id=&#34;kube-controller-manager&#34;&gt;kube-controller-manager&lt;/h3&gt;&#xA;&lt;p&gt;从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。&lt;/p&gt;&#xA;&lt;p&gt;这些控制器包括:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应&lt;/li&gt;&#xA;&lt;li&gt;任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成&lt;/li&gt;&#xA;&lt;li&gt;端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)&lt;/li&gt;&#xA;&lt;li&gt;服务帐户和令牌控制器（Service Account &amp;amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;cloud-controller-manager&#34;&gt;cloud-controller-manager&lt;/h3&gt;&#xA;&lt;p&gt;云控制器管理器是指嵌入特定云的控制逻辑的 控制平面组件。 云控制器管理器允许您链接集群到云提供商的应用编程接口中， 并把和该云平台交互的组件与只和您的集群交互的组件分离开。&#xA;cloud-controller-manager 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
