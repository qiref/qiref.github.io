<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on 大道至简</title>
    <link>https://qiref.github.io/tags/java/</link>
    <description>Recent content in Java on 大道至简</description>
    <generator>Hugo</generator>
    <language>cn-zh</language>
    <lastBuildDate>Mon, 26 Jun 2023 21:55:00 +0800</lastBuildDate>
    <atom:link href="https://qiref.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Java进程分析工具</title>
      <link>https://qiref.github.io/post/2023/06/26/java%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 26 Jun 2023 21:55:00 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/06/26/java%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;h2 id=&#34;jvm-内存区域&#34;&gt;JVM 内存区域&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/jvm-area.svg&#34; alt=&#34;jvm-area&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果要为&lt;code&gt;新生代&lt;/code&gt;分配 &lt;code&gt;256m&lt;/code&gt; 的内存（&lt;code&gt;NewSize&lt;/code&gt; 与 &lt;code&gt;MaxNewSize&lt;/code&gt; 设为一致），参数应该这样来写：&lt;code&gt;-Xmn256m&lt;/code&gt;;&lt;/p&gt;&#xA;&lt;p&gt;还可以通过 &lt;code&gt;-XX:NewRatio=&amp;lt;int&amp;gt;&lt;/code&gt; 来设置&lt;code&gt;老年代&lt;/code&gt;与&lt;code&gt;新生代&lt;/code&gt;内存的比值。比如以下参数就是设置老年代与新生代内存的比值为 1。也就是说老年代和新生代所占比值为 1：1，新生代占整个堆栈的 1/2。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;-XX:NewRatio=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;JDK 1.8 ，方法区（HotSpot 的永久代）被彻底移除了，取而代之是元空间 Metaspace，元空间使用的是本地内存。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Metaspace 的初始容量并不是 &lt;code&gt;-XX:MetaspaceSize&lt;/code&gt; 设置，无论 &lt;code&gt;-XX:MetaspaceSize&lt;/code&gt; 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）。可以参考 Oracle 官方文档 :&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Specify a higher value for the option MetaspaceSize to avoid early garbage collections induced for class metadata. The amount of class metadata allocated for an application is application-dependent and general guidelines do not exist for the selection of MetaspaceSize. The default size of MetaspaceSize is platform-dependent and ranges from 12 MB to about 20 MB.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java双亲委派</title>
      <link>https://qiref.github.io/post/2023/03/24/java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</link>
      <pubDate>Fri, 24 Mar 2023 15:46:27 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/03/24/java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</guid>
      <description>&lt;h2 id=&#34;类加载器&#34;&gt;类加载器&lt;/h2&gt;&#xA;&lt;p&gt;Java语言系统中支持以下4种类加载器：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bootstrap ClassLoader 启动类加载器，主要负责加载Java核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等；&lt;/li&gt;&#xA;&lt;li&gt;Extension ClassLoader 标准扩展类加载器，主要负责加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件；&lt;/li&gt;&#xA;&lt;li&gt;Application ClassLoader 应用类加载器，主要负责加载当前应用的classpath下的所有类；&lt;/li&gt;&#xA;&lt;li&gt;User ClassLoader 用户自定义类加载器，用户自定义的类加载器,可加载指定路径的class文件；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/java-class-loader.svg&#34; alt=&#34;java类加载器&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;双亲委派&#34;&gt;双亲委派&lt;/h2&gt;&#xA;&lt;p&gt;类加载器采用了双亲委派模式，其工作原理是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。&lt;/p&gt;&#xA;&lt;p&gt;双亲委派模式的好处是什么？&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层次关系可以避免类的重复加载，当父类加载器已经加载过一次时，没有必要子类再去加载一次。&lt;/li&gt;&#xA;&lt;li&gt;考虑到安全因素，Java 核心 Api 类不会被随意替换，核心类永远是被上层的类加载器加载。如果我们自己定义了一个 java.lang.String 类，它会优先委派给 BootStrapClassLoader 去加载，加载完了就直接返回了。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;如果我们定义了一个 java.lang.ExtString，能被加载吗？答案也是不能的，因为 java.lang 包是有权限控制的，自定义了这个包，会报一个错如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java.lang.SecurityException: Prohibited package name: java.lang&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;源码分析&#34;&gt;源码分析&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)&#xA;        throws ClassNotFoundException&#xA;    {&#xA;        synchronized (getClassLoadingLock(name)) {&#xA;            // 首先，检查这个类是否已经被加载了，最终实现是一个 native 本地实现&#xA;            Class&amp;lt;?&amp;gt; c = findLoadedClass(name);&#xA;            // 如果还没有被加载，则开始加载&#xA;            if (c == null) {&#xA;                long t0 = System.nanoTime();&#xA;                try {&#xA;                    // 首先如果父加载器不为空，则使用父类加载器加载。Launcher 类里提到的 parent 就在这里使用的。&#xA;                    if (parent != null) {&#xA;                        c = parent.loadClass(name, false);&#xA;                    } else {&#xA;                        // 如果父加载器为空（比如 ExtClassLoader），就使用 BootStrapClassloader 来加载&#xA;                        c = findBootstrapClassOrNull(name);&#xA;                    }&#xA;                } catch (ClassNotFoundException e) {&#xA;                }&#xA;                &#xA;                // 如果还没有找到，则使用 findClass 类来加载。也就是说如果我们自定义类加载器，就重写这个方法&#xA;                if (c == null) {&#xA;                    long t1 = System.nanoTime();&#xA;                    c = findClass(name);&#xA;&#xA;                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);&#xA;                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);&#xA;                    sun.misc.PerfCounter.getFindClasses().increment();&#xA;                }&#xA;            }&#xA;            if (resolve) {&#xA;                resolveClass(c);&#xA;            }&#xA;            return c;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;如何主动破坏双亲委派机制&#34;&gt;如何主动破坏双亲委派机制&lt;/h2&gt;&#xA;&lt;p&gt;双亲委派过程都是在loadClass方法中实现的，那么&lt;strong&gt;想要破坏这种机制，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>SpringBoot中使用AOP</title>
      <link>https://qiref.github.io/post/2019/06/16/springboot%E4%B8%AD%E4%BD%BF%E7%94%A8aop/</link>
      <pubDate>Sun, 16 Jun 2019 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2019/06/16/springboot%E4%B8%AD%E4%BD%BF%E7%94%A8aop/</guid>
      <description>&lt;p&gt;摘要：Spring中如何使用注解实现面向切面编程，以及如何使用自定义注解。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;场景&#34;&gt;场景&lt;/h2&gt;&#xA;&lt;p&gt;比如用户登录，每个请求发起之前都会判断用户是否登录，如果每个请求都去判断一次，那就重复地做了很多事情，只要是有重复的地方，就有优化的空间。现在就把重复的地方抽取出来，暂且称之为 &amp;quot; 拦截器 &amp;ldquo;，然后每次请求之前就先经过&amp;rdquo; 拦截器 &amp;ldquo;，这个编程的思想就可以称之为面向切面编程。AOP(Aspect  Oriented Program)&lt;/p&gt;&#xA;&lt;p&gt;最典型的应用就是事务管理和权限验证，还有日志统计，下文中的案例就是接口执行时间的统计。&lt;/p&gt;&#xA;&lt;h2 id=&#34;spring中使用aop基于注解&#34;&gt;spring中使用AOP（基于注解）&lt;/h2&gt;&#xA;&lt;p&gt;不得不说注解是个很巧妙的设计，使用很少量的信息描述数据，这类数据称之为元数据，描述数据的数据。关于注解的理解，这里有个传送门：http://www.importnew.com/10294.html&lt;/p&gt;&#xA;&lt;p&gt;下面的案例是在springBoot中进行的，直观地感受一下如何使用注解完成AOP。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service&#xA;public class UserService {&#xA;&#xA;    public void getUser() {&#xA;        //To do something&#xA;        System.out.println(&amp;quot;getUser() has been called&amp;quot;);&#xA;        try {&#xA;            Thread.sleep(1000);&#xA;        } catch (InterruptedException e) {&#xA;            e.printStackTrace();&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;切面是这样定义的：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&#xA;@Component&#xA;@Aspect&#xA;public class LoggerAspect {&#xA;    /**&#xA;     * getUser()执行之前执行&#xA;     */&#xA;    @Before(&amp;quot;execution(* com.springboot.demo.service.UserService.getUser(..))&amp;quot;)&#xA;    public void callBefore() {&#xA;        System.out.println(&amp;quot;before call method&amp;quot;);&#xA;        System.out.println(&amp;quot;begin........................&amp;quot;);&#xA;    }&#xA;&#xA;    /**&#xA;     * getUser()执行之后执行&#xA;     */&#xA;    @After(&amp;quot;execution(* com.springboot.demo.service.UserService.getUser(..))&amp;quot;)&#xA;    public void callAfter() {&#xA;        System.out.println(&amp;quot;after call method&amp;quot;);&#xA;        System.out.println(&amp;quot;end..............................&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;来个单元测试验证一下：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
