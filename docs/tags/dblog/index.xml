<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DBLog on 大道至简</title>
    <link>https://qiref.github.io/tags/dblog/</link>
    <description>Recent content in DBLog on 大道至简</description>
    <generator>Hugo</generator>
    <language>cn-zh</language>
    <lastBuildDate>Wed, 09 Aug 2023 10:39:17 +0800</lastBuildDate>
    <atom:link href="https://qiref.github.io/tags/dblog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>DBLog 阅读笔记</title>
      <link>https://qiref.github.io/post/2023/08/09/dblog-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 09 Aug 2023 10:39:17 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/08/09/dblog-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;&#xA;&lt;p&gt;论文原名: &lt;code&gt;DBLog: A Watermark Based Change-Data-Capture Framework&lt;/code&gt; , 基于 &lt;code&gt;Watermark&lt;/code&gt; 的 &lt;code&gt;Change-Data-Capture&lt;/code&gt;(数据库实时捕获已提交的变更记录) 框架, 本质上是解决数据库同步(全量+增量)的框架, &lt;code&gt;Watermark&lt;/code&gt; 是框架使用的一种手段, 在源表中创建表,生成唯一 uuid 并更新表数据, 在源表中就会生成一条变更记录,记作 &lt;code&gt;Watermark&lt;/code&gt; 的变更记录, 通过 &lt;code&gt;High Watermark&lt;/code&gt; 和 &lt;code&gt;Low Watermark &lt;/code&gt; 将变更记录分割, 保证 select chunk 数据包含了增量的变更记录.&lt;/p&gt;&#xA;&lt;p&gt;框架整体架构如下:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/DBLog-1.svg&#34; alt=&#34;DBLog-1&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;框架特点:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;按顺序处理捕获到的 &lt;code&gt;changelog&lt;/code&gt;;&lt;/li&gt;&#xA;&lt;li&gt;转储可以随时进行，跨所有表，针对一个特定的表或者针对一个表的具体主键;&lt;/li&gt;&#xA;&lt;li&gt;以块(chunk)的形式获取转储，日志与转储事件交错。通过这种方式，&lt;code&gt;changelog&lt;/code&gt; 可以与转储处理一起进行。如果进程终止，它可以在最后一个完成的块之后恢复，而不需要从头开始。这还允许在需要时对转储进行调整和暂停;&lt;/li&gt;&#xA;&lt;li&gt;不会获取表级锁，这可以防止影响源数据库上的写流量;&lt;/li&gt;&#xA;&lt;li&gt;支持任何类型的输出，因此，输出可以是流、数据存储甚或是 API;&lt;/li&gt;&#xA;&lt;li&gt;设计充分考虑了高可用性。因此，下游的消费者可以放心，只要源端发生变化，它们就可以收到变化事件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;注意, 本文并非详细介绍 &lt;code&gt;DBLog&lt;/code&gt; 框架本身, 而是分析其框架背后的设计思路.&lt;/p&gt;&#xA;&lt;h2 id=&#34;算法流程&#34;&gt;算法流程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;chunk-划分&#34;&gt;chunk 划分&lt;/h3&gt;&#xA;&lt;p&gt;对于源表数据, 全量数据使用分块读取, 基于 &lt;code&gt;primary key&lt;/code&gt; 顺序排序, 将全量数据划分为 N 个 chunk;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/DBLog-2.svg&#34; alt=&#34;DBLog-2&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;watermark&#34;&gt;watermark&lt;/h3&gt;&#xA;&lt;p&gt;基于 chunk 划分, 然后 chunk 数据全量写入下游之后, 再将源表的变更记录 &lt;code&gt;changelog&lt;/code&gt; 增量同步到下游, 整体思路就是这样, 但是划分 chunk 有个问题需要解决, 就是先同步到下游的数据不一定的最终的数据, 例如上图 chunk1 中的数据在同步到下游之后可能会删除, 那chunk1 的数据写到下游之后, 下游就会出现脏数据; 如何解决 chunk 和 &lt;code&gt;changelog&lt;/code&gt; 之间不会相互覆盖的问题?&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
