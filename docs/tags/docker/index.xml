<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Docker on 大道至简</title>
    <link>https://qiref.github.io/tags/docker/</link>
    <description>Recent content in Docker on 大道至简</description>
    <generator>Hugo</generator>
    <language>cn-zh</language>
    <lastBuildDate>Wed, 23 Jun 2021 10:18:23 +0000</lastBuildDate>
    <atom:link href="https://qiref.github.io/tags/docker/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Docker构建Go工程镜像</title>
      <link>https://qiref.github.io/post/2021/06/23/docker%E6%9E%84%E5%BB%BAgo%E5%B7%A5%E7%A8%8B%E9%95%9C%E5%83%8F/</link>
      <pubDate>Wed, 23 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/23/docker%E6%9E%84%E5%BB%BAgo%E5%B7%A5%E7%A8%8B%E9%95%9C%E5%83%8F/</guid>
      <description>&lt;p&gt;摘要：Docker构建Go工程镜像。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;工程&#34;&gt;工程&lt;/h2&gt;&#xA;&lt;p&gt;工程是一个比较简单的Http server的demo，现在将这个工程构建为docker镜像。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;)&#xA;&#xA;func Init() {&#xA;    log.Println(&amp;quot;start server&amp;quot;)&#xA;    http.HandleFunc(&amp;quot;/hello_world&amp;quot;, HelloWorld)&#xA;    http.Handle(&amp;quot;/test_handle&amp;quot;, &amp;amp;TestHandleStruct{content: &amp;quot;test handle&amp;quot;})&#xA;    if err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil); err != nil {&#xA;        log.Println(&amp;quot;start server on 8080&amp;quot;)&#xA;    }&#xA;    log.Fatal(&amp;quot;start server failed.&amp;quot;)&#xA;}&#xA;&#xA;func main() {&#xA;    // 启动HTTP服务&#xA;    server.Init()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;构建&#34;&gt;构建&lt;/h2&gt;&#xA;&lt;p&gt;需要在工程根目录下新建一个Dockerfile&lt;/p&gt;&#xA;&lt;p&gt;内容如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-docker&#34;&gt;# 拉取Go语言的版本&#xA;FROM golang:1.16&#xA;&#xA;# 在容器内设置工作目录&#xA;WORKDIR /app&#xA;&#xA;# 把文件复制到当前工作目录&#xA;COPY . .&#xA;&#xA;FROM alpine:latest as prod&#xA;&#xA;# 设置GOPROXY的环境变量&#xA;ENV GOPROXY=&amp;quot;https://goproxy.cn&amp;quot;&#xA;&#xA;# 编译项目&#xA;#RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64  go build -o ./bin/go_http_server_demo ./src/main/main.go&#xA;&#xA;ADD ./bin/go_http_server_demo ./&#xA;&#xA;# 暴露端口&#xA;EXPOSE 8080&#xA;&#xA;# 可执行文件&#xA;CMD [&amp;quot;./go_http_server_demo&amp;quot;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;然后到根目录下编译项目，注意编译时要根据当前机器的类型设置环境变量：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker入门</title>
      <link>https://qiref.github.io/post/2021/06/21/docker%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 21 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/21/docker%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;p&gt;摘要：Docker简单使用。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言开发，并遵从 Apache2.0 协议开源。&#xA;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&#xA;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;&#xA;&lt;p&gt;Docker下载地址：&lt;a href=&#34;https://www.docker.com/get-started&#34;&gt;https://www.docker.com/get-started&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;安装完成后，才可以执行docker的相关命令。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker system info&#xA;&#xA;Client:&#xA; Context:    default&#xA; Debug Mode: false&#xA; Plugins:&#xA;  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)&#xA;  compose: Docker Compose (Docker Inc., 2.0.0-beta.3)&#xA;  scan: Docker Scan (Docker Inc., v0.8.0)&#xA;&#xA;Server:&#xA; Containers: 0&#xA;  Running: 0&#xA;  Paused: 0&#xA;  Stopped: 0&#xA; Images: 0&#xA; Server Version: 20.10.7&#xA; Storage Driver: overlay2&#xA;  Backing Filesystem: extfs&#xA;  Supports d_type: true&#xA;  Native Overlay Diff: true&#xA;  userxattr: false&#xA; Logging Driver: json-file&#xA; Cgroup Driver: cgroupfs&#xA; Cgroup Version: 1&#xA; Plugins:&#xA;  Volume: local&#xA;  Network: bridge host ipvlan macvlan null overlay&#xA;  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog&#xA; Swarm: inactive&#xA; Runtimes: runc io.containerd.runc.v2 io.containerd.runtime.v1.linux&#xA; Default Runtime: runc&#xA; Init Binary: docker-init&#xA; containerd version: d71fcd7d8303cbf684402823e425e9dd2e99285d&#xA; runc version: b9ee9c6314599f1b4a7f497e1f1f856fe433d3b7&#xA; init version: de40ad0&#xA; Security Options:&#xA;  seccomp&#xA;   Profile: default&#xA; Kernel Version: 5.10.25-linuxkit&#xA; Operating System: Docker Desktop&#xA; OSType: linux&#xA; Architecture: x86_64&#xA; CPUs: 6&#xA; Total Memory: 1.941GiB&#xA; Name: docker-desktop&#xA; ID: TA2L:IL5R:BGA2:7NS2:RE5C:LOZ6:7RHP:275V:F5OQ:KAJP:QHWN:VOQU&#xA; Docker Root Dir: /var/lib/docker&#xA; Debug Mode: false&#xA; HTTP Proxy: http.docker.internal:3128&#xA; HTTPS Proxy: http.docker.internal:3128&#xA; Registry: https://index.docker.io/v1/&#xA; Labels:&#xA; Experimental: false&#xA; Insecure Registries:&#xA;  127.0.0.0/8&#xA; Live Restore Enabled: false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;mac上停止docker服务：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
