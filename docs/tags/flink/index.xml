<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Flink on 大道至简</title>
    <link>https://qiref.github.io/tags/flink/</link>
    <description>Recent content in Flink on 大道至简</description>
    <generator>Hugo</generator>
    <language>cn-zh</language>
    <lastBuildDate>Fri, 26 Dec 2025 11:39:10 +0800</lastBuildDate>
    <atom:link href="https://qiref.github.io/tags/flink/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Flink源码 Jobmanager作业提交与调度</title>
      <link>https://qiref.github.io/post/2025/12/26/flink%E6%BA%90%E7%A0%81-jobmanager%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E4%B8%8E%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Fri, 26 Dec 2025 11:39:10 +0800</pubDate>
      <guid>https://qiref.github.io/post/2025/12/26/flink%E6%BA%90%E7%A0%81-jobmanager%E4%BD%9C%E4%B8%9A%E6%8F%90%E4%BA%A4%E4%B8%8E%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;p&gt;详细梳理 Flink 中从 Client 提交作业到任务在 TaskManager 上执行的完整流程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-整体流程概览&#34;&gt;1. 整体流程概览&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;Client 提交 JobGraph&#xA;       ↓&#xA;REST API (JobSubmitHandler)    -- 接收 HTTP 请求，解析 JobGraph&#xA;       ↓&#xA;Dispatcher.submitJob()         -- 作业提交入口，创建 JobManagerRunner&#xA;       ↓&#xA;JobManagerRunner.start()       -- 启动 Leader 选举&#xA;       ↓&#xA;grantLeadership()              -- 获得 Leadership&#xA;       ↓&#xA;JobMasterServiceProcess        -- 创建 JobMaster&#xA;       ↓&#xA;JobMaster.onStart()            -- JobMaster 启动，触发调度&#xA;       ↓&#xA;SchedulerBase.startScheduling  -- 创建 ExecutionGraph，开始调度&#xA;       ↓&#xA;SchedulingStrategy             -- 调度策略，决定任务调度顺序&#xA;       ↓&#xA;ExecutionDeployer              -- 分配 Slot，部署任务&#xA;       ↓&#xA;TaskManagerGateway             -- RPC 调用，提交任务到 TaskManager&#xA;       ↓&#xA;TaskExecutor.submitTask()      -- 创建 Task，启动执行线程&#xA;       ↓&#xA;Task.run()                     -- 执行用户代码&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;2-核心类和文件位置&#34;&gt;2. 核心类和文件位置&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-作业提交相关&#34;&gt;2.1 作业提交相关&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;JobSubmitHandler&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../rest/handler/job/JobSubmitHandler.java&lt;/code&gt; - REST API 处理作业提交&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Dispatcher&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../dispatcher/Dispatcher.java&lt;/code&gt; - 作业提交入口，管理多个作业&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;JobManagerRunner&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../jobmaster/JobManagerRunner.java&lt;/code&gt; - 管理单个作业的生命周期&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;JobMasterServiceLeadershipRunner&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../jobmaster/JobMasterServiceLeadershipRunner.java&lt;/code&gt; - Leader 选举和 JobMaster 创建&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;22-调度核心类&#34;&gt;2.2 调度核心类&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;JobMaster&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../jobmaster/JobMaster.java&lt;/code&gt; - 作业主节点，管理单个作业&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;SchedulerNG&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../scheduler/SchedulerNG.java&lt;/code&gt; - 调度器接口&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;SchedulerBase&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../scheduler/SchedulerBase.java&lt;/code&gt; - 调度器基类&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;DefaultScheduler&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../scheduler/DefaultScheduler.java&lt;/code&gt; - 默认调度器实现&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;23-执行图相关类&#34;&gt;2.3 执行图相关类&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;ExecutionGraph&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../executiongraph/ExecutionGraph.java&lt;/code&gt; - 执行图接口&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;DefaultExecutionGraph&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../executiongraph/DefaultExecutionGraph.java&lt;/code&gt; - 执行图实现&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ExecutionJobVertex&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../executiongraph/ExecutionJobVertex.java&lt;/code&gt; - 对应 JobVertex 的运行时表示&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ExecutionVertex&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../executiongraph/ExecutionVertex.java&lt;/code&gt; - 单个并行子任务的运行时表示&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Execution&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../executiongraph/Execution.java&lt;/code&gt; - 一次执行尝试&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;24-调度策略和部署类&#34;&gt;2.4 调度策略和部署类&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;SchedulingStrategy&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../scheduler/strategy/SchedulingStrategy.java&lt;/code&gt; - 调度策略接口&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;PipelinedRegionSchedulingStrategy&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../scheduler/strategy/PipelinedRegionSchedulingStrategy.java&lt;/code&gt; - 流水线区域调度策略&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ExecutionDeployer&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../scheduler/ExecutionDeployer.java&lt;/code&gt; - 执行部署器接口&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;DefaultExecutionDeployer&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../scheduler/DefaultExecutionDeployer.java&lt;/code&gt; - 默认执行部署器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;25-taskmanager-相关&#34;&gt;2.5 TaskManager 相关&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;TaskExecutor&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../taskexecutor/TaskExecutor.java&lt;/code&gt; - TaskManager 主类&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Task&lt;/strong&gt; - &lt;code&gt;flink-runtime/.../taskmanager/Task.java&lt;/code&gt; - 任务执行实例&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;StreamTask&lt;/strong&gt; - &lt;code&gt;flink-streaming-java/.../runtime/tasks/StreamTask.java&lt;/code&gt; - 流式任务执行&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;3-阶段一client-提交作业&#34;&gt;3. 阶段一：Client 提交作业&lt;/h2&gt;&#xA;&lt;h3 id=&#34;31-rest-请求路由机制&#34;&gt;3.1 REST 请求路由机制&lt;/h3&gt;&#xA;&lt;p&gt;Client 提交作业时，HTTP 请求经过以下路由过程到达 Dispatcher：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink源码-CompletableFuture异步编程</title>
      <link>https://qiref.github.io/post/2025/12/25/flink%E6%BA%90%E7%A0%81-completablefuture%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Thu, 25 Dec 2025 12:05:41 +0800</pubDate>
      <guid>https://qiref.github.io/post/2025/12/25/flink%E6%BA%90%E7%A0%81-completablefuture%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</guid>
      <description>&lt;h2 id=&#34;1-基础概念&#34;&gt;1. 基础概念&lt;/h2&gt;&#xA;&lt;h3 id=&#34;11-什么是-completablefuture&#34;&gt;1.1 什么是 CompletableFuture&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;CompletableFuture&lt;/code&gt; 是 Java 8 引入的异步编程工具，它代表一个可能尚未完成的异步计算结果。与传统的 &lt;code&gt;Future&lt;/code&gt; 相比，它支持：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;非阻塞回调&lt;/strong&gt;：不需要调用 &lt;code&gt;get()&lt;/code&gt; 阻塞等待&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;链式操作&lt;/strong&gt;：可以将多个异步操作串联起来&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;组合操作&lt;/strong&gt;：可以组合多个异步操作的结果&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;异常处理&lt;/strong&gt;：提供优雅的异常处理机制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;12-同步-vs-异步对比&#34;&gt;1.2 同步 vs 异步对比&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ==================== 同步方式 - 阻塞等待 ====================&#xA;public String processSync() {&#xA;    String result1 = step1();           // 阻塞 2 秒&#xA;    String result2 = step2(result1);    // 阻塞 2 秒&#xA;    String result3 = step3(result2);    // 阻塞 2 秒&#xA;    return result3;                     // 总耗时: 6 秒&#xA;}&#xA;&#xA;// ==================== 异步方式 - 非阻塞 ====================&#xA;public CompletableFuture&amp;lt;String&amp;gt; processAsync() {&#xA;    return CompletableFuture&#xA;        .supplyAsync(() -&amp;gt; step1())              // 异步执行&#xA;        .thenApplyAsync(result1 -&amp;gt; step2(result1))  // 链式处理&#xA;        .thenApplyAsync(result2 -&amp;gt; step3(result2)); // 继续链式&#xA;    // 主线程立即返回，不阻塞&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;13-核心接口关系&#34;&gt;1.3 核心接口关系&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;                    ┌─────────────────┐&#xA;                    │     Future      │&#xA;                    └────────┬────────┘&#xA;                             │&#xA;              ┌──────────────┴─────────────┐&#xA;              │                            │&#xA;    ┌─────────┴─────────┐       ┌──────────┴──────────┐&#xA;    │  CompletionStage  │       │   CompletableFuture │&#xA;    │   (接口)           │◄------│   (实现类)           │&#xA;    └───────────────────┘       └─────────────────────┘&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;2-创建-completablefuture&#34;&gt;2. 创建 CompletableFuture&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-已完成的-future&#34;&gt;2.1 已完成的 Future&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建一个已经完成的 Future（成功）&#xA;CompletableFuture&amp;lt;String&amp;gt; completed = CompletableFuture.completedFuture(&amp;quot;result&amp;quot;);&#xA;System.out.println(completed.isDone());  // true&#xA;System.out.println(completed.get());     // &amp;quot;result&amp;quot;&#xA;&#xA;// 创建一个已经完成的 Future（失败）- Java 9+&#xA;CompletableFuture&amp;lt;String&amp;gt; failed = CompletableFuture.failedFuture(&#xA;    new RuntimeException(&amp;quot;error&amp;quot;));&#xA;&#xA;// Java 8 兼容写法&#xA;CompletableFuture&amp;lt;String&amp;gt; failedJava8 = new CompletableFuture&amp;lt;&amp;gt;();&#xA;failedJava8.completeExceptionally(new RuntimeException(&amp;quot;error&amp;quot;));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;22-异步执行有返回值的任务---supplyasync&#34;&gt;2.2 异步执行有返回值的任务 - supplyAsync&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 使用默认线程池（ForkJoinPool.commonPool()）&#xA;CompletableFuture&amp;lt;String&amp;gt; future1 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    System.out.println(&amp;quot;执行线程: &amp;quot; + Thread.currentThread().getName());&#xA;    // 模拟耗时操作&#xA;    try {&#xA;        Thread.sleep(1000);&#xA;    } catch (InterruptedException e) {&#xA;        Thread.currentThread().interrupt();&#xA;    }&#xA;    return &amp;quot;async result&amp;quot;;&#xA;});&#xA;&#xA;// 使用自定义线程池&#xA;ExecutorService executor = Executors.newFixedThreadPool(4);&#xA;CompletableFuture&amp;lt;String&amp;gt; future2 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    return &amp;quot;custom executor result&amp;quot;;&#xA;}, executor);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;23-异步执行无返回值的任务---runasync&#34;&gt;2.3 异步执行无返回值的任务 - runAsync&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 无返回值的异步任务&#xA;CompletableFuture&amp;lt;Void&amp;gt; future = CompletableFuture.runAsync(() -&amp;gt; {&#xA;    System.out.println(&amp;quot;执行异步任务，线程: &amp;quot; + Thread.currentThread().getName());&#xA;    // 执行一些操作，没有返回值&#xA;    doSomething();&#xA;});&#xA;&#xA;// 等待完成&#xA;future.join();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;24-手动创建并控制完成&#34;&gt;2.4 手动创建并控制完成&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 手动创建 CompletableFuture&#xA;CompletableFuture&amp;lt;String&amp;gt; manualFuture = new CompletableFuture&amp;lt;&amp;gt;();&#xA;&#xA;// 在另一个线程中完成它&#xA;new Thread(() -&amp;gt; {&#xA;    try {&#xA;        Thread.sleep(2000);&#xA;        // 正常完成&#xA;        manualFuture.complete(&amp;quot;manual result&amp;quot;);&#xA;        &#xA;        // 或者异常完成&#xA;        // manualFuture.completeExceptionally(new RuntimeException(&amp;quot;error&amp;quot;));&#xA;    } catch (InterruptedException e) {&#xA;        manualFuture.completeExceptionally(e);&#xA;    }&#xA;}).start();&#xA;&#xA;// 主线程可以等待结果&#xA;String result = manualFuture.get();  // 阻塞等待&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;3-链式处理&#34;&gt;3. 链式处理&lt;/h2&gt;&#xA;&lt;h3 id=&#34;31-thenapply---转换结果同步&#34;&gt;3.1 thenApply - 转换结果（同步）&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// thenApply: 对结果进行同步转换&#xA;// Function&amp;lt;T, U&amp;gt;: 接收 T 类型，返回 U 类型&#xA;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; 42)                          // Integer&#xA;    .thenApply(num -&amp;gt; num * 2)                      // Integer -&amp;gt; Integer&#xA;    .thenApply(num -&amp;gt; &amp;quot;Result: &amp;quot; + num);            // Integer -&amp;gt; String&#xA;&#xA;System.out.println(future.get());  // &amp;quot;Result: 84&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;32-thenapplyasync---转换结果异步&#34;&gt;3.2 thenApplyAsync - 转换结果（异步）&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// thenApplyAsync: 在异步线程中执行转换&#xA;ExecutorService executor = Executors.newFixedThreadPool(2);&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; {&#xA;        System.out.println(&amp;quot;Step 1: &amp;quot; + Thread.currentThread().getName());&#xA;        return 42;&#xA;    })&#xA;    .thenApplyAsync(num -&amp;gt; {&#xA;        System.out.println(&amp;quot;Step 2: &amp;quot; + Thread.currentThread().getName());&#xA;        return num * 2;&#xA;    }, executor)  // 使用自定义线程池&#xA;    .thenApplyAsync(num -&amp;gt; {&#xA;        System.out.println(&amp;quot;Step 3: &amp;quot; + Thread.currentThread().getName());&#xA;        return &amp;quot;Result: &amp;quot; + num;&#xA;    });  // 使用默认线程池&#xA;&#xA;executor.shutdown();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;33-thenaccept---消费结果无返回值&#34;&gt;3.3 thenAccept - 消费结果（无返回值）&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// thenAccept: 消费结果，不返回新值&#xA;// Consumer&amp;lt;T&amp;gt;: 接收 T 类型，无返回值&#xA;CompletableFuture&amp;lt;Void&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; &amp;quot;Hello&amp;quot;)&#xA;    .thenApply(s -&amp;gt; s + &amp;quot; World&amp;quot;)&#xA;    .thenAccept(result -&amp;gt; {&#xA;        System.out.println(&amp;quot;最终结果: &amp;quot; + result);&#xA;        // 可以在这里保存到数据库、发送通知等&#xA;    });&#xA;&#xA;future.join();  // 等待完成&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;34-thenrun---执行后续操作不关心结果&#34;&gt;3.4 thenRun - 执行后续操作（不关心结果）&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// thenRun: 不关心前一步的结果，只是在完成后执行某些操作&#xA;// Runnable: 无参数，无返回值&#xA;CompletableFuture&amp;lt;Void&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; {&#xA;        System.out.println(&amp;quot;执行主要任务&amp;quot;);&#xA;        return &amp;quot;result&amp;quot;;&#xA;    })&#xA;    .thenRun(() -&amp;gt; {&#xA;        System.out.println(&amp;quot;任务完成，执行清理操作&amp;quot;);&#xA;        // 清理资源、记录日志等&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;35-thencompose---扁平化嵌套-future重要&#34;&gt;3.5 thenCompose - 扁平化嵌套 Future（重要！）&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 问题：thenApply 会产生嵌套的 CompletableFuture&#xA;CompletableFuture&amp;lt;CompletableFuture&amp;lt;String&amp;gt;&amp;gt; nested = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; &amp;quot;input&amp;quot;)&#xA;    .thenApply(input -&amp;gt; asyncProcess(input));  // 返回 CompletableFuture&amp;lt;String&amp;gt;&#xA;&#xA;// 解决：使用 thenCompose 扁平化&#xA;CompletableFuture&amp;lt;String&amp;gt; flattened = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; &amp;quot;input&amp;quot;)&#xA;    .thenCompose(input -&amp;gt; asyncProcess(input));  // 自动扁平化&#xA;&#xA;// 辅助方法&#xA;private CompletableFuture&amp;lt;String&amp;gt; asyncProcess(String input) {&#xA;    return CompletableFuture.supplyAsync(() -&amp;gt; &amp;quot;processed: &amp;quot; + input);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;36-thencompose-vs-thenapply&#34;&gt;3.6 thenCompose vs thenApply&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ==================== thenApply ====================&#xA;// 用于同步转换，lambda 返回普通值&#xA;CompletableFuture&amp;lt;String&amp;gt; f1 = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; 1)&#xA;    .thenApply(n -&amp;gt; &amp;quot;Number: &amp;quot; + n);  // 返回 String&#xA;&#xA;// ==================== thenCompose ====================&#xA;// 用于异步转换，lambda 返回 CompletableFuture&#xA;CompletableFuture&amp;lt;String&amp;gt; f2 = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; 1)&#xA;    .thenCompose(n -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; &amp;quot;Number: &amp;quot; + n));&#xA;&#xA;// 类比 Stream API:&#xA;// thenApply  ≈ map()&#xA;// thenCompose ≈ flatMap()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;37-functionidentity-模式&#34;&gt;3.7 Function.identity() 模式&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 这是 Flink 中常见的模式&#xA;// 当 handleAsync 返回 CompletableFuture 时，需要扁平化&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; result = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; &amp;quot;input&amp;quot;)&#xA;    .handleAsync((value, throwable) -&amp;gt; {&#xA;        if (throwable != null) {&#xA;            return CompletableFuture.completedFuture(&amp;quot;error fallback&amp;quot;);&#xA;        }&#xA;        return asyncProcess(value);  // 返回 CompletableFuture&amp;lt;String&amp;gt;&#xA;    })&#xA;    // handleAsync 返回 CompletableFuture&amp;lt;CompletableFuture&amp;lt;String&amp;gt;&amp;gt;&#xA;    // 使用 thenCompose(Function.identity()) 扁平化&#xA;    .thenCompose(Function.identity());  // 等价于 .thenCompose(f -&amp;gt; f)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;4-异常处理&#34;&gt;4. 异常处理&lt;/h2&gt;&#xA;&lt;h3 id=&#34;41-exceptionally---异常恢复&#34;&gt;4.1 exceptionally - 异常恢复&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// exceptionally: 只处理异常情况，正常情况直接传递&#xA;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; {&#xA;        if (Math.random() &amp;gt; 0.5) {&#xA;            throw new RuntimeException(&amp;quot;Random error&amp;quot;);&#xA;        }&#xA;        return &amp;quot;success&amp;quot;;&#xA;    })&#xA;    .exceptionally(throwable -&amp;gt; {&#xA;        System.err.println(&amp;quot;发生异常: &amp;quot; + throwable.getMessage());&#xA;        return &amp;quot;default value&amp;quot;;  // 返回默认值&#xA;    });&#xA;&#xA;System.out.println(future.get());  // &amp;quot;success&amp;quot; 或 &amp;quot;default value&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;42-handle---统一处理结果和异常&#34;&gt;4.2 handle - 统一处理结果和异常&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// handle: 同时处理正常结果和异常&#xA;// BiFunction&amp;lt;T, Throwable, U&amp;gt;: 接收结果和异常，返回新值&#xA;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; {&#xA;        if (Math.random() &amp;gt; 0.5) {&#xA;            throw new RuntimeException(&amp;quot;Random error&amp;quot;);&#xA;        }&#xA;        return &amp;quot;success&amp;quot;;&#xA;    })&#xA;    .handle((result, throwable) -&amp;gt; {&#xA;        if (throwable != null) {&#xA;            // 异常情况&#xA;            System.err.println(&amp;quot;异常: &amp;quot; + throwable.getMessage());&#xA;            return &amp;quot;error: &amp;quot; + throwable.getMessage();&#xA;        }&#xA;        // 正常情况&#xA;        return &amp;quot;result: &amp;quot; + result;&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;43-handleasync---异步处理结果和异常&#34;&gt;4.3 handleAsync - 异步处理结果和异常&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;ExecutorService executor = Executors.newFixedThreadPool(2);&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; {&#xA;        System.out.println(&amp;quot;主任务线程: &amp;quot; + Thread.currentThread().getName());&#xA;        return &amp;quot;data&amp;quot;;&#xA;    })&#xA;    .handleAsync((result, throwable) -&amp;gt; {&#xA;        System.out.println(&amp;quot;处理线程: &amp;quot; + Thread.currentThread().getName());&#xA;        if (throwable != null) {&#xA;            return &amp;quot;error&amp;quot;;&#xA;        }&#xA;        return &amp;quot;processed: &amp;quot; + result;&#xA;    }, executor);  // 在指定线程池中执行&#xA;&#xA;executor.shutdown();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;44-whencomplete---观察结果不改变结果&#34;&gt;4.4 whenComplete - 观察结果（不改变结果）&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// whenComplete: 观察结果和异常，但不改变它们&#xA;// BiConsumer&amp;lt;T, Throwable&amp;gt;: 接收结果和异常，无返回值&#xA;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; &amp;quot;result&amp;quot;)&#xA;    .whenComplete((result, throwable) -&amp;gt; {&#xA;        if (throwable != null) {&#xA;            System.err.println(&amp;quot;任务失败: &amp;quot; + throwable.getMessage());&#xA;        } else {&#xA;            System.out.println(&amp;quot;任务成功: &amp;quot; + result);&#xA;        }&#xA;        // 注意：这里不能改变结果&#xA;    });&#xA;&#xA;// whenComplete 返回的 Future 包含原始结果&#xA;System.out.println(future.get());  // &amp;quot;result&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;45-异常处理链&#34;&gt;4.5 异常处理链&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; {&#xA;        throw new RuntimeException(&amp;quot;Step 1 error&amp;quot;);&#xA;    })&#xA;    .thenApply(result -&amp;gt; {&#xA;        System.out.println(&amp;quot;Step 2&amp;quot;);  // 不会执行&#xA;        return result + &amp;quot; step2&amp;quot;;&#xA;    })&#xA;    .thenApply(result -&amp;gt; {&#xA;        System.out.println(&amp;quot;Step 3&amp;quot;);  // 不会执行&#xA;        return result + &amp;quot; step3&amp;quot;;&#xA;    })&#xA;    .exceptionally(throwable -&amp;gt; {&#xA;        // 捕获之前所有步骤的异常&#xA;        System.err.println(&amp;quot;捕获异常: &amp;quot; + throwable.getMessage());&#xA;        return &amp;quot;recovered&amp;quot;;&#xA;    })&#xA;    .thenApply(result -&amp;gt; {&#xA;        System.out.println(&amp;quot;Step 4: &amp;quot; + result);  // 会执行&#xA;        return result + &amp;quot; step4&amp;quot;;&#xA;    });&#xA;&#xA;System.out.println(future.get());  // &amp;quot;recovered step4&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;46-异常类型处理&#34;&gt;4.6 异常类型处理&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; {&#xA;        throw new IllegalArgumentException(&amp;quot;Invalid argument&amp;quot;);&#xA;    })&#xA;    .handle((result, throwable) -&amp;gt; {&#xA;        if (throwable != null) {&#xA;            // 获取真正的异常（去除 CompletionException 包装）&#xA;            Throwable cause = throwable.getCause();&#xA;            if (cause == null) {&#xA;                cause = throwable;&#xA;            }&#xA;            &#xA;            if (cause instanceof IllegalArgumentException) {&#xA;                return &amp;quot;参数错误: &amp;quot; + cause.getMessage();&#xA;            } else if (cause instanceof IOException) {&#xA;                return &amp;quot;IO错误: &amp;quot; + cause.getMessage();&#xA;            } else {&#xA;                return &amp;quot;未知错误: &amp;quot; + cause.getMessage();&#xA;            }&#xA;        }&#xA;        return result;&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;5-组合多个异步操作&#34;&gt;5. 组合多个异步操作&lt;/h2&gt;&#xA;&lt;h3 id=&#34;51-thencombine---合并两个-future-的结果&#34;&gt;5.1 thenCombine - 合并两个 Future 的结果&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// thenCombine: 等待两个 Future 都完成，然后合并结果&#xA;CompletableFuture&amp;lt;String&amp;gt; future1 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    sleep(1000);&#xA;    return &amp;quot;Hello&amp;quot;;&#xA;});&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; future2 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    sleep(1500);&#xA;    return &amp;quot;World&amp;quot;;&#xA;});&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; combined = future1.thenCombine(future2, (s1, s2) -&amp;gt; {&#xA;    return s1 + &amp;quot; &amp;quot; + s2;&#xA;});&#xA;&#xA;System.out.println(combined.get());  // &amp;quot;Hello World&amp;quot;（约 1.5 秒后）&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;52-thenacceptboth---消费两个-future-的结果&#34;&gt;5.2 thenAcceptBoth - 消费两个 Future 的结果&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// thenAcceptBoth: 类似 thenCombine，但没有返回值&#xA;CompletableFuture&amp;lt;String&amp;gt; future1 = CompletableFuture.supplyAsync(() -&amp;gt; &amp;quot;User&amp;quot;);&#xA;CompletableFuture&amp;lt;Integer&amp;gt; future2 = CompletableFuture.supplyAsync(() -&amp;gt; 25);&#xA;&#xA;CompletableFuture&amp;lt;Void&amp;gt; result = future1.thenAcceptBoth(future2, (name, age) -&amp;gt; {&#xA;    System.out.println(name + &amp;quot; is &amp;quot; + age + &amp;quot; years old&amp;quot;);&#xA;});&#xA;&#xA;result.join();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;53-runafterboth---两个都完成后执行&#34;&gt;5.3 runAfterBoth - 两个都完成后执行&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// runAfterBoth: 两个 Future 都完成后执行操作，不关心结果&#xA;CompletableFuture&amp;lt;String&amp;gt; future1 = CompletableFuture.supplyAsync(() -&amp;gt; &amp;quot;task1&amp;quot;);&#xA;CompletableFuture&amp;lt;String&amp;gt; future2 = CompletableFuture.supplyAsync(() -&amp;gt; &amp;quot;task2&amp;quot;);&#xA;&#xA;CompletableFuture&amp;lt;Void&amp;gt; result = future1.runAfterBoth(future2, () -&amp;gt; {&#xA;    System.out.println(&amp;quot;两个任务都完成了&amp;quot;);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;54-applytoeither---任一完成即处理&#34;&gt;5.4 applyToEither - 任一完成即处理&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// applyToEither: 哪个先完成就用哪个的结果&#xA;CompletableFuture&amp;lt;String&amp;gt; future1 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    sleep(2000);&#xA;    return &amp;quot;slow result&amp;quot;;&#xA;});&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; future2 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    sleep(1000);&#xA;    return &amp;quot;fast result&amp;quot;;&#xA;});&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; result = future1.applyToEither(future2, s -&amp;gt; {&#xA;    return &amp;quot;Winner: &amp;quot; + s;&#xA;});&#xA;&#xA;System.out.println(result.get());  // &amp;quot;Winner: fast result&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;55-accepteither---任一完成即消费&#34;&gt;5.5 acceptEither - 任一完成即消费&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// acceptEither: 哪个先完成就消费哪个的结果&#xA;CompletableFuture&amp;lt;String&amp;gt; future1 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    sleep(2000);&#xA;    return &amp;quot;slow&amp;quot;;&#xA;});&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; future2 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    sleep(1000);&#xA;    return &amp;quot;fast&amp;quot;;&#xA;});&#xA;&#xA;future1.acceptEither(future2, result -&amp;gt; {&#xA;    System.out.println(&amp;quot;First completed: &amp;quot; + result);&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;56-allof---等待所有完成&#34;&gt;5.6 allOf - 等待所有完成&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// allOf: 等待所有 Future 完成&#xA;CompletableFuture&amp;lt;String&amp;gt; f1 = CompletableFuture.supplyAsync(() -&amp;gt; &amp;quot;Result1&amp;quot;);&#xA;CompletableFuture&amp;lt;String&amp;gt; f2 = CompletableFuture.supplyAsync(() -&amp;gt; &amp;quot;Result2&amp;quot;);&#xA;CompletableFuture&amp;lt;String&amp;gt; f3 = CompletableFuture.supplyAsync(() -&amp;gt; &amp;quot;Result3&amp;quot;);&#xA;&#xA;// allOf 返回 CompletableFuture&amp;lt;Void&amp;gt;&#xA;CompletableFuture&amp;lt;Void&amp;gt; allFuture = CompletableFuture.allOf(f1, f2, f3);&#xA;&#xA;// 等待所有完成后，收集结果&#xA;CompletableFuture&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; resultsFuture = allFuture.thenApply(v -&amp;gt; {&#xA;    return Stream.of(f1, f2, f3)&#xA;        .map(CompletableFuture::join)&#xA;        .collect(Collectors.toList());&#xA;});&#xA;&#xA;List&amp;lt;String&amp;gt; results = resultsFuture.get();&#xA;System.out.println(results);  // [Result1, Result2, Result3]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;57-anyof---任一完成即返回&#34;&gt;5.7 anyOf - 任一完成即返回&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// anyOf: 任一 Future 完成就返回&#xA;CompletableFuture&amp;lt;String&amp;gt; f1 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    sleep(3000);&#xA;    return &amp;quot;slow&amp;quot;;&#xA;});&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; f2 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    sleep(1000);&#xA;    return &amp;quot;fast&amp;quot;;&#xA;});&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; f3 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    sleep(2000);&#xA;    return &amp;quot;medium&amp;quot;;&#xA;});&#xA;&#xA;// anyOf 返回 CompletableFuture&amp;lt;Object&amp;gt;&#xA;CompletableFuture&amp;lt;Object&amp;gt; anyFuture = CompletableFuture.anyOf(f1, f2, f3);&#xA;&#xA;System.out.println(anyFuture.get());  // &amp;quot;fast&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;58-批量处理模式&#34;&gt;5.8 批量处理模式&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 批量处理多个异步任务&#xA;public &amp;lt;T&amp;gt; CompletableFuture&amp;lt;List&amp;lt;T&amp;gt;&amp;gt; sequence(List&amp;lt;CompletableFuture&amp;lt;T&amp;gt;&amp;gt; futures) {&#xA;    return CompletableFuture&#xA;        .allOf(futures.toArray(new CompletableFuture[0]))&#xA;        .thenApply(v -&amp;gt; futures.stream()&#xA;            .map(CompletableFuture::join)&#xA;            .collect(Collectors.toList()));&#xA;}&#xA;&#xA;// 使用示例&#xA;List&amp;lt;CompletableFuture&amp;lt;String&amp;gt;&amp;gt; futures = Arrays.asList(&#xA;    CompletableFuture.supplyAsync(() -&amp;gt; &amp;quot;A&amp;quot;),&#xA;    CompletableFuture.supplyAsync(() -&amp;gt; &amp;quot;B&amp;quot;),&#xA;    CompletableFuture.supplyAsync(() -&amp;gt; &amp;quot;C&amp;quot;)&#xA;);&#xA;&#xA;CompletableFuture&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; resultFuture = sequence(futures);&#xA;List&amp;lt;String&amp;gt; results = resultFuture.get();  // [A, B, C]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;6-结合线程池&#34;&gt;6. 结合线程池&lt;/h2&gt;&#xA;&lt;h3 id=&#34;61-默认线程池&#34;&gt;6.1 默认线程池&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 默认使用 ForkJoinPool.commonPool()&#xA;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    System.out.println(&amp;quot;线程: &amp;quot; + Thread.currentThread().getName());&#xA;    // 输出类似: ForkJoinPool.commonPool-worker-1&#xA;    return &amp;quot;result&amp;quot;;&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;62-自定义线程池&#34;&gt;6.2 自定义线程池&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建自定义线程池&#xA;ExecutorService customExecutor = Executors.newFixedThreadPool(4, r -&amp;gt; {&#xA;    Thread t = new Thread(r);&#xA;    t.setName(&amp;quot;custom-thread-&amp;quot; + t.getId());&#xA;    t.setDaemon(true);&#xA;    return t;&#xA;});&#xA;&#xA;// 使用自定义线程池&#xA;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    System.out.println(&amp;quot;线程: &amp;quot; + Thread.currentThread().getName());&#xA;    return &amp;quot;result&amp;quot;;&#xA;}, customExecutor);&#xA;&#xA;// 链式操作也可以指定线程池&#xA;CompletableFuture&amp;lt;String&amp;gt; result = future&#xA;    .thenApplyAsync(s -&amp;gt; s.toUpperCase(), customExecutor)&#xA;    .thenApplyAsync(s -&amp;gt; s + &amp;quot;!&amp;quot;, customExecutor);&#xA;&#xA;// 记得关闭线程池&#xA;customExecutor.shutdown();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;63-不同类型的线程池&#34;&gt;6.3 不同类型的线程池&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1. 固定大小线程池 - 适合 CPU 密集型任务&#xA;ExecutorService fixedPool = Executors.newFixedThreadPool(&#xA;    Runtime.getRuntime().availableProcessors());&#xA;&#xA;// 2. 缓存线程池 - 适合短期异步任务&#xA;ExecutorService cachedPool = Executors.newCachedThreadPool();&#xA;&#xA;// 3. 单线程池 - 保证顺序执行&#xA;ExecutorService singlePool = Executors.newSingleThreadExecutor();&#xA;&#xA;// 4. 调度线程池 - 支持延迟和周期性任务&#xA;ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(2);&#xA;&#xA;// 5. 自定义 ThreadPoolExecutor&#xA;ThreadPoolExecutor customPool = new ThreadPoolExecutor(&#xA;    4,                      // 核心线程数&#xA;    8,                      // 最大线程数&#xA;    60L,                    // 空闲线程存活时间&#xA;    TimeUnit.SECONDS,       // 时间单位&#xA;    new LinkedBlockingQueue&amp;lt;&amp;gt;(100),  // 工作队列&#xA;    new ThreadPoolExecutor.CallerRunsPolicy()  // 拒绝策略&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;64-flink-风格的线程池使用&#34;&gt;6.4 Flink 风格的线程池使用&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FlinkStyleExecutor {&#xA;    &#xA;    // 主线程执行器 - 保证线程安全&#xA;    private final Executor mainThreadExecutor;&#xA;    &#xA;    // IO 执行器 - 用于 IO 密集型操作&#xA;    private final ExecutorService ioExecutor;&#xA;    &#xA;    // 计算执行器 - 用于 CPU 密集型操作&#xA;    private final ExecutorService computeExecutor;&#xA;    &#xA;    public FlinkStyleExecutor() {&#xA;        // 主线程执行器（单线程，保证顺序）&#xA;        this.mainThreadExecutor = Executors.newSingleThreadExecutor(&#xA;            r -&amp;gt; new Thread(r, &amp;quot;main-thread&amp;quot;));&#xA;        &#xA;        // IO 执行器（多线程，处理阻塞 IO）&#xA;        this.ioExecutor = Executors.newCachedThreadPool(&#xA;            r -&amp;gt; new Thread(r, &amp;quot;io-thread-&amp;quot; + System.currentTimeMillis()));&#xA;        &#xA;        // 计算执行器（固定大小，处理 CPU 密集任务）&#xA;        this.computeExecutor = Executors.newFixedThreadPool(&#xA;            Runtime.getRuntime().availableProcessors(),&#xA;            r -&amp;gt; new Thread(r, &amp;quot;compute-thread-&amp;quot; + System.currentTimeMillis()));&#xA;    }&#xA;    &#xA;    public CompletableFuture&amp;lt;String&amp;gt; processData(String input) {&#xA;        return CompletableFuture&#xA;            // IO 操作：读取数据&#xA;            .supplyAsync(() -&amp;gt; {&#xA;                System.out.println(&amp;quot;IO 读取, 线程: &amp;quot; + Thread.currentThread().getName());&#xA;                return readFromDatabase(input);&#xA;            }, ioExecutor)&#xA;            // 计算操作：处理数据&#xA;            .thenApplyAsync(data -&amp;gt; {&#xA;                System.out.println(&amp;quot;计算处理, 线程: &amp;quot; + Thread.currentThread().getName());&#xA;                return processData(data);&#xA;            }, computeExecutor)&#xA;            // 主线程：更新状态&#xA;            .thenApplyAsync(result -&amp;gt; {&#xA;                System.out.println(&amp;quot;更新状态, 线程: &amp;quot; + Thread.currentThread().getName());&#xA;                updateState(result);&#xA;                return result;&#xA;            }, mainThreadExecutor);&#xA;    }&#xA;    &#xA;    private String readFromDatabase(String input) { return &amp;quot;data-&amp;quot; + input; }&#xA;    private String processData(String data) { return &amp;quot;processed-&amp;quot; + data; }&#xA;    private void updateState(String result) { /* 更新状态 */ }&#xA;    &#xA;    public void shutdown() {&#xA;        ((ExecutorService) mainThreadExecutor).shutdown();&#xA;        ioExecutor.shutdown();&#xA;        computeExecutor.shutdown();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;65-线程池选择策略&#34;&gt;6.5 线程池选择策略&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 根据任务类型选择合适的线程池&#xA;public class ExecutorSelector {&#xA;    &#xA;    private final ExecutorService cpuBoundExecutor;&#xA;    private final ExecutorService ioBoundExecutor;&#xA;    &#xA;    public ExecutorSelector() {&#xA;        // CPU 密集型：线程数 = CPU 核心数&#xA;        int cpuCores = Runtime.getRuntime().availableProcessors();&#xA;        this.cpuBoundExecutor = Executors.newFixedThreadPool(cpuCores);&#xA;        &#xA;        // IO 密集型：线程数 = CPU 核心数 * 2（或更多）&#xA;        this.ioBoundExecutor = Executors.newFixedThreadPool(cpuCores * 2);&#xA;    }&#xA;    &#xA;    // CPU 密集型任务&#xA;    public &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; submitCpuTask(Supplier&amp;lt;T&amp;gt; task) {&#xA;        return CompletableFuture.supplyAsync(task, cpuBoundExecutor);&#xA;    }&#xA;    &#xA;    // IO 密集型任务&#xA;    public &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; submitIoTask(Supplier&amp;lt;T&amp;gt; task) {&#xA;        return CompletableFuture.supplyAsync(task, ioBoundExecutor);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;7-结合-runnable-和-callable&#34;&gt;7. 结合 Runnable 和 Callable&lt;/h2&gt;&#xA;&lt;h3 id=&#34;71-runnable-转-completablefuture&#34;&gt;7.1 Runnable 转 CompletableFuture&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Runnable: 无返回值&#xA;Runnable task = () -&amp;gt; {&#xA;    System.out.println(&amp;quot;执行任务&amp;quot;);&#xA;    // 执行一些操作&#xA;};&#xA;&#xA;// 方式 1: 使用 runAsync&#xA;CompletableFuture&amp;lt;Void&amp;gt; future1 = CompletableFuture.runAsync(task);&#xA;&#xA;// 方式 2: 使用自定义线程池&#xA;ExecutorService executor = Executors.newFixedThreadPool(2);&#xA;CompletableFuture&amp;lt;Void&amp;gt; future2 = CompletableFuture.runAsync(task, executor);&#xA;&#xA;// 方式 3: 手动包装&#xA;CompletableFuture&amp;lt;Void&amp;gt; future3 = new CompletableFuture&amp;lt;&amp;gt;();&#xA;executor.submit(() -&amp;gt; {&#xA;    try {&#xA;        task.run();&#xA;        future3.complete(null);&#xA;    } catch (Exception e) {&#xA;        future3.completeExceptionally(e);&#xA;    }&#xA;});&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;72-callable-转-completablefuture&#34;&gt;7.2 Callable 转 CompletableFuture&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Callable: 有返回值，可抛出异常&#xA;Callable&amp;lt;String&amp;gt; callable = () -&amp;gt; {&#xA;    Thread.sleep(1000);&#xA;    return &amp;quot;callable result&amp;quot;;&#xA;};&#xA;&#xA;// 方式 1: 使用 supplyAsync（推荐）&#xA;CompletableFuture&amp;lt;String&amp;gt; future1 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    try {&#xA;        return callable.call();&#xA;    } catch (Exception e) {&#xA;        throw new CompletionException(e);&#xA;    }&#xA;});&#xA;&#xA;// 方式 2: 手动包装&#xA;CompletableFuture&amp;lt;String&amp;gt; future2 = new CompletableFuture&amp;lt;&amp;gt;();&#xA;ExecutorService executor = Executors.newSingleThreadExecutor();&#xA;executor.submit(() -&amp;gt; {&#xA;    try {&#xA;        String result = callable.call();&#xA;        future2.complete(result);&#xA;    } catch (Exception e) {&#xA;        future2.completeExceptionally(e);&#xA;    }&#xA;});&#xA;&#xA;// 方式 3: 工具方法&#xA;public static &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; fromCallable(&#xA;        Callable&amp;lt;T&amp;gt; callable, Executor executor) {&#xA;    CompletableFuture&amp;lt;T&amp;gt; future = new CompletableFuture&amp;lt;&amp;gt;();&#xA;    executor.execute(() -&amp;gt; {&#xA;        try {&#xA;            future.complete(callable.call());&#xA;        } catch (Throwable t) {&#xA;            future.completeExceptionally(t);&#xA;        }&#xA;    });&#xA;    return future;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;73-future-转-completablefuture&#34;&gt;7.3 Future 转 CompletableFuture&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 传统 Future&#xA;ExecutorService executor = Executors.newSingleThreadExecutor();&#xA;Future&amp;lt;String&amp;gt; legacyFuture = executor.submit(() -&amp;gt; {&#xA;    Thread.sleep(1000);&#xA;    return &amp;quot;legacy result&amp;quot;;&#xA;});&#xA;&#xA;// 转换为 CompletableFuture（需要轮询或阻塞）&#xA;// 方式 1: 阻塞转换（不推荐，会阻塞线程）&#xA;CompletableFuture&amp;lt;String&amp;gt; cf1 = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    try {&#xA;        return legacyFuture.get();&#xA;    } catch (Exception e) {&#xA;        throw new CompletionException(e);&#xA;    }&#xA;});&#xA;&#xA;// 方式 2: 轮询转换&#xA;public static &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; fromFuture(&#xA;        Future&amp;lt;T&amp;gt; future, ScheduledExecutorService scheduler) {&#xA;    CompletableFuture&amp;lt;T&amp;gt; cf = new CompletableFuture&amp;lt;&amp;gt;();&#xA;    pollFuture(future, cf, scheduler);&#xA;    return cf;&#xA;}&#xA;&#xA;private static &amp;lt;T&amp;gt; void pollFuture(&#xA;        Future&amp;lt;T&amp;gt; future, CompletableFuture&amp;lt;T&amp;gt; cf, &#xA;        ScheduledExecutorService scheduler) {&#xA;    if (future.isDone()) {&#xA;        try {&#xA;            cf.complete(future.get());&#xA;        } catch (Exception e) {&#xA;            cf.completeExceptionally(e);&#xA;        }&#xA;    } else {&#xA;        scheduler.schedule(() -&amp;gt; pollFuture(future, cf, scheduler), &#xA;            10, TimeUnit.MILLISECONDS);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;74-completablefuture-与-runnable-链式组合&#34;&gt;7.4 CompletableFuture 与 Runnable 链式组合&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 在异步链中插入 Runnable&#xA;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; &amp;quot;step1&amp;quot;)&#xA;    .thenApply(s -&amp;gt; {&#xA;        System.out.println(&amp;quot;处理: &amp;quot; + s);&#xA;        return s + &amp;quot;-step2&amp;quot;;&#xA;    })&#xA;    // 插入一个不关心结果的操作&#xA;    .whenComplete((result, error) -&amp;gt; {&#xA;        // 这里可以执行 Runnable 风格的操作&#xA;        Runnable logTask = () -&amp;gt; System.out.println(&amp;quot;日志记录: &amp;quot; + result);&#xA;        logTask.run();&#xA;    })&#xA;    .thenApply(s -&amp;gt; s + &amp;quot;-step3&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;75-批量执行-runnable&#34;&gt;7.5 批量执行 Runnable&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 批量执行多个 Runnable 并等待全部完成&#xA;public CompletableFuture&amp;lt;Void&amp;gt; runAll(List&amp;lt;Runnable&amp;gt; tasks, Executor executor) {&#xA;    CompletableFuture&amp;lt;?&amp;gt;[] futures = tasks.stream()&#xA;        .map(task -&amp;gt; CompletableFuture.runAsync(task, executor))&#xA;        .toArray(CompletableFuture[]::new);&#xA;    &#xA;    return CompletableFuture.allOf(futures);&#xA;}&#xA;&#xA;// 使用示例&#xA;List&amp;lt;Runnable&amp;gt; tasks = Arrays.asList(&#xA;    () -&amp;gt; System.out.println(&amp;quot;Task 1&amp;quot;),&#xA;    () -&amp;gt; System.out.println(&amp;quot;Task 2&amp;quot;),&#xA;    () -&amp;gt; System.out.println(&amp;quot;Task 3&amp;quot;)&#xA;);&#xA;&#xA;ExecutorService executor = Executors.newFixedThreadPool(3);&#xA;runAll(tasks, executor).join();&#xA;executor.shutdown();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;8-高级模式&#34;&gt;8. 高级模式&lt;/h2&gt;&#xA;&lt;h3 id=&#34;81-超时处理&#34;&gt;8.1 超时处理&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Java 9+ 方式&#xA;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; {&#xA;        sleep(5000);  // 模拟长时间操作&#xA;        return &amp;quot;result&amp;quot;;&#xA;    })&#xA;    .orTimeout(2, TimeUnit.SECONDS)  // 2 秒超时&#xA;    .exceptionally(throwable -&amp;gt; {&#xA;        if (throwable.getCause() instanceof TimeoutException) {&#xA;            return &amp;quot;timeout fallback&amp;quot;;&#xA;        }&#xA;        return &amp;quot;error fallback&amp;quot;;&#xA;    });&#xA;&#xA;// Java 8 兼容方式&#xA;public static &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; withTimeout(&#xA;        CompletableFuture&amp;lt;T&amp;gt; future, long timeout, TimeUnit unit) {&#xA;    &#xA;    CompletableFuture&amp;lt;T&amp;gt; timeoutFuture = new CompletableFuture&amp;lt;&amp;gt;();&#xA;    &#xA;    ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);&#xA;    scheduler.schedule(() -&amp;gt; {&#xA;        timeoutFuture.completeExceptionally(&#xA;            new TimeoutException(&amp;quot;Operation timed out after &amp;quot; + timeout + &amp;quot; &amp;quot; + unit));&#xA;    }, timeout, unit);&#xA;    &#xA;    return future.applyToEither(timeoutFuture, Function.identity());&#xA;}&#xA;&#xA;// 使用示例&#xA;CompletableFuture&amp;lt;String&amp;gt; original = CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;    sleep(5000);&#xA;    return &amp;quot;result&amp;quot;;&#xA;});&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; withTimeout = withTimeout(original, 2, TimeUnit.SECONDS)&#xA;    .exceptionally(e -&amp;gt; &amp;quot;timeout fallback&amp;quot;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;82-重试机制&#34;&gt;8.2 重试机制&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 带重试的异步操作&#xA;public static &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; retryAsync(&#xA;        Supplier&amp;lt;CompletableFuture&amp;lt;T&amp;gt;&amp;gt; supplier,&#xA;        int maxRetries,&#xA;        long delayMs,&#xA;        Predicate&amp;lt;Throwable&amp;gt; retryOn) {&#xA;    &#xA;    return supplier.get().handle((result, throwable) -&amp;gt; {&#xA;        if (throwable == null) {&#xA;            return CompletableFuture.completedFuture(result);&#xA;        }&#xA;        &#xA;        if (maxRetries &amp;gt; 0 &amp;amp;&amp;amp; retryOn.test(throwable)) {&#xA;            System.out.println(&amp;quot;重试中... 剩余次数: &amp;quot; + maxRetries);&#xA;            sleep(delayMs);&#xA;            return retryAsync(supplier, maxRetries - 1, delayMs, retryOn);&#xA;        }&#xA;        &#xA;        CompletableFuture&amp;lt;T&amp;gt; failed = new CompletableFuture&amp;lt;&amp;gt;();&#xA;        failed.completeExceptionally(throwable);&#xA;        return failed;&#xA;    }).thenCompose(Function.identity());&#xA;}&#xA;&#xA;// 使用示例&#xA;AtomicInteger attempts = new AtomicInteger(0);&#xA;&#xA;CompletableFuture&amp;lt;String&amp;gt; result = retryAsync(&#xA;    () -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;        int attempt = attempts.incrementAndGet();&#xA;        System.out.println(&amp;quot;尝试 #&amp;quot; + attempt);&#xA;        if (attempt &amp;lt; 3) {&#xA;            throw new RuntimeException(&amp;quot;模拟失败&amp;quot;);&#xA;        }&#xA;        return &amp;quot;成功&amp;quot;;&#xA;    }),&#xA;    5,      // 最大重试次数&#xA;    1000,   // 重试间隔（毫秒）&#xA;    e -&amp;gt; e instanceof RuntimeException  // 重试条件&#xA;);&#xA;&#xA;System.out.println(result.get());  // &amp;quot;成功&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;83-指数退避重试&#34;&gt;8.3 指数退避重试&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; retryWithBackoff(&#xA;        Supplier&amp;lt;CompletableFuture&amp;lt;T&amp;gt;&amp;gt; supplier,&#xA;        int maxRetries,&#xA;        long initialDelayMs,&#xA;        double multiplier) {&#xA;    &#xA;    return retryWithBackoffInternal(supplier, maxRetries, initialDelayMs, multiplier, 0);&#xA;}&#xA;&#xA;private static &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; retryWithBackoffInternal(&#xA;        Supplier&amp;lt;CompletableFuture&amp;lt;T&amp;gt;&amp;gt; supplier,&#xA;        int maxRetries,&#xA;        long currentDelayMs,&#xA;        double multiplier,&#xA;        int currentAttempt) {&#xA;    &#xA;    return supplier.get().handle((result, throwable) -&amp;gt; {&#xA;        if (throwable == null) {&#xA;            return CompletableFuture.completedFuture(result);&#xA;        }&#xA;        &#xA;        if (currentAttempt &amp;lt; maxRetries) {&#xA;            System.out.printf(&amp;quot;重试 #%d，等待 %dms%n&amp;quot;, currentAttempt + 1, currentDelayMs);&#xA;            sleep(currentDelayMs);&#xA;            &#xA;            long nextDelay = (long) (currentDelayMs * multiplier);&#xA;            return retryWithBackoffInternal(&#xA;                supplier, maxRetries, nextDelay, multiplier, currentAttempt + 1);&#xA;        }&#xA;        &#xA;        CompletableFuture&amp;lt;T&amp;gt; failed = new CompletableFuture&amp;lt;&amp;gt;();&#xA;        failed.completeExceptionally(throwable);&#xA;        return failed;&#xA;    }).thenCompose(Function.identity());&#xA;}&#xA;&#xA;// 使用示例&#xA;CompletableFuture&amp;lt;String&amp;gt; result = retryWithBackoff(&#xA;    () -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;        throw new RuntimeException(&amp;quot;总是失败&amp;quot;);&#xA;    }),&#xA;    3,       // 最大重试 3 次&#xA;    100,     // 初始延迟 100ms&#xA;    2.0      // 每次延迟翻倍: 100ms -&amp;gt; 200ms -&amp;gt; 400ms&#xA;);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;84-断路器模式&#34;&gt;8.4 断路器模式&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CircuitBreaker {&#xA;    &#xA;    private enum State { CLOSED, OPEN, HALF_OPEN }&#xA;    &#xA;    private final int failureThreshold;&#xA;    private final long resetTimeoutMs;&#xA;    &#xA;    private State state = State.CLOSED;&#xA;    private int failureCount = 0;&#xA;    private long lastFailureTime = 0;&#xA;    &#xA;    public CircuitBreaker(int failureThreshold, long resetTimeoutMs) {&#xA;        this.failureThreshold = failureThreshold;&#xA;        this.resetTimeoutMs = resetTimeoutMs;&#xA;    }&#xA;    &#xA;    public &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; execute(Supplier&amp;lt;CompletableFuture&amp;lt;T&amp;gt;&amp;gt; supplier) {&#xA;        if (state == State.OPEN) {&#xA;            if (System.currentTimeMillis() - lastFailureTime &amp;gt; resetTimeoutMs) {&#xA;                state = State.HALF_OPEN;&#xA;            } else {&#xA;                CompletableFuture&amp;lt;T&amp;gt; failed = new CompletableFuture&amp;lt;&amp;gt;();&#xA;                failed.completeExceptionally(&#xA;                    new RuntimeException(&amp;quot;Circuit breaker is OPEN&amp;quot;));&#xA;                return failed;&#xA;            }&#xA;        }&#xA;        &#xA;        return supplier.get()&#xA;            .whenComplete((result, throwable) -&amp;gt; {&#xA;                if (throwable != null) {&#xA;                    recordFailure();&#xA;                } else {&#xA;                    recordSuccess();&#xA;                }&#xA;            });&#xA;    }&#xA;    &#xA;    private synchronized void recordFailure() {&#xA;        failureCount++;&#xA;        lastFailureTime = System.currentTimeMillis();&#xA;        if (failureCount &amp;gt;= failureThreshold) {&#xA;            state = State.OPEN;&#xA;            System.out.println(&amp;quot;断路器打开！&amp;quot;);&#xA;        }&#xA;    }&#xA;    &#xA;    private synchronized void recordSuccess() {&#xA;        failureCount = 0;&#xA;        state = State.CLOSED;&#xA;    }&#xA;}&#xA;&#xA;// 使用示例&#xA;CircuitBreaker breaker = new CircuitBreaker(3, 5000);&#xA;&#xA;for (int i = 0; i &amp;lt; 10; i++) {&#xA;    breaker.execute(() -&amp;gt; CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;        throw new RuntimeException(&amp;quot;服务不可用&amp;quot;);&#xA;    })).exceptionally(e -&amp;gt; {&#xA;        System.out.println(&amp;quot;错误: &amp;quot; + e.getMessage());&#xA;        return null;&#xA;    }).join();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;85-限流器&#34;&gt;8.5 限流器&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RateLimiter {&#xA;    &#xA;    private final Semaphore semaphore;&#xA;    private final ExecutorService executor;&#xA;    &#xA;    public RateLimiter(int maxConcurrent) {&#xA;        this.semaphore = new Semaphore(maxConcurrent);&#xA;        this.executor = Executors.newCachedThreadPool();&#xA;    }&#xA;    &#xA;    public &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; execute(Supplier&amp;lt;T&amp;gt; task) {&#xA;        return CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;            try {&#xA;                semaphore.acquire();&#xA;                try {&#xA;                    return task.get();&#xA;                } finally {&#xA;                    semaphore.release();&#xA;                }&#xA;            } catch (InterruptedException e) {&#xA;                Thread.currentThread().interrupt();&#xA;                throw new CompletionException(e);&#xA;            }&#xA;        }, executor);&#xA;    }&#xA;    &#xA;    public void shutdown() {&#xA;        executor.shutdown();&#xA;    }&#xA;}&#xA;&#xA;// 使用示例&#xA;RateLimiter limiter = new RateLimiter(3);  // 最多 3 个并发&#xA;&#xA;List&amp;lt;CompletableFuture&amp;lt;String&amp;gt;&amp;gt; futures = IntStream.range(0, 10)&#xA;    .mapToObj(i -&amp;gt; limiter.execute(() -&amp;gt; {&#xA;        System.out.println(&amp;quot;执行任务 &amp;quot; + i + &amp;quot;，线程: &amp;quot; + &#xA;            Thread.currentThread().getName());&#xA;        sleep(1000);&#xA;        return &amp;quot;Result &amp;quot; + i;&#xA;    }))&#xA;    .collect(Collectors.toList());&#xA;&#xA;futures.forEach(f -&amp;gt; System.out.println(f.join()));&#xA;limiter.shutdown();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;9-flink-中的实际应用&#34;&gt;9. Flink 中的实际应用&lt;/h2&gt;&#xA;&lt;h3 id=&#34;91-jobmanagerrunner-结果处理模式&#34;&gt;9.1 JobManagerRunner 结果处理模式&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// Flink 源码中的典型模式&#xA;final CompletableFuture&amp;lt;CleanupJobState&amp;gt; cleanupJobStateFuture =&#xA;    jobManagerRunner&#xA;        .getResultFuture()  // 获取作业结果 Future&#xA;        .handleAsync(       // 异步处理结果和异常&#xA;            (jobManagerRunnerResult, throwable) -&amp;gt; {&#xA;                // 1. 验证状态一致性&#xA;                Preconditions.checkState(&#xA;                    jobManagerRunnerRegistry.isRegistered(jobId) &amp;amp;&amp;amp;&#xA;                    jobManagerRunnerRegistry.get(jobId) == jobManagerRunner,&#xA;                    &amp;quot;Job entry must be bound to JobManagerRunner lifetime.&amp;quot;);&#xA;&#xA;                // 2. 根据结果或异常进行不同处理&#xA;                if (jobManagerRunnerResult != null) {&#xA;                    // 正常完成，返回另一个 CompletableFuture&#xA;                    return handleJobManagerRunnerResult(&#xA;                        jobManagerRunnerResult, executionType);&#xA;                } else {&#xA;                    // 异常情况，返回已完成的 Future&#xA;                    return CompletableFuture.completedFuture(&#xA;                        jobManagerRunnerFailed(jobId, JobStatus.FAILED, throwable));&#xA;                }&#xA;            },&#xA;            getMainThreadExecutor())  // 在主线程执行器中执行&#xA;        .thenCompose(Function.identity());  // 扁平化嵌套的 Future&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;92-模拟-flink-作业提交流程&#34;&gt;9.2 模拟 Flink 作业提交流程&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class FlinkJobSubmissionDemo {&#xA;    &#xA;    private final ExecutorService executorService = &#xA;        Executors.newFixedThreadPool(4);&#xA;    &#xA;    // 模拟作业提交&#xA;    public CompletableFuture&amp;lt;JobID&amp;gt; submitJob(JobGraph jobGraph) {&#xA;        // 步骤 1: 异步序列化 JobGraph&#xA;        CompletableFuture&amp;lt;Path&amp;gt; jobGraphFileFuture = &#xA;            CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;                System.out.println(&amp;quot;序列化 JobGraph，线程: &amp;quot; + &#xA;                    Thread.currentThread().getName());&#xA;                return serializeJobGraph(jobGraph);&#xA;            }, executorService);&#xA;        &#xA;        // 步骤 2: 准备请求体&#xA;        CompletableFuture&amp;lt;JobSubmitRequest&amp;gt; requestFuture = &#xA;            jobGraphFileFuture.thenApply(jobGraphFile -&amp;gt; {&#xA;                System.out.println(&amp;quot;准备请求体，线程: &amp;quot; + &#xA;                    Thread.currentThread().getName());&#xA;                return prepareRequest(jobGraphFile, jobGraph);&#xA;            });&#xA;        &#xA;        // 步骤 3: 发送请求&#xA;        CompletableFuture&amp;lt;JobSubmitResponse&amp;gt; submissionFuture = &#xA;            requestFuture.thenCompose(request -&amp;gt; {&#xA;                System.out.println(&amp;quot;发送请求，线程: &amp;quot; + &#xA;                    Thread.currentThread().getName());&#xA;                return sendRequest(request);&#xA;            });&#xA;        &#xA;        // 步骤 4: 提取 JobID&#xA;        return submissionFuture&#xA;            .thenApply(response -&amp;gt; {&#xA;                System.out.println(&amp;quot;提交成功: &amp;quot; + response.getJobId());&#xA;                return response.getJobId();&#xA;            })&#xA;            .whenComplete((jobId, error) -&amp;gt; {&#xA;                if (error != null) {&#xA;                    System.err.println(&amp;quot;提交失败: &amp;quot; + error.getMessage());&#xA;                }&#xA;            });&#xA;    }&#xA;    &#xA;    // 模拟方法&#xA;    private Path serializeJobGraph(JobGraph jobGraph) {&#xA;        sleep(500);&#xA;        return Path.of(&amp;quot;/tmp/jobgraph-&amp;quot; + jobGraph.getJobID() + &amp;quot;.bin&amp;quot;);&#xA;    }&#xA;    &#xA;    private JobSubmitRequest prepareRequest(Path jobGraphFile, JobGraph jobGraph) {&#xA;        return new JobSubmitRequest(jobGraphFile, jobGraph.getJobID());&#xA;    }&#xA;    &#xA;    private CompletableFuture&amp;lt;JobSubmitResponse&amp;gt; sendRequest(JobSubmitRequest request) {&#xA;        return CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;            sleep(1000);  // 模拟网络延迟&#xA;            return new JobSubmitResponse(request.getJobId());&#xA;        }, executorService);&#xA;    }&#xA;    &#xA;    // 内部类&#xA;    static class JobGraph {&#xA;        private final JobID jobId = new JobID();&#xA;        public JobID getJobID() { return jobId; }&#xA;    }&#xA;    &#xA;    static class JobID {&#xA;        private final String id = UUID.randomUUID().toString();&#xA;        @Override public String toString() { return id; }&#xA;    }&#xA;    &#xA;    static class JobSubmitRequest {&#xA;        private final Path jobGraphFile;&#xA;        private final JobID jobId;&#xA;        &#xA;        JobSubmitRequest(Path jobGraphFile, JobID jobId) {&#xA;            this.jobGraphFile = jobGraphFile;&#xA;            this.jobId = jobId;&#xA;        }&#xA;        &#xA;        public JobID getJobId() { return jobId; }&#xA;    }&#xA;    &#xA;    static class JobSubmitResponse {&#xA;        private final JobID jobId;&#xA;        &#xA;        JobSubmitResponse(JobID jobId) { this.jobId = jobId; }&#xA;        public JobID getJobId() { return jobId; }&#xA;    }&#xA;    &#xA;    public void shutdown() {&#xA;        executorService.shutdown();&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;93-带重试的请求发送&#34;&gt;9.3 带重试的请求发送&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class RetriableRequestSender {&#xA;    &#xA;    private final RestClient restClient;&#xA;    private final int maxRetries;&#xA;    private final Predicate&amp;lt;Throwable&amp;gt; retryPredicate;&#xA;    &#xA;    public RetriableRequestSender(RestClient restClient, int maxRetries) {&#xA;        this.restClient = restClient;&#xA;        this.maxRetries = maxRetries;&#xA;        this.retryPredicate = throwable -&amp;gt; &#xA;            throwable instanceof IOException ||&#xA;            throwable instanceof TimeoutException;&#xA;    }&#xA;    &#xA;    public &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; sendRetriableRequest(&#xA;            String url, Object request, Class&amp;lt;T&amp;gt; responseType) {&#xA;        &#xA;        return retry(&#xA;            () -&amp;gt; restClient.sendRequest(url, request, responseType),&#xA;            maxRetries,&#xA;            retryPredicate);&#xA;    }&#xA;    &#xA;    private &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; retry(&#xA;            Supplier&amp;lt;CompletableFuture&amp;lt;T&amp;gt;&amp;gt; operation,&#xA;            int retriesLeft,&#xA;            Predicate&amp;lt;Throwable&amp;gt; shouldRetry) {&#xA;        &#xA;        return operation.get()&#xA;            .handle((result, throwable) -&amp;gt; {&#xA;                if (throwable == null) {&#xA;                    return CompletableFuture.completedFuture(result);&#xA;                }&#xA;                &#xA;                Throwable cause = throwable.getCause() != null ? &#xA;                    throwable.getCause() : throwable;&#xA;                &#xA;                if (retriesLeft &amp;gt; 0 &amp;amp;&amp;amp; shouldRetry.test(cause)) {&#xA;                    System.out.println(&amp;quot;请求失败，重试中... 剩余次数: &amp;quot; + retriesLeft);&#xA;                    return retry(operation, retriesLeft - 1, shouldRetry);&#xA;                }&#xA;                &#xA;                CompletableFuture&amp;lt;T&amp;gt; failed = new CompletableFuture&amp;lt;&amp;gt;();&#xA;                failed.completeExceptionally(throwable);&#xA;                return failed;&#xA;            })&#xA;            .thenCompose(Function.identity());&#xA;    }&#xA;    &#xA;    // 模拟 RestClient&#xA;    static class RestClient {&#xA;        public &amp;lt;T&amp;gt; CompletableFuture&amp;lt;T&amp;gt; sendRequest(&#xA;                String url, Object request, Class&amp;lt;T&amp;gt; responseType) {&#xA;            return CompletableFuture.supplyAsync(() -&amp;gt; {&#xA;                // 模拟请求&#xA;                return null;&#xA;            });&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;10-最佳实践&#34;&gt;10. 最佳实践&lt;/h2&gt;&#xA;&lt;h3 id=&#34;101-避免阻塞&#34;&gt;10.1 避免阻塞&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ❌ 错误：在异步链中阻塞&#xA;CompletableFuture&amp;lt;String&amp;gt; bad = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; &amp;quot;step1&amp;quot;)&#xA;    .thenApply(s -&amp;gt; {&#xA;        // 不要在这里调用 get() 或 join()&#xA;        String other = anotherFuture.get();  // 阻塞！&#xA;        return s + other;&#xA;    });&#xA;&#xA;// ✅ 正确：使用 thenCompose 组合&#xA;CompletableFuture&amp;lt;String&amp;gt; good = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; &amp;quot;step1&amp;quot;)&#xA;    .thenCompose(s -&amp;gt; anotherFuture.thenApply(other -&amp;gt; s + other));&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;102-正确处理异常&#34;&gt;10.2 正确处理异常&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ❌ 错误：忽略异常&#xA;CompletableFuture&amp;lt;String&amp;gt; bad = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; {&#xA;        throw new RuntimeException(&amp;quot;error&amp;quot;);&#xA;    });&#xA;// 异常被吞掉，没有任何处理&#xA;&#xA;// ✅ 正确：始终处理异常&#xA;CompletableFuture&amp;lt;String&amp;gt; good = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; {&#xA;        throw new RuntimeException(&amp;quot;error&amp;quot;);&#xA;    })&#xA;    .exceptionally(e -&amp;gt; {&#xA;        log.error(&amp;quot;操作失败&amp;quot;, e);&#xA;        return &amp;quot;fallback&amp;quot;;&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;103-使用合适的线程池&#34;&gt;10.3 使用合适的线程池&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ❌ 错误：所有操作使用默认线程池&#xA;CompletableFuture.supplyAsync(() -&amp;gt; blockingIoOperation());  // 可能阻塞公共线程池&#xA;&#xA;// ✅ 正确：IO 操作使用专用线程池&#xA;ExecutorService ioExecutor = Executors.newCachedThreadPool();&#xA;CompletableFuture.supplyAsync(() -&amp;gt; blockingIoOperation(), ioExecutor);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;104-避免过长的链式调用&#34;&gt;10.4 避免过长的链式调用&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ❌ 难以阅读和调试&#xA;CompletableFuture&amp;lt;String&amp;gt; bad = cf&#xA;    .thenApply(...)&#xA;    .thenCompose(...)&#xA;    .thenApply(...)&#xA;    .thenCompose(...)&#xA;    .thenApply(...)&#xA;    .thenCompose(...)&#xA;    .thenApply(...);&#xA;&#xA;// ✅ 拆分成有意义的方法&#xA;CompletableFuture&amp;lt;String&amp;gt; good = cf&#xA;    .thenCompose(this::validateInput)&#xA;    .thenCompose(this::processData)&#xA;    .thenCompose(this::saveResult);&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;105-资源清理&#34;&gt;10.5 资源清理&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// ✅ 使用 whenComplete 确保资源清理&#xA;CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&#xA;    .supplyAsync(() -&amp;gt; {&#xA;        Resource resource = acquireResource();&#xA;        try {&#xA;            return process(resource);&#xA;        } finally {&#xA;            // 这里的清理可能不会执行（如果是异步的）&#xA;        }&#xA;    })&#xA;    .whenComplete((result, error) -&amp;gt; {&#xA;        // 无论成功还是失败都会执行&#xA;        releaseResource();&#xA;    });&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;附录常用方法速查表&#34;&gt;附录：常用方法速查表&lt;/h2&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;方法&lt;/th&gt;&#xA;          &lt;th&gt;描述&lt;/th&gt;&#xA;          &lt;th&gt;返回类型&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;supplyAsync(Supplier)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;异步执行有返回值的任务&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;runAsync(Runnable)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;异步执行无返回值的任务&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;Void&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;thenApply(Function)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;同步转换结果&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;thenApplyAsync(Function)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;异步转换结果&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;thenCompose(Function)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;扁平化嵌套 Future&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;thenAccept(Consumer)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;消费结果&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;Void&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;thenRun(Runnable)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;执行后续操作&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;Void&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;handle(BiFunction)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;处理结果和异常&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;U&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;exceptionally(Function)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;异常恢复&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;whenComplete(BiConsumer)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;观察完成（不改变结果）&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;thenCombine(CF, BiFunction)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;合并两个 Future&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;V&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;allOf(CF...)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;等待所有完成&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;Void&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;anyOf(CF...)&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;任一完成&lt;/td&gt;&#xA;          &lt;td&gt;&lt;code&gt;CompletableFuture&amp;lt;Object&amp;gt;&lt;/code&gt;&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html&#34;&gt;Java CompletableFuture 官方文档&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/apache/flink/blob/master/flink-clients/src/main/java/org/apache/flink/client/program/rest/RestClusterClient.java&#34;&gt;Flink 源码 - RestClusterClient&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;https://github.com/apache/flink/blob/master/flink-runtime/src/main/java/org/apache/flink/runtime/dispatcher/Dispatcher.java&#34;&gt;Flink 源码 - Dispatcher&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;em&gt;本文档基于 Flink 1.19 源码分析编写&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink源码-Flink Client</title>
      <link>https://qiref.github.io/post/2025/12/04/flink%E6%BA%90%E7%A0%81-flink-client/</link>
      <pubDate>Thu, 04 Dec 2025 19:39:10 +0800</pubDate>
      <guid>https://qiref.github.io/post/2025/12/04/flink%E6%BA%90%E7%A0%81-flink-client/</guid>
      <description>&lt;h2 id=&#34;flink-client-layer-学习指南&#34;&gt;Flink Client Layer 学习指南&lt;/h2&gt;&#xA;&lt;p&gt;根据 Flink 源码的架构，Client Layer 主要负责&lt;strong&gt;作业提交、图转换、集群交互&lt;/strong&gt;。本文规划了一个从易到难、循序渐进的学习路径。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;作业提交入口&#34;&gt;作业提交入口&lt;/h2&gt;&#xA;&lt;p&gt;&lt;strong&gt;起点文件：&lt;/strong&gt; &lt;code&gt;StreamExecutionEnvironment.java&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// FileSinkDemo.java 中的这行代码是整个 Client Layer 的入口&#xA;env.execute(&amp;quot;Local FileSystem Debug&amp;quot;);&#xA;&#xA;// 学习路径：&#xA;// 1. StreamExecutionEnvironment.execute()&#xA;// 2. StreamExecutionEnvironment.executeAsync()&#xA;// 3. StreamExecutionEnvironment.getStreamGraph()&#xA;// 4. PipelineExecutor.execute()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;strong&gt;学习方式：&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建调试 Demo&#xA;public class ClientLayerLearningDemo {&#xA;    public static void main(String[] args) throws Exception {&#xA;        Configuration conf = new Configuration();&#xA;        StreamExecutionEnvironment env = &#xA;            StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(conf);&#xA;        &#xA;        env.setParallelism(2);&#xA;        &#xA;        // 简单的作业&#xA;        DataStream&amp;lt;String&amp;gt; source = env.fromElements(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;);&#xA;        source.map(x -&amp;gt; x.toUpperCase()).print();&#xA;        &#xA;        // 在这里打断点，开始追踪 Client Layer 的执行流程&#xA;        env.execute(&amp;quot;Client Layer Learning&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;strong&gt;重点方法：&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink源码学习指南</title>
      <link>https://qiref.github.io/post/2025/12/04/flink%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</link>
      <pubDate>Thu, 04 Dec 2025 11:08:10 +0800</pubDate>
      <guid>https://qiref.github.io/post/2025/12/04/flink%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/</guid>
      <description>&lt;p&gt;从 Flink 的整体架构开始，建立全局视野，再深入源码细节。&lt;/p&gt;&#xA;&lt;h2 id=&#34;flink-整体架构概览&#34;&gt;Flink 整体架构概览&lt;/h2&gt;&#xA;&lt;h3 id=&#34;三层架构模型&#34;&gt;三层架构模型&lt;/h3&gt;&#xA;&lt;p&gt;Flink 采用经典的主从架构，分为三层：&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Client Layer（客户端层）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Client：用户程序入口&lt;/li&gt;&#xA;&lt;li&gt;JobGraph Generation：将用户代码转换为 JobGraph&lt;/li&gt;&#xA;&lt;li&gt;Job Submission：提交作业到集群&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;Master Layer（主节点层）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;JobManager：集群主节点，包含以下组件：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Dispatcher：接收作业提交，管理作业生命周期&lt;/li&gt;&#xA;&lt;li&gt;ResourceManager：管理 TaskManager 资源，分配 slot&lt;/li&gt;&#xA;&lt;li&gt;JobMaster：单个作业的协调者，负责调度和 checkpoint&lt;/li&gt;&#xA;&lt;li&gt;Checkpoint Coordinator：协调 checkpoint 流程&lt;/li&gt;&#xA;&lt;li&gt;Scheduler：任务调度器&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;strong&gt;Worker Layer（工作节点层）&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;TaskManager：工作节点，包含以下组件：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Task Slot：执行具体任务的容器&lt;/li&gt;&#xA;&lt;li&gt;Network Stack：处理数据交换&lt;/li&gt;&#xA;&lt;li&gt;State Backend：管理算子状态&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;作业执行流程&#34;&gt;作业执行流程&lt;/h3&gt;&#xA;&lt;p&gt;以一个简单的 FileSinkDemo 为例：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(conf);&#xA;DataStream&amp;lt;String&amp;gt; source = env.fromData(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;, &amp;quot;flink&amp;quot;);&#xA;source.sinkTo(fileSink);&#xA;env.execute();&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;完整执行流程：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;用户代码 ---&amp;gt; StreamGraph ---&amp;gt; JobGraph ---&amp;gt; ExecutionGraph ---&amp;gt; 物理执行&#xA;   |              |              |               |                  |&#xA; Client        Client        Client         JobMaster          TaskManager&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;源码深入分析&#34;&gt;源码深入分析&lt;/h2&gt;&#xA;&lt;h3 id=&#34;第一阶段streamgraph-生成&#34;&gt;第一阶段：StreamGraph 生成&lt;/h3&gt;&#xA;&lt;h4 id=&#34;入口streamexecutionenvironment&#34;&gt;入口：StreamExecutionEnvironment&lt;/h4&gt;&#xA;&lt;p&gt;当调用 &lt;code&gt;env.fromData()&lt;/code&gt; 时，实际执行的是：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink内存模型</title>
      <link>https://qiref.github.io/post/2023/03/28/flink%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 28 Mar 2023 20:31:01 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/03/28/flink%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;h2 id=&#34;java-堆外内存&#34;&gt;Java 堆外内存&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import sun.nio.ch.DirectBuffer;&#xA;import java.nio.ByteBuffer;&#xA;import java.util.concurrent.TimeUnit;&#xA;&#xA;public class OutHeapMem {&#xA;    public static void main(String[] args) throws Exception {&#xA;        // 分配 1G 直接内存&#xA;        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024 * 1024 * 1024);&#xA;        TimeUnit.SECONDS.sleep(30);&#xA;&#xA;        System.out.println(&amp;quot;clean start&amp;quot;);&#xA;        // 清除直接内存&#xA;        ((DirectBuffer) byteBuffer).cleaner().clean();&#xA;        System.out.println(&amp;quot;clean finished&amp;quot;);&#xA;&#xA;        TimeUnit.SECONDS.sleep(30);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;# 分配内存&#xA;Memory                                  used         total        max           usage&#xA;heap                                    21M          165M         3641M         0.59%&#xA;ps_eden_space                           3M           64M          1344M         0.29%&#xA;ps_survivor_space                       0K           10752K       10752K        0.00%&#xA;ps_old_gen                              17M          91M          2731M         0.64%&#xA;nonheap                                 28M          28M          -1            96.89%&#xA;code_cache                              5M           5M           240M          2.11%&#xA;metaspace                               20M          21M          -1            97.00%&#xA;compressed_class_space                  2M           2M           1024M         0.25%&#xA;+direct                                 1024M        1024M        -             100.00%&#xA;mapped                                  0K           0K           -             0.00% &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;# 释放内存&#xA;Memory                                  used         total        max           usage&#xA;heap                                    21M          165M         3641M         0.60%&#xA;ps_eden_space                           4M           64M          1344M         0.32%&#xA;ps_survivor_space                       0K           10752K       10752K        0.00%&#xA;ps_old_gen                              17M          91M          2731M         0.64%&#xA;nonheap                                 27M          28M          -1            96.79%&#xA;code_cache                              5M           5M           240M          2.09%&#xA;metaspace                               20M          21M          -1            97.03%&#xA;compressed_class_space                  2M           2M           1024M         0.25%&#xA;-direct                                 0K           0K           -             0.00%&#xA;mapped                                  0K           0K           -             0.00%&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;通过 arthas 分析，分配直接内存会在 direct 开辟内存空间，表明是在堆外分配的内存空间；虽然 byteBuffer 指向了 direct memory，但是这个对象引用还在 heap 中，当 byteBuffer 对象引用 被 GC 算法回收掉之后，byteBuffer 指向的内存空间也会被释放；&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink类加载机制</title>
      <link>https://qiref.github.io/post/2023/03/24/flink%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 24 Mar 2023 16:13:22 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/03/24/flink%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h2 id=&#34;flink-类加载配置说明&#34;&gt;flink 类加载配置说明&lt;/h2&gt;&#xA;&lt;p&gt;Flink 作为基于 JVM 的框架，在 flink-conf.yaml 中提供了控制类加载策略的参数 classloader.resolve-order，可选项有 child-first（默认）和 parent-first。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;Key&lt;/th&gt;&#xA;          &lt;th&gt;Default&lt;/th&gt;&#xA;          &lt;th&gt;Type&lt;/th&gt;&#xA;          &lt;th&gt;Description&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;classloader.resolve-order&lt;/td&gt;&#xA;          &lt;td&gt;&amp;ldquo;child-first&amp;rdquo;&lt;/td&gt;&#xA;          &lt;td&gt;String&lt;/td&gt;&#xA;          &lt;td&gt;Defines the class resolution strategy when loading classes from user code, meaning whether to first check the user code jar (&amp;ldquo;child-first&amp;rdquo;) or the application classpath (&amp;ldquo;parent-first&amp;rdquo;). The default settings indicate to load classes first from the user code jar, which means that user code jars can include and load different dependencies than Flink uses (transitively).&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;classloader.parent-first-patterns.default&lt;/td&gt;&#xA;          &lt;td&gt;&amp;ldquo;java.&amp;rdquo;;&lt;br&gt;&amp;ldquo;scala.&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.flink.&amp;rdquo;;&lt;br&gt;&amp;ldquo;com.esotericsoftware.kryo&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.hadoop.&amp;rdquo;;&lt;br&gt;&amp;ldquo;javax.annotation.&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.xml&amp;rdquo;;&lt;br&gt;&amp;ldquo;javax.xml&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.xerces&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.w3c&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.rocksdb.&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.slf4j&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.log4j&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.logging&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.commons.logging&amp;rdquo;;&lt;br&gt;&amp;ldquo;ch.qos.logback&amp;rdquo;&lt;/td&gt;&#xA;          &lt;td&gt;List&lt;String&gt;&lt;/td&gt;&#xA;          &lt;td&gt;A (semicolon-separated) list of patterns that specifies which classes should always be resolved through the parent ClassLoader first. A pattern is a simple prefix that is checked against the fully qualified class name. This setting should generally not be modified. To add another pattern we recommend to use &amp;ldquo;classloader.parent-first-patterns.additional&amp;rdquo; instead.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;classloader.parent-first-patterns.additional&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;List&lt;String&gt;&lt;/td&gt;&#xA;          &lt;td&gt;A (semicolon-separated) list of patterns that specifies which classes should always be resolved through the parent ClassLoader first. A pattern is a simple prefix that is checked against the fully qualified class name. These patterns are appended to &amp;ldquo;classloader.parent-first-patterns.default&amp;rdquo;.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;classloader.fail-on-metaspace-oom-error&lt;/td&gt;&#xA;          &lt;td&gt;true&lt;/td&gt;&#xA;          &lt;td&gt;Boolean&lt;/td&gt;&#xA;          &lt;td&gt;Fail Flink JVM processes if &amp;lsquo;OutOfMemoryError: Metaspace&amp;rsquo; is thrown while trying to load a user code class.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;classloader.check-leaked-classloader&lt;/td&gt;&#xA;          &lt;td&gt;true&lt;/td&gt;&#xA;          &lt;td&gt;Boolean&lt;/td&gt;&#xA;          &lt;td&gt;Fails attempts at loading classes if the user classloader of a job is used after it has terminated. This is usually caused by the classloader being leaked by lingering threads or misbehaving libraries, which may also result in the classloader being used by other jobs. This check should only be disabled if such a leak prevents further jobs from running.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;parent-first-类加载策略&#34;&gt;parent-first 类加载策略&lt;/h2&gt;&#xA;&lt;p&gt;ParentFirstClassLoader 和 ChildFirstClassLoader 类的父类均为 FlinkUserCodeClassLoader 抽象类：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink反压</title>
      <link>https://qiref.github.io/post/2023/03/23/flink%E5%8F%8D%E5%8E%8B/</link>
      <pubDate>Thu, 23 Mar 2023 16:37:37 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/03/23/flink%E5%8F%8D%E5%8E%8B/</guid>
      <description>&lt;h2 id=&#34;什么是反压&#34;&gt;什么是反压&lt;/h2&gt;&#xA;&lt;p&gt;如果你看到一个 Task 发生 &lt;strong&gt;反压警告&lt;/strong&gt;（例如： &lt;code&gt;High&lt;/code&gt;），意味着它生产数据的速率比下游 Task 消费数据的速率要快。 在工作流中数据记录是从上游向下游流动的（例如：从 Source 到 Sink）。反压沿着相反的方向传播，沿着数据流向上游传播。&lt;/p&gt;&#xA;&lt;p&gt;以一个简单的 &lt;code&gt;Source -&amp;gt; Sink&lt;/code&gt; Job 为例。如果看到 &lt;code&gt;Source&lt;/code&gt; 发生了警告，意味着 &lt;code&gt;Sink&lt;/code&gt; 消费数据的速率比 &lt;code&gt;Source&lt;/code&gt; 生产数据的速率要慢。 &lt;code&gt;Sink&lt;/code&gt; 正在向上游的 &lt;code&gt;Source&lt;/code&gt; 算子产生反压。&lt;/p&gt;&#xA;&lt;p&gt;Task（SubTask）的每个并行实例都可以用三个一组的指标评价：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;backPressureTimeMsPerSecond&lt;/code&gt;，subtask 被反压的时间&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;idleTimeMsPerSecond&lt;/code&gt;，subtask 等待某类处理的时间&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;busyTimeMsPerSecond&lt;/code&gt;，subtask 实际工作时间 在任何时间点，这三个指标相加都约等于&lt;code&gt;1000ms&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;指标值说明：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;OK&lt;/strong&gt;: 0 &amp;lt;= 比例 &amp;lt;= 0.10&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LOW&lt;/strong&gt;: 0.10 &amp;lt; 比例 &amp;lt;= 0.5&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HIGH&lt;/strong&gt;: 0.5 &amp;lt; 比例 &amp;lt;= 1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;反压问题定位&#34;&gt;反压问题定位&lt;/h2&gt;&#xA;&lt;p&gt;可以看各个operator的metrics的指标，比如：buffers.outPoolUsage、buffers.inPoolUsage、buffers.inputFloatingBuffersUsage、buffers.inputExclusiveBuffersUsage；&lt;/p&gt;&#xA;&lt;p&gt;接收端共用一个LocalBufferPool，接收端每个Channel在初始化阶段都会分配固定数量的Buffer(Exclusive Buffer)。如果某一时刻接收端接受到的数量太多，Exclusive Buffer就会耗尽，此时就会向BufferPool申请剩余的Floating Buffer（除了Exclusive Buffer，其他的都是Floating Buffer,备用Buffer）；&lt;code&gt;inPoolUsage = floatingBuffersUsage + exclusiveBuffersUsage&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;若 inPoolUsage 低，而 outPoolUsage 低，则说明完全没有背压现象。&lt;/li&gt;&#xA;&lt;li&gt;若 inPoolUsage 低，而 outPoolUsage 高，则说明处于临时状态，可能是背压刚开始，也可能是刚结束，需要再观察。&lt;/li&gt;&#xA;&lt;li&gt;若 inPoolUsage 高，而 outPoolUsage 低，那么通常情况下这个算子就是背压的根源了。&lt;/li&gt;&#xA;&lt;li&gt;若 inPoolUsage 高，而 outPoolUsage 高，则说明这个算子是被其他下游算子反压而来的，并不是元凶。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在反压定位过程中，建议关闭 Operator Chaining 优化，这样所有的算子可以单独拆分出来，不会相互干扰：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink Append流、Retract流、Upsert流</title>
      <link>https://qiref.github.io/post/2022/03/13/flink-append%E6%B5%81retract%E6%B5%81upsert%E6%B5%81/</link>
      <pubDate>Sun, 13 Mar 2022 11:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/03/13/flink-append%E6%B5%81retract%E6%B5%81upsert%E6%B5%81/</guid>
      <description>&lt;p&gt;摘要： 介绍 Flink 中 Append流、Retract流、Upsert流的含义。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#append%E6%B5%81&#34;&gt;Append流&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#retract%E6%B5%81&#34;&gt;Retract流&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#upsert%E6%B5%81&#34;&gt;Upsert流&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;append流&#34;&gt;Append流&lt;/h2&gt;&#xA;&lt;p&gt;在 Append 流中，仅通过 &lt;code&gt;INSERT&lt;/code&gt; 操作修改的动态表，可以通过输出插入的行转换为流。&lt;/p&gt;&#xA;&lt;h2 id=&#34;retract流&#34;&gt;Retract流&lt;/h2&gt;&#xA;&lt;p&gt;retract 流包含两种类型的 message： add messages 和 retract messages 。&lt;/p&gt;&#xA;&lt;p&gt;通过将INSERT 操作编码为 add message、将 &lt;code&gt;DELETE&lt;/code&gt; 操作编码为 retract message、将 &lt;code&gt;UPDATE&lt;/code&gt; 操作编码为更新(先前)行的 retract message 和更新(新)行的 add message，将动态表转换为 retract 流。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;OPERATOR&lt;/th&gt;&#xA;          &lt;th&gt;ENCODE&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;insert&lt;/td&gt;&#xA;          &lt;td&gt;add&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;update&lt;/td&gt;&#xA;          &lt;td&gt;retract -&amp;gt; add&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;delete&lt;/td&gt;&#xA;          &lt;td&gt;retract&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;upsert流&#34;&gt;Upsert流&lt;/h2&gt;&#xA;&lt;p&gt;upsert 流包含两种类型的 message： upsert messages 和delete messages。&lt;/p&gt;&#xA;&lt;p&gt;转换为 upsert 流的动态表需要(可能是组合的)唯一键。通过将 &lt;code&gt;INSERT&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 操作编码为 upsert message，将 &lt;code&gt;DELETE&lt;/code&gt; 操作编码为 delete message ，将具有唯一键的动态表转换为流。消费流的算子需要知道唯一键的属性，以便正确地应用 message。与 retract 流的主要区别在于 &lt;code&gt;UPDATE&lt;/code&gt; 操作是用单个 message 编码的，因此效率更高。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink Checkpoint机制</title>
      <link>https://qiref.github.io/post/2022/03/04/flink-checkpoint%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 04 Mar 2022 11:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/03/04/flink-checkpoint%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;p&gt;摘要： 如果把运行中的 Flink 程序比做一条河流，Checkpoint 就是一个相机，定期地对河流进行拍照，记录河水的状态。本文以自顶向下的视角，从理论到实现，分析 Flink 中的 Checkpoint 机制；&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80&#34;&gt;理论基础&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#asynchronous-barrier-snapshotting&#34;&gt;asynchronous barrier snapshotting&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4&#34;&gt;算法步骤&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%AE%97%E6%B3%95%E5%9C%A8-flink-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0&#34;&gt;算法在 Flink 中的实现&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-checkpoint-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B&#34;&gt;Flink Checkpoint 整体流程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-checkpoint-barrier-alignment&#34;&gt;Flink Checkpoint Barrier Alignment&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-checkpoint-%E4%BD%BF%E7%94%A8&#34;&gt;Flink Checkpoint 使用&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-job-%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5&#34;&gt;Flink Job 重启策略&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-job-%E5%BC%80%E5%90%AF-checkpoint&#34;&gt;Flink Job 开启 Checkpoint&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;理论基础&#34;&gt;理论基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;asynchronous-barrier-snapshotting&#34;&gt;asynchronous barrier snapshotting&lt;/h3&gt;&#xA;&lt;p&gt;Flink Checkpoint 机制是异步屏障快照（asynchronous barrier snapshotting, ABS）算法的一种实现，而 ABS 算法基于 &lt;a href=&#34;https://archieyao.github.io/posts/2023-05-08-chandy-lamport%E7%AE%97%E6%B3%95/&#34;&gt;Chandy-Lamport&lt;/a&gt; 的变种，但数据模型是还是基于  Chandy-Lamport；&lt;/p&gt;&#xA;&lt;p&gt;在 flink 中，作业算子被抽象为 DAG，节点为 operator，边是每一个 operator 的 stream（channel），与 Chandy-Lamport 的数据模型正好吻合；&lt;/p&gt;&#xA;&lt;p&gt;ABS 算法把 Chandy-Lamport 中的 marker 消息换成了 barrier，作用是一致的，都是切分 snapshot；&lt;/p&gt;&#xA;&lt;p&gt;ABS 算法 中 asynchronous 是异步的意思，当算子收齐 barrier 并触发快照之后，不会等待快照数据全部写入状态后端，而是一边后台写入，一边立刻继续处理数据流，并将 barrier 发送到下游，实现了最小化延迟。当然，引入异步性之后，所有有状态的算子都需要上报 ack，否则 JobManager 就无法确认一次 snapshot 是否完成。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink时间语义</title>
      <link>https://qiref.github.io/post/2022/02/25/flink%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89/</link>
      <pubDate>Fri, 25 Feb 2022 11:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/02/25/flink%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89/</guid>
      <description>&lt;p&gt;摘要： 理解流处理中的时间语义，处理时间和事件时间。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/stream-time.png&#34; alt=&#34;stream-time&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如图，在无界数据中，随着时间推移，数据一直产生，但真实情况中，往往在一段时间内的数据都是不均匀的，往往会出现意外的情况，比如在地铁无信号的情况下，数据虽然产生，但是会有一段时间延迟才会到达消息队列，例如虚线框中的数据。&lt;/p&gt;&#xA;&lt;h2 id=&#34;处理时间&#34;&gt;处理时间&lt;/h2&gt;&#xA;&lt;p&gt;处理时间就是流计算处理程序的机器本地时间，按照这种时间语义，在流计算的时间窗口中，上述例子中的数据会按这样分布：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/process-time.png&#34; alt=&#34;process-time&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;基于本地时间，在第一分钟，流处理程序只收到了 &lt;code&gt;15&lt;/code&gt;、&lt;code&gt;18&lt;/code&gt; 两个数据，后续数据由于网络原因，在 8:01:00 之后才到达流计算程序，所以后续数据在下一个时间窗口内。&lt;/p&gt;&#xA;&lt;h2 id=&#34;事件时间&#34;&gt;事件时间&lt;/h2&gt;&#xA;&lt;p&gt;事件时间就是事件的发生时间，这个时间通常会在数据中，按照这种时间语义，在流计算的时间窗口中，上述例子中的数据会按这样分布：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/event-time.png&#34; alt=&#34;event-time&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;基于事件时间，在第一分钟，数据应该是：&lt;code&gt;15&lt;/code&gt; &lt;code&gt;18&lt;/code&gt; &lt;code&gt;9&lt;/code&gt; &lt;code&gt;10&lt;/code&gt; ，在第二分钟，数据应该是：&lt;code&gt;11&lt;/code&gt; 。&lt;/p&gt;&#xA;&lt;h2 id=&#34;watermark&#34;&gt;watermark&lt;/h2&gt;&#xA;&lt;p&gt;由于事件时间的窗口和事件相关，那么如果下一个事件还未到达，流计算程序是否就无限等待呢？&lt;/p&gt;&#xA;&lt;p&gt;为了解决这个问题，flink 引入 watermark 的概念，假如定义 watermark 为 T，那么在每一个时间窗口中，T 都会单调递增 &lt;code&gt;T &amp;lt; T1&lt;/code&gt;，并且下一个时间窗口中的事件时间必须大于 &lt;code&gt;T1&lt;/code&gt;，那么每一个时间窗口的数据就是介于 &lt;code&gt;T-T1&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink基本架构</title>
      <link>https://qiref.github.io/post/2022/02/23/flink%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Wed, 23 Feb 2022 11:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/02/23/flink%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;p&gt;摘要： 鸟瞰 Flink 架构，分析 Flink 内部组件工作机制。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-%E6%9E%B6%E6%9E%84%E5%9B%BE&#34;&gt;Flink 架构图&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A%E6%B5%81%E7%A8%8B&#34;&gt;提交作业流程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F&#34;&gt;Flink 集群模式&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#jobmanager&#34;&gt;JobManager&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#taskmanager&#34;&gt;Taskmanager&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%AE%97%E5%AD%90%E9%93%BE&#34;&gt;算子链&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#slot&#34;&gt;Slot&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#task-%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5&#34;&gt;task 数据交换策略&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;flink-架构图&#34;&gt;Flink 架构图&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/flink-struct.svg&#34; alt=&#34;Flink架构图&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;一个完整的 Flink 集群由一个 Jobmanager 和若干个 Taskmanager 组成，Jobmanager 主要负责调度 task 以及 协调 Checkpoint。Taskmanager 则负责具体的 task 执行，以及数据流的交换。&lt;/p&gt;&#xA;&lt;p&gt;可以通过多种方式启动 JobManager 和 TaskManager：直接在机器上作为standalone 集群启动、在容器中启动、或者通过YARN等资源框架管理并启动。TaskManager 连接到 JobManagers，宣布自己可用，并被分配工作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;提交作业流程&#34;&gt;提交作业流程&lt;/h2&gt;&#xA;&lt;p&gt;以一个作业提交的流程来说明 Flink 各个组件是如何交互和工作的：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/flink-struct-1.svg&#34; alt=&#34;提交作业流程&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;flink-集群模式&#34;&gt;Flink 集群模式&lt;/h2&gt;&#xA;&lt;p&gt;Flink 集群类型一般有以下几种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Flink Session 集群&lt;/p&gt;&#xA;&lt;p&gt;这种模式下，集群自创建开始，最后到集群生命周期结束，不受作业因素影响； 集群下的多个作业共享 内存、网络、磁盘等资源，如果集群出现异常，该集群下的所有作业都会收到影响。&lt;/p&gt;&#xA;&lt;p&gt;优点：提交作业速度很快，无需提前申请资源； 并且资源利用率较高。&lt;/p&gt;&#xA;&lt;p&gt;缺点：作业之间隔离性较差，横向扩展不太方便。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Flink job 集群&lt;/p&gt;&#xA;&lt;p&gt;这种模式也称 pre-job 模式，集群交由 资源管理器托管，例如 Yarn ，需要运行作业，第一步申请资源，启动一个 Flink 集群，第二步提交作业，这种模式下，每个作业会独享一个 Flink 集群。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink WordCount</title>
      <link>https://qiref.github.io/post/2022/02/22/flink-wordcount/</link>
      <pubDate>Tue, 22 Feb 2022 18:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/02/22/flink-wordcount/</guid>
      <description>&lt;p&gt;摘要：Flink 从零开始，下载集群并运行 WordCount Job。 完整代码地址： &lt;a href=&#34;https://github.com/ArchieYao/flink-learning/tree/main/hello-world&#34;&gt;https://github.com/ArchieYao/flink-learning/tree/main/hello-world&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;flink-本地模式集群安装&#34;&gt;Flink 本地模式集群安装&lt;/h2&gt;&#xA;&lt;p&gt;运行Flink，需提前安装好 Java 8 或者 Java 11。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://dlcdn.apache.org/flink/flink-1.14.3/flink-1.14.3-bin-scala_2.12.tgz&#xA;tar -zxvf flink-1.14.3-bin-scala_2.12.tgz&#xA;cd flink-1.14.3&#xA;./bin/start-cluster.sh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;运行成功后，可以在 IP:8081 访问 Flink-UI&lt;/p&gt;&#xA;&lt;h2 id=&#34;flink-word-count-job&#34;&gt;Flink Word Count job&lt;/h2&gt;&#xA;&lt;p&gt;source 是多段文本，类型： DataSource&lt;String&gt; ，经过 flatMap，切分为每个单词，然后转换为：(val,n) 的数据，然后根据 val 分组统计，得出 sum(n) 的值。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws Exception {&#xA;    // 创建Flink任务运行环境&#xA;    final ExecutionEnvironment executionEnvironment =&#xA;            ExecutionEnvironment.getExecutionEnvironment();&#xA;&#xA;    // 创建DataSet，数据是一行一行文本&#xA;    DataSource&amp;lt;String&amp;gt; text =&#xA;            executionEnvironment.fromElements(&#xA;                    &amp;quot;Licensed to the Apache Software Foundation (ASF) under one&amp;quot;,&#xA;                    &amp;quot;or more contributor license agreements.  See the NOTICE file&amp;quot;,&#xA;                    &amp;quot;distributed with this work for additional information&amp;quot;,&#xA;                    &amp;quot;regarding copyright ownership.  The ASF licenses this file&amp;quot;,&#xA;                    &amp;quot;to you under the Apache License, Version 2.0 (the&amp;quot;);&#xA;&#xA;    // 通过Flink内置转换函数进行计算&#xA;    AggregateOperator&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; sum =&#xA;            text.flatMap(&#xA;                            new FlatMapFunction&amp;lt;String, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt;() {&#xA;                                @Override&#xA;                                public void flatMap(&#xA;                                        String value,&#xA;                                        Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; collector)&#xA;                                        throws Exception {&#xA;                                    String[] split = value.split(&amp;quot;\\W+&amp;quot;);&#xA;                                    for (String s : split) {&#xA;                                        if (s.length() &amp;gt; 0) {&#xA;                                            collector.collect(new Tuple2&amp;lt;&amp;gt;(s, 1));&#xA;                                            // TimeUnit.SECONDS.sleep(5);&#xA;                                        }&#xA;                                    }&#xA;                                }&#xA;                            })&#xA;                    .groupBy(0)&#xA;                    .sum(1);&#xA;&#xA;    // 打印结果&#xA;    sum.print();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Job 可以直接运行，也可以提交到 Flink 集群中运行。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
