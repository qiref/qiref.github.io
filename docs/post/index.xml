<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 大道至简</title>
    <link>https://qiref.github.io/post/</link>
    <description>Recent content in Posts on 大道至简</description>
    <generator>Hugo</generator>
    <language>cn-zh</language>
    <lastBuildDate>Fri, 18 Jul 2025 17:12:09 +0800</lastBuildDate>
    <atom:link href="https://qiref.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Chuck Based 分布式定时任务调度</title>
      <link>https://qiref.github.io/post/2025/07/18/chuck-based-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</link>
      <pubDate>Fri, 18 Jul 2025 17:12:09 +0800</pubDate>
      <guid>https://qiref.github.io/post/2025/07/18/chuck-based-%E5%88%86%E5%B8%83%E5%BC%8F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6/</guid>
      <description>&lt;h2 id=&#34;问题背景&#34;&gt;问题背景&lt;/h2&gt;&#xA;&lt;p&gt;有个event表的数据，需要用定时任务定期处理，处理后状态改为已完成；&#xA;定时任务所在的程序是多实例的，希望能通过横向扩展，加速定时任务处理的吞吐量；&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6-1.svg&#34; alt=&#34;原始问题&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;当 scheduler task 横向扩容，出现多个实例时，多个定时任务同时执行，为了保证同一时间只有一个实例执行定时任务，多个定时任务之间需要加锁，并发量不大的情况下，可以用数据库实现一个简单的分布式锁；&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;CREATE TABLE `locker` (&#xA;  `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,&#xA;  `bizType` varchar(100) NOT NULL,&#xA;  `bizId` varchar(100) NOT NULL,&#xA;  `createTime` datetime DEFAULT CURRENT_TIMESTAMP,&#xA;  `updateTime` datetime DEFAULT CURRENT_TIMESTAMP,&#xA;  `unlockTime` datetime DEFAULT &#39;0000-00-00 00:00:00&#39;,&#xA;  PRIMARY KEY (`id`),&#xA;  UNIQUE KEY `bizType` (`bizType`,`bizId`)&#xA;) ENGINE=InnoDB AUTO_INCREMENT=2593578 DEFAULT CHARSET=utf8mb3 COMMENT=&#39;locker&#39;;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;相同定时任务使用相同的 bizType+bizId；通过UNIQUE KEY 约束，同时只能有一个实例写入数据；写入成功则获取到锁；&lt;/li&gt;&#xA;&lt;li&gt;获取到锁时，写入一个过期时间，任务执行过程中，不断对锁进行续期；&lt;/li&gt;&#xA;&lt;li&gt;另起定时任务，扫描过期的锁进行清除；&lt;/li&gt;&#xA;&lt;li&gt;定时任务结束后，清除锁；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在这种场景下，多个定时任务进程中，同时只有一个实例执行；当原始问题中的 Event table 数据量很大，需要增加处理吞吐量时，无法通过横向扩容解决。&lt;/p&gt;&#xA;&lt;h2 id=&#34;定时任务拆分&#34;&gt;定时任务拆分&lt;/h2&gt;&#xA;&lt;p&gt;受 DBLog 论文启发，可以提前对数据进行分片，不同分片交给不同的实例进行处理，从而提高吞吐量；&lt;/p&gt;&#xA;&lt;p&gt;具体思路如下:&lt;/p&gt;</description>
    </item>
    <item>
      <title>容器网络原理分析-单主机容器网络</title>
      <link>https://qiref.github.io/post/2025/05/30/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E5%8D%95%E4%B8%BB%E6%9C%BA%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</link>
      <pubDate>Fri, 30 May 2025 16:28:12 +0800</pubDate>
      <guid>https://qiref.github.io/post/2025/05/30/%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E5%8D%95%E4%B8%BB%E6%9C%BA%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</guid>
      <description>&lt;h2 id=&#34;单主机容器通信&#34;&gt;单主机容器通信&lt;/h2&gt;&#xA;&lt;p&gt;在容器环境中，启动两个container，C1，C2，默认情况下，C1 和 C2 网络是通的，但是在 C1 和 C2 中，都分配了自己的 IP；&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;# 启动两个容器环境&#xA;&#xA;# 172.17.0.3&#xA;docker run -d --name containerA nginx:alpine&#xA;&#xA;# 172.17.0.2&#xA;docker run -d --name containerB nginx:alpine&#xA;&#xA;# 登录containerA ping containerB，网络能通&#xA;docker exec -it containerA sh&#xA;&#xA;# ping 172.17.0.2&#xA;PING 172.17.0.2 (172.17.0.2): 56 data bytes&#xA;64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.076 ms&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;为什么在两个 container 中，网络都是互通的呢？&lt;/p&gt;&#xA;&lt;p&gt;在 contaner 中，查看网络配置：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker exec -it containerA sh&#xA;ifconfig&#xA;eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:03&#xA;          inet addr:172.17.0.3  Bcast:172.17.255.255  Mask:255.255.0.0&#xA;          inet6 addr: fe80::42:acff:fe11:3/64 Scope:Link&#xA;          inet6 addr: fd00:dead:beef:c0:0:242:ac11:3/80 Scope:Global&#xA;          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1&#xA;          RX packets:275 errors:0 dropped:0 overruns:0 frame:0&#xA;          TX packets:139 errors:0 dropped:0 overruns:0 carrier:0&#xA;          collisions:0 txqueuelen:0&#xA;          RX bytes:19546 (19.0 KiB)  TX bytes:9854 (9.6 KiB)&#xA;&#xA;lo        Link encap:Local Loopback&#xA;          inet addr:127.0.0.1  Mask:255.0.0.0&#xA;          inet6 addr: ::1/128 Scope:Host&#xA;          UP LOOPBACK RUNNING  MTU:65536  Metric:1&#xA;          RX packets:0 errors:0 dropped:0 overruns:0 frame:0&#xA;          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0&#xA;          collisions:0 txqueuelen:1000&#xA;          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)&#xA;&#xA;route -n&#xA;Kernel IP routing table&#xA;Destination     Gateway         Genmask         Flags Metric Ref    Use Iface&#xA;0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0&#xA;172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;从容器中的配置来看：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Paxos推导过程</title>
      <link>https://qiref.github.io/post/2025/01/01/paxos%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Wed, 01 Jan 2025 16:29:06 +0800</pubDate>
      <guid>https://qiref.github.io/post/2025/01/01/paxos%E6%8E%A8%E5%AF%BC%E8%BF%87%E7%A8%8B/</guid>
      <description>&lt;p&gt;paxos 是一个分布式共识算法, 就是用来解决分布式系统中, 多副本数据如何保证读写一致性的问题.&lt;/p&gt;&#xA;&lt;h3 id=&#34;不完美的副本数据同步机制&#34;&gt;不完美的副本数据同步机制&lt;/h3&gt;&#xA;&lt;p&gt;假设我们有个分布式存储系统, 数据在写入时, 需要把数据写入到其他节点: 副本数据从一个节点复制到其他节点, 有几种复制办法:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;同步复制&lt;/li&gt;&#xA;&lt;li&gt;异步复制&lt;/li&gt;&#xA;&lt;li&gt;半同步复制&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h4 id=&#34;同步复制&#34;&gt;同步复制&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;# node1, node2, node3 &#xA;&#xA;a=x --&amp;gt; node1 --&amp;gt; node2&#xA;              ------&amp;gt; node3&#xA;                           --&amp;gt; done&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;数据在一次写入时, 需要同时写入 node1, node2, node3 三个节点, 写入完成才算是一次写入成功;&lt;/p&gt;&#xA;&lt;p&gt;同步复制有什么问题:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;性能低下; 写入性能会受制于节点数量;&lt;/li&gt;&#xA;&lt;li&gt;没有容错, 任何一个节点写入失败, 则系统不可用;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;异步复制&#34;&gt;异步复制&lt;/h4&gt;&#xA;&lt;pre&gt;&lt;code&gt;a=x --&amp;gt; node1 &#xA;             --&amp;gt; done&#xA;             async( node1  --&amp;gt; node2 ; node1  --&amp;gt; node3 ) &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;数据在一次写入时, 只要写入一个节点, 则认定写入成功, node1 写入 node2; node1 写入 node3 是异步复制, 不影响整体写入结果;&lt;/p&gt;&#xA;&lt;p&gt;异步复制有什么问题:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;数据可能存在不一致, 当 async( node1  &amp;ndash;&amp;gt; node2) 写入失败时, node2 和 node1 上的数据就不一致;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;半同步复制&#34;&gt;半同步复制&lt;/h4&gt;&#xA;&lt;p&gt;数据在一次写入时, 数据必须写入一定量的副本(不是全部), 这样多副本则提供了较高的可靠性;&lt;/p&gt;</description>
    </item>
    <item>
      <title>两阶段提交和三阶段提交</title>
      <link>https://qiref.github.io/post/2024/07/25/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%92%8C%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</link>
      <pubDate>Thu, 25 Jul 2024 20:57:06 +0800</pubDate>
      <guid>https://qiref.github.io/post/2024/07/25/%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%92%8C%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4/</guid>
      <description>&lt;h2 id=&#34;分布式共识问题&#34;&gt;分布式共识问题&lt;/h2&gt;&#xA;&lt;p&gt;分布式共识问题是指在分布式系统中，多个节点或参与者需要就某个共同的结果达成一致意见的问题。例如主从同步问题, 简单的主从同步可以借助两阶段提交和三阶段提交来解决,确保所有节点上的事务操作能够保持一致性，即要么全部提交，要么全部回滚。&lt;/p&gt;&#xA;&lt;h2 id=&#34;两阶段提交&#34;&gt;两阶段提交&lt;/h2&gt;&#xA;&lt;p&gt;在主从同步的场景中, backup 需要从 master 同步数据, 从数据写入的场景来说, 假定主从节点是同步复制, 实际上就是一次分布式事务, backup 和 master 的一次写入要么都成功, 要么都失败, 才能保证主从节点的数据一致性;&lt;/p&gt;&#xA;&lt;p&gt;借助两阶段提交, 需要引入一个协调者: Coordinator, 如下:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/2phase-commit-1.svg&#34; alt=&#34;2phase-commit-1&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;将提交过程分为两个阶段: PreCommit、commit;&lt;/p&gt;&#xA;&lt;p&gt;在 PreCommit 阶段, 执行 WAL 流程, 把事务日志提前写入, 然后 Coordinator 在收到参与者的 PreCommit ack 之后, 开启第二阶段 commit, commit 成功之后, 数据才算是真正的写入. 当 PreCommit 失败时, Coordinator 会发起事务回滚, 所有参与者会基于 WAL 的事务日志, 回滚此次事务;&lt;/p&gt;&#xA;&lt;p&gt;当 Coordinator 和 Participant 网络异常时, 如果是在 PreCommit 阶段, 那事务都不会提交, 相当于一次写入就失败了;  如果在 commit 阶段网络异常, Coordinator 会重试执行, 直到 Participant 恢复, 事务重新提交或者回滚. 但在此期间, 客户端的写入都会被拒绝, 此时分布式系统处于不可用状态(相当于保证了数据一致性, 牺牲了可用性)&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于锁的思考和总结(二)</title>
      <link>https://qiref.github.io/post/2024/05/21/%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93%E4%BA%8C/</link>
      <pubDate>Tue, 21 May 2024 15:53:46 +0800</pubDate>
      <guid>https://qiref.github.io/post/2024/05/21/%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93%E4%BA%8C/</guid>
      <description>&lt;p&gt;书接上文, 在单机模式下, 可以借助操作系统能力, 使用原子指令去实现锁, 但是在分布式场景中, 这种方案就会无法实现, 因为要竞争锁的进程在不同的机器上, 分布式锁因此而诞生.&lt;/p&gt;&#xA;&lt;h2 id=&#34;分布式锁的常见问题&#34;&gt;分布式锁的常见问题&lt;/h2&gt;&#xA;&lt;p&gt;举一个很常见的案例, 如果某个服务为了实现高可用而采用了多副本模式, 当服务中存在定时任务, 如何保证同时只有一个定时任务在运行呢? 从这里, 问题就开始变得复杂.&lt;/p&gt;&#xA;&lt;p&gt;很常规的思路就是借助数据库, 操作系统提供了原子指令, 同样, 数据库也提供了事务来保证原子性, 那么案例中的问题可以这么解决:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;可以设计一张表 lock, &lt;code&gt;id, key&lt;/code&gt; 两个字段, 把 key 设置为唯一索引; key 的业务意义是定时任务的唯一标识;&lt;/li&gt;&#xA;&lt;li&gt;每个实例执行定时任务之前, 往表里写入一条数据: &lt;code&gt;(1, tastA)&lt;/code&gt;, 由于事务机制的存在, 如果此时有其他实例往这个表里写数据时就会失败, 此时跳过当前实例的定时任务;&lt;/li&gt;&#xA;&lt;li&gt;执行完定时任务之后, 把 (1, taskA) 这条记录删除;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;问题解决了吗? 考虑一下异常情况: 当实例A拿到锁之后挂了, 那其他实例永远也拿不到锁了;&lt;/p&gt;&#xA;&lt;p&gt;一个很直观的思路就是给锁设置超时时间, 但是设置超时时间就需要权衡了, 如果定时任务本身的耗时跟锁的超时时间还要长, 那就会出现锁超时而导致同时两个实例在执行定时任务, 因此, 这个方案是需要一定的前提的, 这取决于实际的业务场景;&lt;/p&gt;&#xA;&lt;p&gt;再更进一步思考, 如果真的定时任务比锁的超时时间还长, 怎么解决呢?  锁的超时时间如果能动态变化, 这个问题就引刃而解了, 这就是锁续期;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;lock 表结构改为: &lt;code&gt;id, key, createTime, expiredTime&lt;/code&gt; ;&lt;/li&gt;&#xA;&lt;li&gt;在执行定时任务时,往表里写一条数据 &lt;code&gt;(1, tastA)&lt;/code&gt;,  同步开一个线程去给锁续期, expiredTime 时间增加;&lt;/li&gt;&#xA;&lt;li&gt;定时任务执行结束时, 续期线程退出, 删除记录 &lt;code&gt;(1, tastA)&lt;/code&gt;;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;注意, 续期的前提是加了锁超时的机制, 如果使用数据库的话, 需要定期扫描, 发现已经达到 expiredTime 时, 就删除记录;&lt;/p&gt;</description>
    </item>
    <item>
      <title>关于锁的思考和总结(一)</title>
      <link>https://qiref.github.io/post/2024/05/15/%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93%E4%B8%80/</link>
      <pubDate>Wed, 15 May 2024 15:53:46 +0800</pubDate>
      <guid>https://qiref.github.io/post/2024/05/15/%E5%85%B3%E4%BA%8E%E9%94%81%E7%9A%84%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93%E4%B8%80/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func add (a *int) *int { &#xA;  *a++ // 线程不安全&#xA;  return a&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;这是一段很典型的线程不安全的代码示例, 在并发场景下, a 的结果是不确定的, 大概率会小于 1000, 原因是 &lt;code&gt;a++&lt;/code&gt; 并非原子操作, 会存在同时有两个协程读取到 a 的值是相同的情况, 执行 &lt;code&gt;a++&lt;/code&gt;之后再重新回写时, a的值也是相同的, 想要变为线程安全, 就需要在操作临界资源之前加锁;&lt;/p&gt;&#xA;&lt;h2 id=&#34;mutex&#34;&gt;Mutex&lt;/h2&gt;&#xA;&lt;p&gt;在操作共享资源之前加锁, 然后操作完临界资源之后释放锁, 保证同时只有一个协程操作临界资源;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var mu sync.Mutex&#xA;func addSafe(a *int) *int {&#xA;  mu.Lock() // 加锁&#xA;  defer mu.Unlock() // 释放锁&#xA;  *a++&#xA;  return a&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;锁在多线程或多进程环境中实现资源的互斥访问。当一个线程或进程想要访问某个共享资源（如数据结构、文件等）时，它必须首先尝试获取该资源对应的锁。如果锁未被其他线程或进程占用，那么请求的线程或进程将获得锁并继续执行；否则，它将等待，直到锁被释放。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// If the lock is already in use, the calling goroutine&#xA;// blocks until the mutex is available.&#xA;func (m *Mutex) Lock() {&#xA;  // Fast path: grab unlocked mutex.&#xA;  if atomic.CompareAndSwapInt32(&amp;amp;m.state, 0, mutexLocked) {&#xA;    if race.Enabled {&#xA;      race.Acquire(unsafe.Pointer(m))&#xA;    }&#xA;    return&#xA;  }&#xA;  // Slow path (outlined so that the fast path can be inlined)&#xA;  m.lockSlow()&#xA;}&#xA;&#xA;type Mutex struct {&#xA;  state int32 // state 表示当前互斥锁的状态&#xA;  sema  uint32 // sema 是用于控制锁状态的信号量&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;在 &lt;code&gt;golang&lt;/code&gt; 的实现中, 如果通过 &lt;code&gt;CompareAndSwapInt32&lt;/code&gt; 也就是 &lt;code&gt;CAS&lt;/code&gt; 能获取到锁, 表明协程已经能拿到锁了, 此时直接返回;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go ppfof工具使用</title>
      <link>https://qiref.github.io/post/2024/02/23/go-ppfof%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 23 Feb 2024 15:53:46 +0800</pubDate>
      <guid>https://qiref.github.io/post/2024/02/23/go-ppfof%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;h2 id=&#34;pprof&#34;&gt;pprof&lt;/h2&gt;&#xA;&lt;p&gt;pprof 是用于可视化和分析性能分析数据的工具;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;runtime/pprof：采集程序（非 Server）的运行数据进行分析&lt;/li&gt;&#xA;&lt;li&gt;net/http/pprof：采集 HTTP Server 的运行时数据进行分析&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;启用方式&#34;&gt;启用方式&lt;/h2&gt;&#xA;&lt;p&gt;在&lt;code&gt;main&lt;/code&gt;函数之前使用启动, &lt;code&gt;DoProfile(6060)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&#xA;import (&#xA;    &amp;quot;net/http&amp;quot;&#xA;    _ &amp;quot;net/http/pprof&amp;quot;&#xA;    &amp;quot;strconv&amp;quot;&#xA;)&#xA;&#xA;type ProfileServer struct {&#xA;}&#xA;&#xA;func (this *ProfileServer) DoProfile(port int) {&#xA;    go func() {&#xA;        err := http.ListenAndServe(&amp;quot;:&amp;quot;+strconv.FormatInt(int64(port), 10), nil)&#xA;        if err != nil {&#xA;            log.Errorf(&amp;quot;Failed to do profile on port: %d&amp;quot;, port)&#xA;        } else {&#xA;            log.Infof(&amp;quot;pprof start successfully on port %d&amp;quot;, port)&#xA;        }&#xA;    }()&#xA;}&#xA;  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl &#39;http://127.0.0.1:6060/debug/pprof/profile&#39; -o profile.20240223&#xA;curl &#39;http://127.0.0.1:6060/debug/pprof/heap&#39; -o heap.20240223&#xA;curl &#39;http://127.0.0.1:6060/debug/pprof/block&#39; -o block.20240223&#xA;curl &#39;http://127.0.0.1:6060/debug/pprof/mutex&#39; -o mutex.20240223&#xA;curl &#39;http://127.0.0.1:6060/debug/pprof/trace&#39; -o trace.20240223&#xA;  &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;输出对应的pprof文件之后, 对文件进行分析;&lt;/p&gt;</description>
    </item>
    <item>
      <title>B&#43;树</title>
      <link>https://qiref.github.io/post/2023/12/05/b-%E6%A0%91/</link>
      <pubDate>Tue, 05 Dec 2023 11:03:22 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/12/05/b-%E6%A0%91/</guid>
      <description>&lt;h2 id=&#34;b树引入&#34;&gt;B树引入&lt;/h2&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;B树（英语：B-tree），是一种在计算机科学自平衡的树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。B树，概括来说是一个一般化的二叉搜索树（binary search tree）一个节点可以拥有2个以上的子节点。与自平衡二叉查找树不同，B树适用于读写相对大的数据块的存储系统，例如磁盘。B树减少定位记录时所经历的中间过程，从而加快访问速度。B树这种数据结构可以用来描述外部存储。这种数据结构常被应用在数据库和文件系统的实现上。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;p&gt;&lt;code&gt;wiki&lt;/code&gt; 上是这么描述 B 树的, 重点在于 B 树被用作存储系统的实现上, 基于二叉搜索树天然的有序性, 实现 logn 级别的查询; 既然是用作存储系统的实现, 那么可以来推导一下, 为什么B 树会用作存储系统的实现?&lt;/p&gt;&#xA;&lt;p&gt;想要实现 logn 级别的查询, &lt;code&gt;binary search tree&lt;/code&gt; &lt;code&gt;skiip list&lt;/code&gt; 都可以实现, Why B 树?&lt;/p&gt;&#xA;&lt;h3 id=&#34;二叉搜索树&#34;&gt;二叉搜索树&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/b-tree-1.svg&#34; alt=&#34;b+-tree-1&#34;&gt; &lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;&#xA;&lt;p&gt;二叉搜索树天然有序, 也能达到 logn 级别的查询性能, 但是二叉搜索树, 有个很严重的问题, 如果插入的数据本身是有序的, 那二叉搜索树就会退化为链表, 要解决这个问题, 可以用 &lt;code&gt;AVL Tree (Balanced binary search tree)&lt;/code&gt; 和 &lt;code&gt;Red-Black Tree&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h3 id=&#34;avl-树&#34;&gt;AVL 树&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;AVL Tree (Balanced binary search tree)&lt;/code&gt; 在二叉搜索树的基础上, 增加了自平衡的机制, 解决二叉搜索树退化为链表的问题, 但是自平衡也会带来新的问题(平衡条件必须满足所有节点的左右子树高度差不超过1), 插入时可能会触发多次的自平衡, 从而会影响数据插入的效率, 那有没有办法解决频繁的自平衡的问题呢?&lt;/p&gt;&#xA;&lt;h3 id=&#34;红黑树&#34;&gt;红黑树&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;Red-Black Tree&lt;/code&gt; 就能做到, 红黑树通过制定一系列的规则:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Log Structured Merge Tree</title>
      <link>https://qiref.github.io/post/2023/10/13/log-structured-merge-tree/</link>
      <pubDate>Fri, 13 Oct 2023 11:46:21 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/10/13/log-structured-merge-tree/</guid>
      <description>&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;Log Structured Merge Tree&lt;/code&gt;, 其本质上是一种存储数据的方式,通常用于各种存储系统的底层数据结构,通过尽可能减少磁盘随机IO来提升写入性能, 适用于写多读少的场景.&lt;/p&gt;&#xA;&lt;h3 id=&#34;随机写和顺序写&#34;&gt;随机写和顺序写&lt;/h3&gt;&#xA;&lt;p&gt;对于一个存储系统而言, 不可避免地需要写入文件到磁盘, 对于常规的写来说, 每来一条数据写一次文件, 数据可能是 &lt;code&gt;add update delete&lt;/code&gt;, 需要频繁操作文件, 每一次写都是一次随机 IO; 为了提高写入速度, &lt;code&gt;LSM Tree&lt;/code&gt; 并不是每一次写操作都把文件写到磁盘, 而是将数据在内存中更新，当内存中的数据达到一定的阈值时，才将这部分数据真正刷新到磁盘文件中. 以这种方式尽可能让每次磁盘 IO 都是顺序写;&lt;/p&gt;&#xA;&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;&#xA;&lt;p&gt;基于减少磁盘的随机 IO 来提升整体存储系统的写入性能这一背景, 很自然可以推导出用批量写入的方式, 要想批量写入, 就需要在内存维护最近写入的数据, 达到阈值之后生成一个文件写入到磁盘, 但是这样又会存在新的问题:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果某一条数据已经写入到磁盘文件, 后续又有更新, 怎么处理呢?&lt;/li&gt;&#xA;&lt;li&gt;内存中维护的临时数据, 如果还未来得及写入磁盘, 服务挂了, 重新启动时, 历史写入的数据如何恢复?&lt;/li&gt;&#xA;&lt;li&gt;每次内存中数据达到阈值,写一个整个文件到磁盘,那么最终会生成大量的文件, 如何解决?&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;解决问题1, 为了优化这种更新的写入, 可以采用数据版本的做法, 或者给数据增加标志, 然后定期合并, 当然, 这也是以空间换时间, 相同的数据存储了多次, 以提升写入性能; 与此同时, 在数据读取时,由于写入的逻辑改变, 一条数据可能会存在于多个文件中, 因此在读取时, 需要返回最新的数据, 在读取到多条数据时,需要对多条数据进行合取最新;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;解决问题2, 在业界比较标准的做法是 &lt;code&gt;WAL&lt;/code&gt;, &lt;code&gt;WAL&lt;/code&gt; 的基本原理是在执行数据修改操作之前，先将这些操作记录在日志（log）文件中, 以确保在发生故障或崩溃时，可以借助日志进行恢复并保持数据的一致性;&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;解决问题3, 为了避免大量文件, 可以对文件进行定期合并, 当数据还在内存中时, 可以借助跳表或者 &lt;code&gt;B+Tree&lt;/code&gt; 等数据结构保证内存中数据的顺序性, 在写文件时, 由于数据是有序的, 在文件合并时,很自然可以借助归并排序保证合并之后的数据的有序性, 而有序性又能天然提高查询效率.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Skip Lists 阅读笔记</title>
      <link>https://qiref.github.io/post/2023/10/01/skip-lists-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 01 Oct 2023 22:05:38 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/10/01/skip-lists-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;算法介绍&#34;&gt;算法介绍&lt;/h2&gt;&#xA;&lt;p&gt;《Skip Lists: A Probabilistic Alternative to Balanced Trees》 论文标题翻译就是 跳表: 平衡树的概率性替代方案; 跳表是一种可以用来代替平衡树的数据结构。跳表使用概率平衡而不是严格强制的平衡，因此跳跃列表中的插入和删除算法比平衡树的等效算法要简单得多并且速度明显更快。&lt;/p&gt;&#xA;&lt;p&gt;从论文的标题和介绍, 基本上就能知道跳表是一种怎么样的数据结构, 为了解决平衡树实现的复杂性, 提供一种概率性平衡的数据结构,作为平衡树的平替数据结构, 查询和插入时间复杂度是 &lt;code&gt;O(log n)&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;h2 id=&#34;算法流程&#34;&gt;算法流程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本原理&#34;&gt;基本原理&lt;/h3&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/skiplist-1.svg&#34; alt=&#34;skiplist-1&#34;&gt;&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;节点结构：跳表由多个层级组成，每个层级都是一个有序链表。每个节点包含一个值和多个指向下一层级节点的指针。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;层级索引：跳表的最底层是一个普通的有序链表，每个节点都连接到下一个节点。而在更高的层级，节点以一定的概率连接到更远的节点，形成了一种“跳跃”的效果。这些连接被称为“跳跃指针”，它们允许我们在查找时可以快速地跳过一些节点。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;查找操作：从跳表的顶层开始，我们沿着每个层级向右移动，直到找到目标值或找到一个大于目标值的节点。然后我们进入下一层级继续查找，直到最底层。这种方式可以在平均情况下实现快速的查找，时间复杂度为 O(log n)。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;插入和删除操作：在插入新节点时，我们首先执行查找操作，找到合适的插入位置。然后我们在每个层级上插入新节点，并根据一定的概率决定是否要为该节点添加跳跃指针。删除操作类似，我们首先找到要删除的节点，然后将其从每个层级中移除。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;查询&#34;&gt;查询&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;level&lt;/code&gt; 表示跳表的层级, 而 &lt;code&gt;forward[i]&lt;/code&gt; 是每一个层级的链表.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;Search(list, searchKey)&#xA;    x := list→header&#xA;    // 从跳表的顶层开始,遍历到第一层&#xA;    for i := list→level downto 1 do&#xA;        while x→forward[i]→key &amp;lt; searchKey do&#xA;            x := x→forward[i]&#xA;    // x→key &amp;lt; searchKey ≤ x→forward[1]→key&#xA;    // 最终的结果从跳表最底层获取&#xA;    x := x→forward[1]&#xA;    if x→key = searchKey then &#xA;        return x→value&#xA;    else &#xA;        return failure&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;写入&#34;&gt;写入&lt;/h3&gt;&#xA;&lt;p&gt;由跳表的定义得出, 跳表的上一层级相当于下一层级的索引, 如果需要构建多级的索引, 首先需要解决: &lt;em&gt;当前node是否应该索引到上一层级?&lt;/em&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>DBLog 阅读笔记</title>
      <link>https://qiref.github.io/post/2023/08/09/dblog-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Wed, 09 Aug 2023 10:39:17 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/08/09/dblog-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;&#xA;&lt;p&gt;论文原名: &lt;code&gt;DBLog: A Watermark Based Change-Data-Capture Framework&lt;/code&gt; , 基于 &lt;code&gt;Watermark&lt;/code&gt; 的 &lt;code&gt;Change-Data-Capture&lt;/code&gt;(数据库实时捕获已提交的变更记录) 框架, 本质上是解决数据库同步(全量+增量)的框架, &lt;code&gt;Watermark&lt;/code&gt; 是框架使用的一种手段, 在源表中创建表,生成唯一 uuid 并更新表数据, 在源表中就会生成一条变更记录,记作 &lt;code&gt;Watermark&lt;/code&gt; 的变更记录, 通过 &lt;code&gt;High Watermark&lt;/code&gt; 和 &lt;code&gt;Low Watermark &lt;/code&gt; 将变更记录分割, 保证 select chunk 数据包含了增量的变更记录.&lt;/p&gt;&#xA;&lt;p&gt;框架整体架构如下:&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/DBLog-1.svg&#34; alt=&#34;DBLog-1&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;框架特点:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;按顺序处理捕获到的 &lt;code&gt;changelog&lt;/code&gt;;&lt;/li&gt;&#xA;&lt;li&gt;转储可以随时进行，跨所有表，针对一个特定的表或者针对一个表的具体主键;&lt;/li&gt;&#xA;&lt;li&gt;以块(chunk)的形式获取转储，日志与转储事件交错。通过这种方式，&lt;code&gt;changelog&lt;/code&gt; 可以与转储处理一起进行。如果进程终止，它可以在最后一个完成的块之后恢复，而不需要从头开始。这还允许在需要时对转储进行调整和暂停;&lt;/li&gt;&#xA;&lt;li&gt;不会获取表级锁，这可以防止影响源数据库上的写流量;&lt;/li&gt;&#xA;&lt;li&gt;支持任何类型的输出，因此，输出可以是流、数据存储甚或是 API;&lt;/li&gt;&#xA;&lt;li&gt;设计充分考虑了高可用性。因此，下游的消费者可以放心，只要源端发生变化，它们就可以收到变化事件。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;注意, 本文并非详细介绍 &lt;code&gt;DBLog&lt;/code&gt; 框架本身, 而是分析其框架背后的设计思路.&lt;/p&gt;&#xA;&lt;h2 id=&#34;算法流程&#34;&gt;算法流程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;chunk-划分&#34;&gt;chunk 划分&lt;/h3&gt;&#xA;&lt;p&gt;对于源表数据, 全量数据使用分块读取, 基于 &lt;code&gt;primary key&lt;/code&gt; 顺序排序, 将全量数据划分为 N 个 chunk;&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/DBLog-2.svg&#34; alt=&#34;DBLog-2&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;watermark&#34;&gt;watermark&lt;/h3&gt;&#xA;&lt;p&gt;基于 chunk 划分, 然后 chunk 数据全量写入下游之后, 再将源表的变更记录 &lt;code&gt;changelog&lt;/code&gt; 增量同步到下游, 整体思路就是这样, 但是划分 chunk 有个问题需要解决, 就是先同步到下游的数据不一定的最终的数据, 例如上图 chunk1 中的数据在同步到下游之后可能会删除, 那chunk1 的数据写到下游之后, 下游就会出现脏数据; 如何解决 chunk 和 &lt;code&gt;changelog&lt;/code&gt; 之间不会相互覆盖的问题?&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java进程分析工具</title>
      <link>https://qiref.github.io/post/2023/06/26/java%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Mon, 26 Jun 2023 21:55:00 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/06/26/java%E8%BF%9B%E7%A8%8B%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;h2 id=&#34;jvm-内存区域&#34;&gt;JVM 内存区域&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/jvm-area.svg&#34; alt=&#34;jvm-area&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如果要为&lt;code&gt;新生代&lt;/code&gt;分配 &lt;code&gt;256m&lt;/code&gt; 的内存（&lt;code&gt;NewSize&lt;/code&gt; 与 &lt;code&gt;MaxNewSize&lt;/code&gt; 设为一致），参数应该这样来写：&lt;code&gt;-Xmn256m&lt;/code&gt;;&lt;/p&gt;&#xA;&lt;p&gt;还可以通过 &lt;code&gt;-XX:NewRatio=&amp;lt;int&amp;gt;&lt;/code&gt; 来设置&lt;code&gt;老年代&lt;/code&gt;与&lt;code&gt;新生代&lt;/code&gt;内存的比值。比如以下参数就是设置老年代与新生代内存的比值为 1。也就是说老年代和新生代所占比值为 1：1，新生代占整个堆栈的 1/2。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;-XX:NewRatio=1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;JDK 1.8 ，方法区（HotSpot 的永久代）被彻底移除了，取而代之是元空间 Metaspace，元空间使用的是本地内存。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Metaspace 的初始容量并不是 &lt;code&gt;-XX:MetaspaceSize&lt;/code&gt; 设置，无论 &lt;code&gt;-XX:MetaspaceSize&lt;/code&gt; 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）。可以参考 Oracle 官方文档 :&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Specify a higher value for the option MetaspaceSize to avoid early garbage collections induced for class metadata. The amount of class metadata allocated for an application is application-dependent and general guidelines do not exist for the selection of MetaspaceSize. The default size of MetaspaceSize is platform-dependent and ranges from 12 MB to about 20 MB.&lt;/p&gt;</description>
    </item>
    <item>
      <title>The Dataflow Model 阅读笔记</title>
      <link>https://qiref.github.io/post/2023/05/16/the-dataflow-model-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Tue, 16 May 2023 15:26:10 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/05/16/the-dataflow-model-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;dataflow-计算模型&#34;&gt;Dataflow 计算模型&lt;/h2&gt;&#xA;&lt;p&gt;Dataflow 的核心计算模型非常简单，它只有两个概念，一个叫做 ParDo，就是并行处理的意思；另一个叫做 GroupByKey，也就是按照 Key 进行分组。&lt;/p&gt;&#xA;&lt;h3 id=&#34;pardo&#34;&gt;ParDo&lt;/h3&gt;&#xA;&lt;p&gt;ParDo 用来进行通用的并行化处理。每个输入元素（这个元素本身有可能是一个有限的集合）都会使用一个 UDF 进行处理（在Dataflow中叫做DoFn），输出是0或多个输出元素。这个例子是把键的前缀进行展开，然后把值复制到展开后的键构成新的键值对并输出。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/dataflow-pardo.svg&#34; alt=&#34;dataflow-pardo&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;groupbykey&#34;&gt;GroupByKey&lt;/h3&gt;&#xA;&lt;p&gt;GroupByKey 用来按 Key 把元素重新分组。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/dataflow-group-by-key.svg&#34; alt=&#34;dataflow-group-by-key&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;ParDo 操作因为是对每个输入的元素进行处理，因此很自然地就可以适用于无边界的数据。而 GroupByKey 操作，在把数据发送到下游进行汇总前，需要收集到指定的键对应的所有数据。如果输入源是无边界的，那么我们不知道何时才能收集到所有的数据。所以通常的解决方案是对数据使用窗口操作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;窗口&#34;&gt;窗口&lt;/h2&gt;&#xA;&lt;h3 id=&#34;时间语义&#34;&gt;时间语义&lt;/h3&gt;&#xA;&lt;p&gt;窗口通常基于时间，时间对于窗口来说是必不可少的，在流式计算中，有 processing-time 和 event-time 两种时间语义，具体参考： &lt;a href=&#34;https://archieyao.github.io/posts/2022-02-25-flink-%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89/&#34;&gt;时间语义&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;窗口分类&#34;&gt;窗口分类&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;固定窗口（Fixed Window）固定区间（互不重叠）的窗口，可以基于时间，也可以基于数量；将事件分配到不同区间的窗口中，在通过窗口边界后，窗口内的所有事件会发送给计算函数进行计算；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;滑动窗口（Sliding Window）固定区间但可以重叠的窗口，需要指定窗口区间以及滑动步长，区间重叠意味着同一个事件会分配到不同窗口参与计算。 窗口区间决定何时触发计算，滑动步长决定何时创建一个新的窗口；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;会话窗口（Session Window）会话窗口通常基于用户的会话，通过定义会话的超时时间，将事件分割到不同的会话中； 例如，有个客服聊天系统，如果用户超过 30 分钟没有互动，则认为一次会话结束，当客户下次进入，就是一个新的会话了。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;窗口分配与合并&#34;&gt;窗口分配与合并&lt;/h3&gt;&#xA;&lt;p&gt;Dataflow 模型里，需要的不只是 GroupByKey，实际在统计数据的时候，往往需要的是 GroupByKeyAndWindow。统计一个不考虑任何时间窗口的数据，往往是没有意义的；&#xA;Dataflow 模型提出：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;从模型简化的角度上，把所有的窗口策略都当做非对齐窗口，而底层实现来负责把对齐窗口作为一个特例进行优化。&lt;/li&gt;&#xA;&lt;li&gt;窗口操作可以被分隔为两个互相相关的操作：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;set&amp;lt;Window&amp;gt; AssignWindows(T datum)&lt;/code&gt; 即窗口分配操作。这个操作把元素分配到 0 或多个窗口中去。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;set&amp;lt;window&amp;gt; MergeWindows(Set&amp;lt;Window&amp;gt; windows)&lt;/code&gt; 即窗口合并操作，这个操作在汇总时合并窗口。&#xA;而在实际的逻辑实现层面，Dataflow 最重要的两个函数，也就是 AssignWindows 函数和 MergeWindows 函数。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;窗口分配&#34;&gt;窗口分配&lt;/h4&gt;&#xA;&lt;p&gt;每一个原始的事件，在业务处理函数之前，其实都是（key, value, event_time）这样一个三元组。而 AssignWindows 要做的，就是把这个三元组，根据我们的处理逻辑，变成（key, value, event_time, window）这样的四元组。&lt;/p&gt;</description>
    </item>
    <item>
      <title>堆和堆排序</title>
      <link>https://qiref.github.io/post/2023/05/12/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Fri, 12 May 2023 17:01:04 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/05/12/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>&lt;h2 id=&#34;堆&#34;&gt;堆&lt;/h2&gt;&#xA;&lt;p&gt;堆的本质是树，用数组表示的完全二叉树；&lt;/p&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;&#xA;&lt;p&gt;一棵深度为k且有 &lt;code&gt;2^k - 1&lt;/code&gt; 个结点的二叉树称为满二叉树。&lt;/p&gt;&#xA;&lt;p&gt;根据二叉树的性质2, 满二叉树每一层的结点个数都达到了最大值, 即满二叉树的第i层上有 &lt;code&gt;2^(i-1)&lt;/code&gt; 个结点 (i≥1) 。&lt;/p&gt;&#xA;&lt;p&gt;如果对满二叉树的结点进行编号, 约定编号从根结点起, 自上而下, 自左而右。则深度为k的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时, 称之为完全二叉树。&lt;/p&gt;&#xA;&lt;p&gt;从满二叉树和完全二叉树的定义可以看出, 满二叉树是完全二叉树的特殊形态, 即如果一棵二叉树是满二叉树, 则它必定是完全二叉树。&lt;/p&gt;&#xA;&lt;p&gt;参考： &lt;a href=&#34;https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232&#34;&gt;https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;性质&#34;&gt;性质&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;arr：[2 3 4 52 2 2 1]&#xA;idx： 0 1 2 3  4 5 6&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;i 下标和元素之间的映射关系：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;左子节点：&lt;code&gt;2*i+1&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;右子节点：&lt;code&gt;2*i+2&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;父节点：&lt;code&gt;(i-1)/2&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;大根堆&#34;&gt;大根堆&lt;/h3&gt;&#xA;&lt;p&gt;完全二叉树里，每一个子树的最大值是根节点；&lt;/p&gt;&#xA;&lt;h3 id=&#34;小根堆&#34;&gt;小根堆&lt;/h3&gt;&#xA;&lt;p&gt;完全二叉树里，每一个子树的最小值是根节点；&lt;/p&gt;&#xA;&lt;h2 id=&#34;堆排序&#34;&gt;堆排序&lt;/h2&gt;&#xA;&lt;h3 id=&#34;定义堆&#34;&gt;定义堆&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// maxHeap 定义一个大根堆&#xA;type maxHeap struct {&#xA;    Data  []int&#xA;    Count int&#xA;}&#xA;&#xA;func NewMaxHeap(size int) *maxHeap {&#xA;    return &amp;amp;maxHeap{&#xA;        Data:  make([]int, size),&#xA;        Count: 0,&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;插入数据&#34;&gt;插入数据&lt;/h3&gt;&#xA;&lt;p&gt;插入数据时，是往数组最后增加元素，由于需要保证大根堆的性质，如果新加入的元素比父节点大，则跟父节点交换位置，以此类推，一直到根节点，这个交换流程完成后，新元素插入就完成了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Chandy-Lamport 算法笔记</title>
      <link>https://qiref.github.io/post/2023/05/08/chandy-lamport-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 08 May 2023 22:38:42 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/05/08/chandy-lamport-%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;Global Snapshot（Global State）：全局快照，分布式系统在 Failure Recovery 的时候非常有用，也是广泛应用在分布式系统，更多是分布式计算系统中的一种容错处理理论基础。&lt;/p&gt;&#xA;&lt;p&gt;在 Chandy-Lamport 算法中，为了定义分布式系统的 Global Snapshot，先将分布式系统简化成有限个进程和进程之间的 channel 组成，也就是一个有向图 （GAG）：节点是进程，边是 channel。因为是分布式系统，也就是说，这些进程是运行在不同的物理机器上的。那么一个分布式系统的  Global Snapshot 就是有进程的状态和 channel 中的 message 组成，这个也是分布式快照算法需要记录的。因此，Chandy-Lamport 算法解决了分布式系统在 Failure Recovery 时，可以从  Global Snapshot 中恢复的问题；&lt;/p&gt;&#xA;&lt;h2 id=&#34;算法过程&#34;&gt;算法过程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;前提条件及定义&#34;&gt;前提条件及定义&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;process（Pn）：分布式系统中的进程，用 P1，P2，P3 表示；&lt;/li&gt;&#xA;&lt;li&gt;channel：分布式系统中，Pn 与 Pm 通信的管道，C12 表示从 P1 到 P2 的 channel，反之，C32 表示从 P3 到 P2的 channel；&lt;/li&gt;&#xA;&lt;li&gt;message：分布式系统中，Pn 与 Pm 之间发送的业务消息；M23 表示从 P2 到 P3 的 message；&lt;/li&gt;&#xA;&lt;li&gt;marker：在 Chandy-Lamport 算法中，Pn 与 Pm 之间发送的标记消息，不同于业务的 message，marker 是由 Chandy-Lamport 算法定义，用于帮助实现快照算法；&lt;/li&gt;&#xA;&lt;li&gt;snapshot/state：都表示快照，同时包括进程本身的状态和 message；下文中统一全局快照叫 snapshot，process 本地快照叫 state；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Chandy-Lamport 算法有一些前提条件：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言生产者消费者模型</title>
      <link>https://qiref.github.io/post/2023/04/28/go%E8%AF%AD%E8%A8%80%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Fri, 28 Apr 2023 15:57:51 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/04/28/go%E8%AF%AD%E8%A8%80%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;&#xA;type Request struct {&#xA;    Name string&#xA;}&#xA;&#xA;type XxHandler struct {&#xA;    RequestQueue chan *Request&#xA;}&#xA;&#xA;func (o *XxHandler) String() string {&#xA;    if b, err := json.Marshal(o); err != nil {&#xA;        return &amp;quot;&amp;quot;&#xA;    } else {&#xA;        return string(b)&#xA;    }&#xA;}&#xA;&#xA;// Start 启动队列监听&#xA;func (o *XxHandler) Start() {&#xA;    go func() {&#xA;        for request := range o.RequestQueue {&#xA;            go o.Process(request)&#xA;        }&#xA;    }()&#xA;}&#xA;&#xA;// AppendTask 向队列中增加task&#xA;func (o *XxHandler) AppendTask(request *Request) {&#xA;    if request == nil {&#xA;        return&#xA;    }&#xA;    o.RequestQueue &amp;lt;- request&#xA;}&#xA;&#xA;// Stop 关闭队列&#xA;func (o *XxHandler) Stop() {&#xA;    close(o.RequestQueue)&#xA;}&#xA;&#xA;func newIns() *XxHandler {&#xA;    return &amp;amp;XxHandler{&#xA;        RequestQueue: make(chan *Request, 10),&#xA;    }&#xA;}&#xA;&#xA;var ins *XxHandler&#xA;&#xA;// GetXxHandler 获取 实例&#xA;func GetXxHandler() *XxHandler {&#xA;    if ins == nil {&#xA;        ins = newIns()&#xA;    }&#xA;    return ins&#xA;}&#xA;&#xA;// Process 处理队列中的任务&#xA;func (o *XxHandler) Process(request *Request) {&#xA;    // do something&#xA;}&#xA;&#xA;func TestXxHandler(t *testing.T) {&#xA;    GetXxHandler().Start()&#xA;&#xA;    GetXxHandler().AppendTask(&amp;amp;Request{Name: &amp;quot;xx&amp;quot;})&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>Go语言实现 bitmap</title>
      <link>https://qiref.github.io/post/2023/04/28/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-bitmap/</link>
      <pubDate>Fri, 28 Apr 2023 11:24:38 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/04/28/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-bitmap/</guid>
      <description>&lt;h2 id=&#34;算法说明&#34;&gt;算法说明&lt;/h2&gt;&#xA;&lt;p&gt;Bitmap算法是一种基于位运算的数据结构，用于解决大规模数据的快速查找和统计问题。其基本原理是将一个大数据集合映射到一个二进制向量中，其中每个元素对应于数据集合中的一个元素，向量中的每一位表示该元素是否存在于集合中。&lt;/p&gt;&#xA;&lt;p&gt;具体来说，Bitmap算法通过使用一个位图（bitmap）来表示一个数据集合，其中每个元素对应一个位。如果某个元素在数据集合中出现，则将其对应的位设置为1，否则将其对应的位设置为0。通过这种方式，可以快速地进行集合操作，如并集、交集和差集等。&lt;/p&gt;&#xA;&lt;p&gt;Bitmap算法的主要优点在于其空间效率高，可以用较小的空间存储大规模数据集合。另外，Bitmap算法的时间复杂度也非常低，可以快速地进行集合操作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;如何用数组表示一个-bitmap&#34;&gt;如何用数组表示一个 bitmap&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/bitmap-index-cal.svg&#34; alt=&#34;bitmap-index-cal&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;以 1byte 为例：8位能表示8个元素， 0-7 号对应了 b[0] 下标， 8-15 号对应了 b[1] 下标，以此类推。&lt;/p&gt;&#xA;&lt;p&gt;因此，数组下标 n 跟bitmap元素序号 bitmapIdx 的关系为：&lt;code&gt;n = bitmapIdx &amp;gt;&amp;gt; 3&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;值如何映射到-bitmap-数组&#34;&gt;值如何映射到 bitmap 数组&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/bitmap-index-map.svg&#34; alt=&#34;bitmap-index-cal&#34;&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;当找到了 元素序号 n 在数组中的下标之后，如何给 b[n] 赋值呢？&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;1 &amp;lt;&amp;lt; (bitmapIdx &amp;amp; 7)&lt;/code&gt; 等同于 &lt;code&gt;1 &amp;lt;&amp;lt; (bitmapIdx % 8)&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;(bitmapIdx % 8)&lt;/code&gt; 找到在了在数组 b[n] 中的第 &lt;code&gt;m&lt;/code&gt; 位，然后 &lt;code&gt;1 &amp;lt;&amp;lt; m&lt;/code&gt; 之后，就相当于给数组赋值，把第 &lt;code&gt;m&lt;/code&gt; 位 置为1。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;&#xA;&lt;p&gt;同样以 1byte 为例：借用上述结论，第 24 号元素，对应的数组下标 n 为：&lt;code&gt;n = 24 &amp;gt;&amp;gt; 3 &lt;/code&gt; 结果为3, b[3]；&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言实现 LRU</title>
      <link>https://qiref.github.io/post/2023/04/27/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-lru/</link>
      <pubDate>Thu, 27 Apr 2023 21:43:12 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/04/27/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0-lru/</guid>
      <description>&lt;p&gt;LRU（Least Recently Used）算法，即最近最少使用算法;其基本思想是，如果一个数据最近被访问过，那么它在未来被访问的概率也会很高；反之，如果一个数据很久都没有被访问过，那么它在未来被访问的概率就相对较低。因此，LRU算法选择淘汰最近最少使用的数据，即选择最长时间没有被访问过的数据进行淘汰。&lt;/p&gt;&#xA;&lt;p&gt;具体来说，LRU算法通常使用一个双向链表和一个哈希表来实现。双向链表中的节点按照最近访问时间的顺序排列，最近访问的节点排在链表头部，最久未访问的节点排在链表尾部。哈希表中存储每个节点的地址，以便快速查找和删除。&lt;/p&gt;&#xA;&lt;p&gt;当需要访问一个数据时，LRU算法首先在哈希表中查找该数据，如果存在，则将对应的节点移动到链表头部；如果不存在，则将该数据添加到链表头部，并在哈希表中创建对应的节点。&lt;/p&gt;&#xA;&lt;p&gt;当需要淘汰数据时，LRU算法选择链表尾部的节点进行淘汰，并在哈希表中删除对应的节点。&lt;/p&gt;&#xA;&lt;p&gt;golang 实现 LRU 算法：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;package lru&#xA;&#xA;import (&#xA;    &amp;quot;container/list&amp;quot;&#xA;    &amp;quot;errors&amp;quot;&#xA;    &amp;quot;sync&amp;quot;&#xA;)&#xA;&#xA;// LRU implements a non-thread safe fixed size LRU cache&#xA;type LRU struct {&#xA;    size      int&#xA;    evictList *list.List&#xA;    items     map[interface{}]*list.Element&#xA;}&#xA;&#xA;// entry is used to hold a value in the evictList&#xA;type entry struct {&#xA;    key   interface{}&#xA;    value interface{}&#xA;}&#xA;&#xA;// NewLRU constructs an LRU of the given size&#xA;func NewLRU(size int) (*LRU, error) {&#xA;    if size &amp;lt;= 0 {&#xA;        return nil, errors.New(&amp;quot;must provide a positive size&amp;quot;)&#xA;    }&#xA;    c := &amp;amp;LRU{&#xA;        size:      size,&#xA;        evictList: list.New(),&#xA;        items:     make(map[interface{}]*list.Element),&#xA;    }&#xA;    return c, nil&#xA;}&#xA;&#xA;// Add adds a value to the cache.  Returns true if an eviction occured.&#xA;func (c *LRU) Add(key, value interface{}) bool {&#xA;    // Check for existing item&#xA;    if ent, ok := c.items[key]; ok {&#xA;        c.evictList.MoveToFront(ent)&#xA;        ent.Value.(*entry).value = value&#xA;        return false&#xA;    }&#xA;&#xA;    // Add new item&#xA;    ent := &amp;amp;entry{key, value}&#xA;    entry := c.evictList.PushFront(ent)&#xA;    c.items[key] = entry&#xA;&#xA;    evict := c.evictList.Len() &amp;gt; c.size&#xA;    // Verify size not exceeded&#xA;    if evict {&#xA;        c.removeOldest()&#xA;    }&#xA;    return evict&#xA;}&#xA;&#xA;// Get looks up a key&#39;s value from the cache.&#xA;func (c *LRU) Get(key interface{}) (value interface{}, ok bool) {&#xA;    if ent, ok := c.items[key]; ok {&#xA;        c.evictList.MoveToFront(ent)&#xA;        return ent.Value.(*entry).value, true&#xA;    }&#xA;    return&#xA;}&#xA;&#xA;// Remove removes the provided key from the cache, returning if the&#xA;// key was contained.&#xA;func (c *LRU) Remove(key interface{}) bool {&#xA;    if ent, ok := c.items[key]; ok {&#xA;        c.removeElement(ent)&#xA;        return true&#xA;    }&#xA;    return false&#xA;}&#xA;&#xA;// removeOldest removes the oldest item from the cache.&#xA;func (c *LRU) removeOldest() {&#xA;    ent := c.evictList.Back()&#xA;    if ent != nil {&#xA;        c.removeElement(ent)&#xA;    }&#xA;}&#xA;&#xA;// removeElement is used to remove a given list element from the cache&#xA;func (c *LRU) removeElement(e *list.Element) {&#xA;    c.evictList.Remove(e)&#xA;    kv := e.Value.(*entry)&#xA;    delete(c.items, kv.key)&#xA;    if c.onEvict != nil {&#xA;        c.onEvict(kv.key, kv.value)&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;需要注意的是这个 LRU 实现并不是线程安全的，如果需要线程安全，需要在外层方法加锁，同时，由于 golang 的 lock 并不是可重入的，需要注意避免死锁问题。 以下实现中基于 LRU 做了一次封装，实现了线程安全的内存级 LRU-Cache：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink内存模型</title>
      <link>https://qiref.github.io/post/2023/03/28/flink%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Tue, 28 Mar 2023 20:31:01 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/03/28/flink%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
      <description>&lt;h2 id=&#34;java-堆外内存&#34;&gt;Java 堆外内存&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import sun.nio.ch.DirectBuffer;&#xA;import java.nio.ByteBuffer;&#xA;import java.util.concurrent.TimeUnit;&#xA;&#xA;public class OutHeapMem {&#xA;    public static void main(String[] args) throws Exception {&#xA;        // 分配 1G 直接内存&#xA;        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1024 * 1024 * 1024);&#xA;        TimeUnit.SECONDS.sleep(30);&#xA;&#xA;        System.out.println(&amp;quot;clean start&amp;quot;);&#xA;        // 清除直接内存&#xA;        ((DirectBuffer) byteBuffer).cleaner().clean();&#xA;        System.out.println(&amp;quot;clean finished&amp;quot;);&#xA;&#xA;        TimeUnit.SECONDS.sleep(30);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;# 分配内存&#xA;Memory                                  used         total        max           usage&#xA;heap                                    21M          165M         3641M         0.59%&#xA;ps_eden_space                           3M           64M          1344M         0.29%&#xA;ps_survivor_space                       0K           10752K       10752K        0.00%&#xA;ps_old_gen                              17M          91M          2731M         0.64%&#xA;nonheap                                 28M          28M          -1            96.89%&#xA;code_cache                              5M           5M           240M          2.11%&#xA;metaspace                               20M          21M          -1            97.00%&#xA;compressed_class_space                  2M           2M           1024M         0.25%&#xA;+direct                                 1024M        1024M        -             100.00%&#xA;mapped                                  0K           0K           -             0.00% &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-diff&#34;&gt;# 释放内存&#xA;Memory                                  used         total        max           usage&#xA;heap                                    21M          165M         3641M         0.60%&#xA;ps_eden_space                           4M           64M          1344M         0.32%&#xA;ps_survivor_space                       0K           10752K       10752K        0.00%&#xA;ps_old_gen                              17M          91M          2731M         0.64%&#xA;nonheap                                 27M          28M          -1            96.79%&#xA;code_cache                              5M           5M           240M          2.09%&#xA;metaspace                               20M          21M          -1            97.03%&#xA;compressed_class_space                  2M           2M           1024M         0.25%&#xA;-direct                                 0K           0K           -             0.00%&#xA;mapped                                  0K           0K           -             0.00%&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;通过 arthas 分析，分配直接内存会在 direct 开辟内存空间，表明是在堆外分配的内存空间；虽然 byteBuffer 指向了 direct memory，但是这个对象引用还在 heap 中，当 byteBuffer 对象引用 被 GC 算法回收掉之后，byteBuffer 指向的内存空间也会被释放；&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink类加载机制</title>
      <link>https://qiref.github.io/post/2023/03/24/flink%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 24 Mar 2023 16:13:22 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/03/24/flink%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;h2 id=&#34;flink-类加载配置说明&#34;&gt;flink 类加载配置说明&lt;/h2&gt;&#xA;&lt;p&gt;Flink 作为基于 JVM 的框架，在 flink-conf.yaml 中提供了控制类加载策略的参数 classloader.resolve-order，可选项有 child-first（默认）和 parent-first。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;Key&lt;/th&gt;&#xA;          &lt;th&gt;Default&lt;/th&gt;&#xA;          &lt;th&gt;Type&lt;/th&gt;&#xA;          &lt;th&gt;Description&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;classloader.resolve-order&lt;/td&gt;&#xA;          &lt;td&gt;&amp;ldquo;child-first&amp;rdquo;&lt;/td&gt;&#xA;          &lt;td&gt;String&lt;/td&gt;&#xA;          &lt;td&gt;Defines the class resolution strategy when loading classes from user code, meaning whether to first check the user code jar (&amp;ldquo;child-first&amp;rdquo;) or the application classpath (&amp;ldquo;parent-first&amp;rdquo;). The default settings indicate to load classes first from the user code jar, which means that user code jars can include and load different dependencies than Flink uses (transitively).&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;classloader.parent-first-patterns.default&lt;/td&gt;&#xA;          &lt;td&gt;&amp;ldquo;java.&amp;rdquo;;&lt;br&gt;&amp;ldquo;scala.&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.flink.&amp;rdquo;;&lt;br&gt;&amp;ldquo;com.esotericsoftware.kryo&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.hadoop.&amp;rdquo;;&lt;br&gt;&amp;ldquo;javax.annotation.&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.xml&amp;rdquo;;&lt;br&gt;&amp;ldquo;javax.xml&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.xerces&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.w3c&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.rocksdb.&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.slf4j&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.log4j&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.logging&amp;rdquo;;&lt;br&gt;&amp;ldquo;org.apache.commons.logging&amp;rdquo;;&lt;br&gt;&amp;ldquo;ch.qos.logback&amp;rdquo;&lt;/td&gt;&#xA;          &lt;td&gt;List&lt;String&gt;&lt;/td&gt;&#xA;          &lt;td&gt;A (semicolon-separated) list of patterns that specifies which classes should always be resolved through the parent ClassLoader first. A pattern is a simple prefix that is checked against the fully qualified class name. This setting should generally not be modified. To add another pattern we recommend to use &amp;ldquo;classloader.parent-first-patterns.additional&amp;rdquo; instead.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;classloader.parent-first-patterns.additional&lt;/td&gt;&#xA;          &lt;td&gt;&lt;/td&gt;&#xA;          &lt;td&gt;List&lt;String&gt;&lt;/td&gt;&#xA;          &lt;td&gt;A (semicolon-separated) list of patterns that specifies which classes should always be resolved through the parent ClassLoader first. A pattern is a simple prefix that is checked against the fully qualified class name. These patterns are appended to &amp;ldquo;classloader.parent-first-patterns.default&amp;rdquo;.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;classloader.fail-on-metaspace-oom-error&lt;/td&gt;&#xA;          &lt;td&gt;true&lt;/td&gt;&#xA;          &lt;td&gt;Boolean&lt;/td&gt;&#xA;          &lt;td&gt;Fail Flink JVM processes if &amp;lsquo;OutOfMemoryError: Metaspace&amp;rsquo; is thrown while trying to load a user code class.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;classloader.check-leaked-classloader&lt;/td&gt;&#xA;          &lt;td&gt;true&lt;/td&gt;&#xA;          &lt;td&gt;Boolean&lt;/td&gt;&#xA;          &lt;td&gt;Fails attempts at loading classes if the user classloader of a job is used after it has terminated. This is usually caused by the classloader being leaked by lingering threads or misbehaving libraries, which may also result in the classloader being used by other jobs. This check should only be disabled if such a leak prevents further jobs from running.&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;parent-first-类加载策略&#34;&gt;parent-first 类加载策略&lt;/h2&gt;&#xA;&lt;p&gt;ParentFirstClassLoader 和 ChildFirstClassLoader 类的父类均为 FlinkUserCodeClassLoader 抽象类：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java双亲委派</title>
      <link>https://qiref.github.io/post/2023/03/24/java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</link>
      <pubDate>Fri, 24 Mar 2023 15:46:27 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/03/24/java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE/</guid>
      <description>&lt;h2 id=&#34;类加载器&#34;&gt;类加载器&lt;/h2&gt;&#xA;&lt;p&gt;Java语言系统中支持以下4种类加载器：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Bootstrap ClassLoader 启动类加载器，主要负责加载Java核心类库，%JRE_HOME%\lib下的rt.jar、resources.jar、charsets.jar和class等；&lt;/li&gt;&#xA;&lt;li&gt;Extension ClassLoader 标准扩展类加载器，主要负责加载目录%JRE_HOME%\lib\ext目录下的jar包和class文件；&lt;/li&gt;&#xA;&lt;li&gt;Application ClassLoader 应用类加载器，主要负责加载当前应用的classpath下的所有类；&lt;/li&gt;&#xA;&lt;li&gt;User ClassLoader 用户自定义类加载器，用户自定义的类加载器,可加载指定路径的class文件；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/java-class-loader.svg&#34; alt=&#34;java类加载器&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;双亲委派&#34;&gt;双亲委派&lt;/h2&gt;&#xA;&lt;p&gt;类加载器采用了双亲委派模式，其工作原理是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。&lt;/p&gt;&#xA;&lt;p&gt;双亲委派模式的好处是什么？&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层次关系可以避免类的重复加载，当父类加载器已经加载过一次时，没有必要子类再去加载一次。&lt;/li&gt;&#xA;&lt;li&gt;考虑到安全因素，Java 核心 Api 类不会被随意替换，核心类永远是被上层的类加载器加载。如果我们自己定义了一个 java.lang.String 类，它会优先委派给 BootStrapClassLoader 去加载，加载完了就直接返回了。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;如果我们定义了一个 java.lang.ExtString，能被加载吗？答案也是不能的，因为 java.lang 包是有权限控制的，自定义了这个包，会报一个错如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;java.lang.SecurityException: Prohibited package name: java.lang&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;源码分析&#34;&gt;源码分析&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;protected Class&amp;lt;?&amp;gt; loadClass(String name, boolean resolve)&#xA;        throws ClassNotFoundException&#xA;    {&#xA;        synchronized (getClassLoadingLock(name)) {&#xA;            // 首先，检查这个类是否已经被加载了，最终实现是一个 native 本地实现&#xA;            Class&amp;lt;?&amp;gt; c = findLoadedClass(name);&#xA;            // 如果还没有被加载，则开始加载&#xA;            if (c == null) {&#xA;                long t0 = System.nanoTime();&#xA;                try {&#xA;                    // 首先如果父加载器不为空，则使用父类加载器加载。Launcher 类里提到的 parent 就在这里使用的。&#xA;                    if (parent != null) {&#xA;                        c = parent.loadClass(name, false);&#xA;                    } else {&#xA;                        // 如果父加载器为空（比如 ExtClassLoader），就使用 BootStrapClassloader 来加载&#xA;                        c = findBootstrapClassOrNull(name);&#xA;                    }&#xA;                } catch (ClassNotFoundException e) {&#xA;                }&#xA;                &#xA;                // 如果还没有找到，则使用 findClass 类来加载。也就是说如果我们自定义类加载器，就重写这个方法&#xA;                if (c == null) {&#xA;                    long t1 = System.nanoTime();&#xA;                    c = findClass(name);&#xA;&#xA;                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);&#xA;                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);&#xA;                    sun.misc.PerfCounter.getFindClasses().increment();&#xA;                }&#xA;            }&#xA;            if (resolve) {&#xA;                resolveClass(c);&#xA;            }&#xA;            return c;&#xA;        }&#xA;    }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;如何主动破坏双亲委派机制&#34;&gt;如何主动破坏双亲委派机制&lt;/h2&gt;&#xA;&lt;p&gt;双亲委派过程都是在loadClass方法中实现的，那么&lt;strong&gt;想要破坏这种机制，那么就自定义一个类加载器，重写其中的loadClass方法，使其不进行双亲委派即可。&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言单例模式</title>
      <link>https://qiref.github.io/post/2023/03/24/go%E8%AF%AD%E8%A8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 24 Mar 2023 10:47:42 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/03/24/go%E8%AF%AD%E8%A8%80%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;错误示例&#34;&gt;错误示例&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type singleton struct {}&#xA;&#xA;var instance *singleton&#xA;&#xA;func GetInstance() *singleton {&#xA;    if instance == nil {&#xA;        instance = &amp;amp;singleton{}   // 不是并发安全的&#xA;    }&#xA;    return instance&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;不优雅示例&#34;&gt;不优雅示例&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func GetInstance() *singleton {&#xA;    mu.Lock()                    // 如果实例存在没有必要加锁&#xA;    defer mu.Unlock()&#xA;&#xA;    if instance == nil {&#xA;        instance = &amp;amp;singleton{}&#xA;    }&#xA;    return instance&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;加锁可以保证每次拿到相同实例，但是如果已经实例化，再调用函数，依然有锁存在，浪费性能，不够优雅；&lt;/p&gt;&#xA;&lt;h2 id=&#34;优雅示例&#34;&gt;优雅示例&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (&#xA;    &amp;quot;sync&amp;quot;&#xA;)&#xA;&#xA;type singleton struct {}&#xA;&#xA;var instance *singleton&#xA;var once sync.Once&#xA;&#xA;func GetInstance() *singleton {&#xA;    once.Do(func() {&#xA;        instance = &amp;amp;singleton{}&#xA;    })&#xA;    return instance&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;该实现利用&lt;code&gt;sync.Once&lt;/code&gt;类型去同步对&lt;code&gt;GetInstance()&lt;/code&gt;的访问，并确保我们的类型仅被初始化一次。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink反压</title>
      <link>https://qiref.github.io/post/2023/03/23/flink%E5%8F%8D%E5%8E%8B/</link>
      <pubDate>Thu, 23 Mar 2023 16:37:37 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/03/23/flink%E5%8F%8D%E5%8E%8B/</guid>
      <description>&lt;h2 id=&#34;什么是反压&#34;&gt;什么是反压&lt;/h2&gt;&#xA;&lt;p&gt;如果你看到一个 Task 发生 &lt;strong&gt;反压警告&lt;/strong&gt;（例如： &lt;code&gt;High&lt;/code&gt;），意味着它生产数据的速率比下游 Task 消费数据的速率要快。 在工作流中数据记录是从上游向下游流动的（例如：从 Source 到 Sink）。反压沿着相反的方向传播，沿着数据流向上游传播。&lt;/p&gt;&#xA;&lt;p&gt;以一个简单的 &lt;code&gt;Source -&amp;gt; Sink&lt;/code&gt; Job 为例。如果看到 &lt;code&gt;Source&lt;/code&gt; 发生了警告，意味着 &lt;code&gt;Sink&lt;/code&gt; 消费数据的速率比 &lt;code&gt;Source&lt;/code&gt; 生产数据的速率要慢。 &lt;code&gt;Sink&lt;/code&gt; 正在向上游的 &lt;code&gt;Source&lt;/code&gt; 算子产生反压。&lt;/p&gt;&#xA;&lt;p&gt;Task（SubTask）的每个并行实例都可以用三个一组的指标评价：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;backPressureTimeMsPerSecond&lt;/code&gt;，subtask 被反压的时间&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;idleTimeMsPerSecond&lt;/code&gt;，subtask 等待某类处理的时间&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;busyTimeMsPerSecond&lt;/code&gt;，subtask 实际工作时间 在任何时间点，这三个指标相加都约等于&lt;code&gt;1000ms&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;指标值说明：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;OK&lt;/strong&gt;: 0 &amp;lt;= 比例 &amp;lt;= 0.10&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;LOW&lt;/strong&gt;: 0.10 &amp;lt; 比例 &amp;lt;= 0.5&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HIGH&lt;/strong&gt;: 0.5 &amp;lt; 比例 &amp;lt;= 1&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;反压问题定位&#34;&gt;反压问题定位&lt;/h2&gt;&#xA;&lt;p&gt;可以看各个operator的metrics的指标，比如：buffers.outPoolUsage、buffers.inPoolUsage、buffers.inputFloatingBuffersUsage、buffers.inputExclusiveBuffersUsage；&lt;/p&gt;&#xA;&lt;p&gt;接收端共用一个LocalBufferPool，接收端每个Channel在初始化阶段都会分配固定数量的Buffer(Exclusive Buffer)。如果某一时刻接收端接受到的数量太多，Exclusive Buffer就会耗尽，此时就会向BufferPool申请剩余的Floating Buffer（除了Exclusive Buffer，其他的都是Floating Buffer,备用Buffer）；&lt;code&gt;inPoolUsage = floatingBuffersUsage + exclusiveBuffersUsage&lt;/code&gt;&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;若 inPoolUsage 低，而 outPoolUsage 低，则说明完全没有背压现象。&lt;/li&gt;&#xA;&lt;li&gt;若 inPoolUsage 低，而 outPoolUsage 高，则说明处于临时状态，可能是背压刚开始，也可能是刚结束，需要再观察。&lt;/li&gt;&#xA;&lt;li&gt;若 inPoolUsage 高，而 outPoolUsage 低，那么通常情况下这个算子就是背压的根源了。&lt;/li&gt;&#xA;&lt;li&gt;若 inPoolUsage 高，而 outPoolUsage 高，则说明这个算子是被其他下游算子反压而来的，并不是元凶。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在反压定位过程中，建议关闭 Operator Chaining 优化，这样所有的算子可以单独拆分出来，不会相互干扰：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Arthas火焰图使用</title>
      <link>https://qiref.github.io/post/2023/03/22/arthas%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Wed, 22 Mar 2023 21:29:21 +0800</pubDate>
      <guid>https://qiref.github.io/post/2023/03/22/arthas%E7%81%AB%E7%84%B0%E5%9B%BE%E4%BD%BF%E7%94%A8/</guid>
      <description>&lt;h2 id=&#34;arthas-火焰图相关命令&#34;&gt;arthas 火焰图相关命令&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;arthas&lt;/code&gt; 中 &lt;code&gt;profiler&lt;/code&gt; 命令支持生成应用热点的火焰图。本质上是通过不断的采样，然后把收集到的采样结果生成火焰图。&lt;/p&gt;&#xA;&lt;p&gt;启动arthas：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;java -jar arthas-boot.jar&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;开始收集火焰图：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[arthas@1]$ profiler start&#xA;Profiling started&#xA;[arthas@1]$ profiler status&#xA;Profiling is running for 6 seconds&#xA;[arthas@1]$ profiler status&#xA;Profiling is running for 27 seconds&#xA;[arthas@1]$ profiler getSamples &#xA;2&#xA;[arthas@1]$ profiler getSamples &#xA;4&#xA;[arthas@1]$ profiler stop --file /tmp/cpu-result-1.html&#xA;OK&#xA;profiler output file: /tmp/cpu-result-1.html&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;命令说明：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;profiler start&lt;/code&gt; 开启火焰图收集；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;profiler status&lt;/code&gt; 查看火焰图收集的状态，会显示当前已经采集多长时间；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;profiler getSamples&lt;/code&gt; 获取已采集的 sample 的数量，理论上，sample 越多，结果越准确；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;profiler stop  --file /tmp/cpu-result-1.html&lt;/code&gt; 停止当前火焰图收集，会输出到文件中去，生成的文件就是火焰图；&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;关键参数说明&#34;&gt;关键参数说明&lt;/h3&gt;&#xA;&lt;h4 id=&#34;event&#34;&gt;event&lt;/h4&gt;&#xA;&lt;p&gt;-e, &amp;ndash;event &lt;value&gt; 默认采集 CPU 信息，可设：cpu, alloc, lock, cache-misses etc&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink Append流、Retract流、Upsert流</title>
      <link>https://qiref.github.io/post/2022/03/13/flink-append%E6%B5%81retract%E6%B5%81upsert%E6%B5%81/</link>
      <pubDate>Sun, 13 Mar 2022 11:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/03/13/flink-append%E6%B5%81retract%E6%B5%81upsert%E6%B5%81/</guid>
      <description>&lt;p&gt;摘要： 介绍 Flink 中 Append流、Retract流、Upsert流的含义。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#append%E6%B5%81&#34;&gt;Append流&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#retract%E6%B5%81&#34;&gt;Retract流&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#upsert%E6%B5%81&#34;&gt;Upsert流&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;append流&#34;&gt;Append流&lt;/h2&gt;&#xA;&lt;p&gt;在 Append 流中，仅通过 &lt;code&gt;INSERT&lt;/code&gt; 操作修改的动态表，可以通过输出插入的行转换为流。&lt;/p&gt;&#xA;&lt;h2 id=&#34;retract流&#34;&gt;Retract流&lt;/h2&gt;&#xA;&lt;p&gt;retract 流包含两种类型的 message： add messages 和 retract messages 。&lt;/p&gt;&#xA;&lt;p&gt;通过将INSERT 操作编码为 add message、将 &lt;code&gt;DELETE&lt;/code&gt; 操作编码为 retract message、将 &lt;code&gt;UPDATE&lt;/code&gt; 操作编码为更新(先前)行的 retract message 和更新(新)行的 add message，将动态表转换为 retract 流。&lt;/p&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;OPERATOR&lt;/th&gt;&#xA;          &lt;th&gt;ENCODE&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;insert&lt;/td&gt;&#xA;          &lt;td&gt;add&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;update&lt;/td&gt;&#xA;          &lt;td&gt;retract -&amp;gt; add&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;delete&lt;/td&gt;&#xA;          &lt;td&gt;retract&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h2 id=&#34;upsert流&#34;&gt;Upsert流&lt;/h2&gt;&#xA;&lt;p&gt;upsert 流包含两种类型的 message： upsert messages 和delete messages。&lt;/p&gt;&#xA;&lt;p&gt;转换为 upsert 流的动态表需要(可能是组合的)唯一键。通过将 &lt;code&gt;INSERT&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 操作编码为 upsert message，将 &lt;code&gt;DELETE&lt;/code&gt; 操作编码为 delete message ，将具有唯一键的动态表转换为流。消费流的算子需要知道唯一键的属性，以便正确地应用 message。与 retract 流的主要区别在于 &lt;code&gt;UPDATE&lt;/code&gt; 操作是用单个 message 编码的，因此效率更高。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink Checkpoint机制</title>
      <link>https://qiref.github.io/post/2022/03/04/flink-checkpoint%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Fri, 04 Mar 2022 11:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/03/04/flink-checkpoint%E6%9C%BA%E5%88%B6/</guid>
      <description>&lt;p&gt;摘要： 如果把运行中的 Flink 程序比做一条河流，Checkpoint 就是一个相机，定期地对河流进行拍照，记录河水的状态。本文以自顶向下的视角，从理论到实现，分析 Flink 中的 Checkpoint 机制；&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80&#34;&gt;理论基础&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#asynchronous-barrier-snapshotting&#34;&gt;asynchronous barrier snapshotting&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%AE%97%E6%B3%95%E6%AD%A5%E9%AA%A4&#34;&gt;算法步骤&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%AE%97%E6%B3%95%E5%9C%A8-flink-%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0&#34;&gt;算法在 Flink 中的实现&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-checkpoint-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B&#34;&gt;Flink Checkpoint 整体流程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-checkpoint-barrier-alignment&#34;&gt;Flink Checkpoint Barrier Alignment&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-checkpoint-%E4%BD%BF%E7%94%A8&#34;&gt;Flink Checkpoint 使用&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-job-%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5&#34;&gt;Flink Job 重启策略&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-job-%E5%BC%80%E5%90%AF-checkpoint&#34;&gt;Flink Job 开启 Checkpoint&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;理论基础&#34;&gt;理论基础&lt;/h2&gt;&#xA;&lt;h3 id=&#34;asynchronous-barrier-snapshotting&#34;&gt;asynchronous barrier snapshotting&lt;/h3&gt;&#xA;&lt;p&gt;Flink Checkpoint 机制是异步屏障快照（asynchronous barrier snapshotting, ABS）算法的一种实现，而 ABS 算法基于 &lt;a href=&#34;https://archieyao.github.io/posts/2023-05-08-chandy-lamport%E7%AE%97%E6%B3%95/&#34;&gt;Chandy-Lamport&lt;/a&gt; 的变种，但数据模型是还是基于  Chandy-Lamport；&lt;/p&gt;&#xA;&lt;p&gt;在 flink 中，作业算子被抽象为 DAG，节点为 operator，边是每一个 operator 的 stream（channel），与 Chandy-Lamport 的数据模型正好吻合；&lt;/p&gt;&#xA;&lt;p&gt;ABS 算法把 Chandy-Lamport 中的 marker 消息换成了 barrier，作用是一致的，都是切分 snapshot；&lt;/p&gt;&#xA;&lt;p&gt;ABS 算法 中 asynchronous 是异步的意思，当算子收齐 barrier 并触发快照之后，不会等待快照数据全部写入状态后端，而是一边后台写入，一边立刻继续处理数据流，并将 barrier 发送到下游，实现了最小化延迟。当然，引入异步性之后，所有有状态的算子都需要上报 ack，否则 JobManager 就无法确认一次 snapshot 是否完成。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink时间语义</title>
      <link>https://qiref.github.io/post/2022/02/25/flink%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89/</link>
      <pubDate>Fri, 25 Feb 2022 11:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/02/25/flink%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89/</guid>
      <description>&lt;p&gt;摘要： 理解流处理中的时间语义，处理时间和事件时间。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/stream-time.png&#34; alt=&#34;stream-time&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;如图，在无界数据中，随着时间推移，数据一直产生，但真实情况中，往往在一段时间内的数据都是不均匀的，往往会出现意外的情况，比如在地铁无信号的情况下，数据虽然产生，但是会有一段时间延迟才会到达消息队列，例如虚线框中的数据。&lt;/p&gt;&#xA;&lt;h2 id=&#34;处理时间&#34;&gt;处理时间&lt;/h2&gt;&#xA;&lt;p&gt;处理时间就是流计算处理程序的机器本地时间，按照这种时间语义，在流计算的时间窗口中，上述例子中的数据会按这样分布：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/process-time.png&#34; alt=&#34;process-time&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;基于本地时间，在第一分钟，流处理程序只收到了 &lt;code&gt;15&lt;/code&gt;、&lt;code&gt;18&lt;/code&gt; 两个数据，后续数据由于网络原因，在 8:01:00 之后才到达流计算程序，所以后续数据在下一个时间窗口内。&lt;/p&gt;&#xA;&lt;h2 id=&#34;事件时间&#34;&gt;事件时间&lt;/h2&gt;&#xA;&lt;p&gt;事件时间就是事件的发生时间，这个时间通常会在数据中，按照这种时间语义，在流计算的时间窗口中，上述例子中的数据会按这样分布：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/event-time.png&#34; alt=&#34;event-time&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;基于事件时间，在第一分钟，数据应该是：&lt;code&gt;15&lt;/code&gt; &lt;code&gt;18&lt;/code&gt; &lt;code&gt;9&lt;/code&gt; &lt;code&gt;10&lt;/code&gt; ，在第二分钟，数据应该是：&lt;code&gt;11&lt;/code&gt; 。&lt;/p&gt;&#xA;&lt;h2 id=&#34;watermark&#34;&gt;watermark&lt;/h2&gt;&#xA;&lt;p&gt;由于事件时间的窗口和事件相关，那么如果下一个事件还未到达，流计算程序是否就无限等待呢？&lt;/p&gt;&#xA;&lt;p&gt;为了解决这个问题，flink 引入 watermark 的概念，假如定义 watermark 为 T，那么在每一个时间窗口中，T 都会单调递增 &lt;code&gt;T &amp;lt; T1&lt;/code&gt;，并且下一个时间窗口中的事件时间必须大于 &lt;code&gt;T1&lt;/code&gt;，那么每一个时间窗口的数据就是介于 &lt;code&gt;T-T1&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink基本架构</title>
      <link>https://qiref.github.io/post/2022/02/23/flink%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Wed, 23 Feb 2022 11:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/02/23/flink%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84/</guid>
      <description>&lt;p&gt;摘要： 鸟瞰 Flink 架构，分析 Flink 内部组件工作机制。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-%E6%9E%B6%E6%9E%84%E5%9B%BE&#34;&gt;Flink 架构图&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%8F%90%E4%BA%A4%E4%BD%9C%E4%B8%9A%E6%B5%81%E7%A8%8B&#34;&gt;提交作业流程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#flink-%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F&#34;&gt;Flink 集群模式&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#jobmanager&#34;&gt;JobManager&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#taskmanager&#34;&gt;Taskmanager&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%AE%97%E5%AD%90%E9%93%BE&#34;&gt;算子链&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#slot&#34;&gt;Slot&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#task-%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E7%AD%96%E7%95%A5&#34;&gt;task 数据交换策略&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;flink-架构图&#34;&gt;Flink 架构图&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/flink-struct.svg&#34; alt=&#34;Flink架构图&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;一个完整的 Flink 集群由一个 Jobmanager 和若干个 Taskmanager 组成，Jobmanager 主要负责调度 task 以及 协调 Checkpoint。Taskmanager 则负责具体的 task 执行，以及数据流的交换。&lt;/p&gt;&#xA;&lt;p&gt;可以通过多种方式启动 JobManager 和 TaskManager：直接在机器上作为standalone 集群启动、在容器中启动、或者通过YARN等资源框架管理并启动。TaskManager 连接到 JobManagers，宣布自己可用，并被分配工作。&lt;/p&gt;&#xA;&lt;h2 id=&#34;提交作业流程&#34;&gt;提交作业流程&lt;/h2&gt;&#xA;&lt;p&gt;以一个作业提交的流程来说明 Flink 各个组件是如何交互和工作的：&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/flink-struct-1.svg&#34; alt=&#34;提交作业流程&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;flink-集群模式&#34;&gt;Flink 集群模式&lt;/h2&gt;&#xA;&lt;p&gt;Flink 集群类型一般有以下几种：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Flink Session 集群&lt;/p&gt;&#xA;&lt;p&gt;这种模式下，集群自创建开始，最后到集群生命周期结束，不受作业因素影响； 集群下的多个作业共享 内存、网络、磁盘等资源，如果集群出现异常，该集群下的所有作业都会收到影响。&lt;/p&gt;&#xA;&lt;p&gt;优点：提交作业速度很快，无需提前申请资源； 并且资源利用率较高。&lt;/p&gt;&#xA;&lt;p&gt;缺点：作业之间隔离性较差，横向扩展不太方便。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;Flink job 集群&lt;/p&gt;&#xA;&lt;p&gt;这种模式也称 pre-job 模式，集群交由 资源管理器托管，例如 Yarn ，需要运行作业，第一步申请资源，启动一个 Flink 集群，第二步提交作业，这种模式下，每个作业会独享一个 Flink 集群。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Flink WordCount</title>
      <link>https://qiref.github.io/post/2022/02/22/flink-wordcount/</link>
      <pubDate>Tue, 22 Feb 2022 18:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/02/22/flink-wordcount/</guid>
      <description>&lt;p&gt;摘要：Flink 从零开始，下载集群并运行 WordCount Job。 完整代码地址： &lt;a href=&#34;https://github.com/ArchieYao/flink-learning/tree/main/hello-world&#34;&gt;https://github.com/ArchieYao/flink-learning/tree/main/hello-world&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;flink-本地模式集群安装&#34;&gt;Flink 本地模式集群安装&lt;/h2&gt;&#xA;&lt;p&gt;运行Flink，需提前安装好 Java 8 或者 Java 11。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://dlcdn.apache.org/flink/flink-1.14.3/flink-1.14.3-bin-scala_2.12.tgz&#xA;tar -zxvf flink-1.14.3-bin-scala_2.12.tgz&#xA;cd flink-1.14.3&#xA;./bin/start-cluster.sh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;运行成功后，可以在 IP:8081 访问 Flink-UI&lt;/p&gt;&#xA;&lt;h2 id=&#34;flink-word-count-job&#34;&gt;Flink Word Count job&lt;/h2&gt;&#xA;&lt;p&gt;source 是多段文本，类型： DataSource&lt;String&gt; ，经过 flatMap，切分为每个单词，然后转换为：(val,n) 的数据，然后根据 val 分组统计，得出 sum(n) 的值。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public static void main(String[] args) throws Exception {&#xA;    // 创建Flink任务运行环境&#xA;    final ExecutionEnvironment executionEnvironment =&#xA;            ExecutionEnvironment.getExecutionEnvironment();&#xA;&#xA;    // 创建DataSet，数据是一行一行文本&#xA;    DataSource&amp;lt;String&amp;gt; text =&#xA;            executionEnvironment.fromElements(&#xA;                    &amp;quot;Licensed to the Apache Software Foundation (ASF) under one&amp;quot;,&#xA;                    &amp;quot;or more contributor license agreements.  See the NOTICE file&amp;quot;,&#xA;                    &amp;quot;distributed with this work for additional information&amp;quot;,&#xA;                    &amp;quot;regarding copyright ownership.  The ASF licenses this file&amp;quot;,&#xA;                    &amp;quot;to you under the Apache License, Version 2.0 (the&amp;quot;);&#xA;&#xA;    // 通过Flink内置转换函数进行计算&#xA;    AggregateOperator&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; sum =&#xA;            text.flatMap(&#xA;                            new FlatMapFunction&amp;lt;String, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt;() {&#xA;                                @Override&#xA;                                public void flatMap(&#xA;                                        String value,&#xA;                                        Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; collector)&#xA;                                        throws Exception {&#xA;                                    String[] split = value.split(&amp;quot;\\W+&amp;quot;);&#xA;                                    for (String s : split) {&#xA;                                        if (s.length() &amp;gt; 0) {&#xA;                                            collector.collect(new Tuple2&amp;lt;&amp;gt;(s, 1));&#xA;                                            // TimeUnit.SECONDS.sleep(5);&#xA;                                        }&#xA;                                    }&#xA;                                }&#xA;                            })&#xA;                    .groupBy(0)&#xA;                    .sum(1);&#xA;&#xA;    // 打印结果&#xA;    sum.print();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;Job 可以直接运行，也可以提交到 Flink 集群中运行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言cobra</title>
      <link>https://qiref.github.io/post/2022/02/19/go%E8%AF%AD%E8%A8%80cobra/</link>
      <pubDate>Sat, 19 Feb 2022 18:16:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/02/19/go%E8%AF%AD%E8%A8%80cobra/</guid>
      <description>&lt;p&gt;摘要：Go语言 cobra 框架使用说明，文中代码地址： &lt;a href=&#34;https://github.com/ArchieYao/clid&#34;&gt;https://github.com/ArchieYao/clid&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;cobra-简介&#34;&gt;cobra 简介&lt;/h2&gt;&#xA;&lt;p&gt;cobra是 Go 语言的一个命令行程序库，可以用来编写命令行程序。同时，它也提供了一个脚手架， 用于生成基于 cobra 的应用程序框架。非常多知名的开源项目使用了 cobra 库构建命令行，如Kubernetes、Hugo、etcd等。&lt;/p&gt;&#xA;&lt;h2 id=&#34;安装-cobra&#34;&gt;安装 cobra&lt;/h2&gt;&#xA;&lt;p&gt;cobra 是由大名鼎鼎的 spf13（golang 开发者） 开发的，GitHub 地址：&lt;a href=&#34;https://github.com/spf13/cobra&#34;&gt;https://github.com/spf13/cobra&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 安装&#xA;go get -u github.com/spf13/cobra&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 检查是否安装成功&#xA;cobra -h&#xA;Cobra is a CLI library for Go that empowers applications.&#xA;This application is a tool to generate the needed files&#xA;to quickly create a Cobra application.&#xA;&#xA;Usage:&#xA;  cobra [command]&#xA;&#xA;Available Commands:&#xA;  add         Add a command to a Cobra Application&#xA;  completion  Generate the autocompletion script for the specified shell&#xA;  help        Help about any command&#xA;  init        Initialize a Cobra Application&#xA;&#xA;Flags:&#xA;  -a, --author string    author name for copyright attribution (default &amp;quot;YOUR NAME&amp;quot;)&#xA;      --config string    config file (default is $HOME/.cobra.yaml)&#xA;  -h, --help             help for cobra&#xA;  -l, --license string   name of license for the project&#xA;      --viper            use Viper for configuration&#xA;&#xA;Use &amp;quot;cobra [command] --help&amp;quot; for more information about a command.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;创建-cobra-工程&#34;&gt;创建 cobra 工程&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 创建 Go 工程&#xA;mkdir clid&#xA;cd clid&#xA;go mod init clid&#xA;&#xA;# 创建 cobra 工程&#xA;cobra init&#xA;# 可以得到如下工程目录&#xA;D:\WORKSPACE\GOLANG\TRAINNING\CLID&#xA;│   go.mod&#xA;│   go.sum&#xA;│   LICENSE&#xA;│   main.go&#xA;│&#xA;└───cmd&#xA;        root.go&#xA;&#xA;# 正常情况下，这个工程可以正常编译并且运行&#xA;go build -o ./bin/clid&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;增加自定义命令&#34;&gt;增加自定义命令&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cobra add version&#xA;&#xA;tree /f&#xA;D:.&#xA;│   go.mod&#xA;│   go.sum&#xA;│   LICENSE&#xA;│   main.go&#xA;│&#xA;└───cmd&#xA;        root.go&#xA;        version.go&#xA;&#xA;# 在 `cmd` 目录下新生成一个 `version.go` 的文件&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;从新生成的文件可以看出，核心方法就2个：&lt;/p&gt;</description>
    </item>
    <item>
      <title>ProtoBuf数据协议</title>
      <link>https://qiref.github.io/post/2022/01/11/protobuf%E6%95%B0%E6%8D%AE%E5%8D%8F%E8%AE%AE/</link>
      <pubDate>Tue, 11 Jan 2022 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2022/01/11/protobuf%E6%95%B0%E6%8D%AE%E5%8D%8F%E8%AE%AE/</guid>
      <description>&lt;p&gt;摘要：ProtoBuf(Protocol Buffers)是一种跨平台、语言无关、可扩展的序列化结构数据的方法，可用于网络数据交换及数据存储。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;protocol-buffers介绍&#34;&gt;Protocol Buffers介绍&lt;/h2&gt;&#xA;&lt;p&gt;不同于 &lt;code&gt;XML&lt;/code&gt; 、&lt;code&gt;JSON&lt;/code&gt; 这种文本格式数据，Protocol Buffers 是一种二进制格式数据。在Protocol Buffers 诞生之初，就被赋予两个特点：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;向前兼容，很容易引入新字段，应对字段的频繁变更&lt;/li&gt;&#xA;&lt;li&gt;数据格式具备描述性，并且支持多语言处理&lt;/li&gt;&#xA;&lt;li&gt;传输效率高&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;基于以上这些特性，Protocol Buffers 被广泛应用于各种 RPC 框架中，并且是 Google 的数据通用语言。&lt;/p&gt;&#xA;&lt;h3 id=&#34;protocol-buffers协议文件&#34;&gt;Protocol Buffers协议文件&lt;/h3&gt;&#xA;&lt;p&gt;Protocol Buffers 在使用前需要先定义好协议文件，以 &lt;code&gt;.proto&lt;/code&gt; 为后缀的文件就是Protocol Buffers 的协议文件。&lt;/p&gt;&#xA;&lt;p&gt;Example:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-protobuf&#34;&gt;// 指定protobuf的版本，proto3是最新的语法版本&#xA;syntax = &amp;quot;proto3&amp;quot;;&#xA;&#xA;// 定义数据结构，message 你可以想象成java的class，c语言中的struct&#xA;message Response {&#xA;  string data = 1;   // 定义一个string类型的字段，字段名字为data, 序号为1&#xA;  int32 status = 2;   // 定义一个int32类型的字段，字段名字为status, 序号为2&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;如果 A 和 B 要基于 Protocol Buffers 协议进行通信，那么在通信前，A 和 B 都需要有同一份协议文件，所以在 Protocol Buffers 数据传输过程中，不需要数据的 &lt;code&gt;Schema&lt;/code&gt; 信息；&lt;/p&gt;</description>
    </item>
    <item>
      <title>Log4j2按照时间和日志大小滚动</title>
      <link>https://qiref.github.io/post/2021/08/25/log4j2%E6%8C%89%E7%85%A7%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E5%BF%97%E5%A4%A7%E5%B0%8F%E6%BB%9A%E5%8A%A8/</link>
      <pubDate>Wed, 25 Aug 2021 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/08/25/log4j2%E6%8C%89%E7%85%A7%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E5%BF%97%E5%A4%A7%E5%B0%8F%E6%BB%9A%E5%8A%A8/</guid>
      <description>&lt;p&gt;摘要：Log4j2 按照时间和日志大小滚动。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;log4j2按照时间和日志大小滚&#34;&gt;Log4j2按照时间和日志大小滚&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-properties&#34;&gt;status = error&#xA;name = PropertiesConfig&#xA;&#xA;#Make sure to change log file path as per your need&#xA;property.filename = C:\\logs\\debug.log&#xA;&#xA;filters = threshold&#xA;filter.threshold.type = ThresholdFilter&#xA;filter.threshold.level = debug&#xA;&#xA;appenders = rolling&#xA;appender.rolling.type = RollingFile&#xA;appender.rolling.name = RollingFile&#xA;appender.rolling.fileName = ${filename}&#xA;appender.rolling.filePattern = debug-backup-%d{MM-dd-yy-HH-mm-ss}-%i.log.gz&#xA;appender.rolling.layout.type = PatternLayout&#xA;appender.rolling.layout.pattern = %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n&#xA;appender.rolling.policies.type = Policies&#xA;appender.rolling.policies.time.type = TimeBasedTriggeringPolicy&#xA;appender.rolling.policies.time.interval = 1&#xA;appender.rolling.policies.time.modulate = true&#xA;appender.rolling.policies.size.type = SizeBasedTriggeringPolicy&#xA;appender.rolling.policies.size.size=10MB&#xA;appender.rolling.strategy.type = DefaultRolloverStrategy&#xA;appender.rolling.strategy.max = 20&#xA;&#xA;loggers = rolling&#xA;#Make sure to change the package structure as per your application&#xA;logger.rolling.name = com.howtodoinjava&#xA;logger.rolling.level = debug&#xA;logger.rolling.additivity = false&#xA;logger.rolling.appenderRef.rolling.ref = RollingFile&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;日志配置动态更新&#34;&gt;日志配置动态更新&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;monitorInterval&lt;/code&gt; 是用来设置配置文件的动态加载时间的，单位是秒。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Git-rebase用法.md</title>
      <link>https://qiref.github.io/post/2021/08/09/git-rebase%E7%94%A8%E6%B3%95.md/</link>
      <pubDate>Mon, 09 Aug 2021 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/08/09/git-rebase%E7%94%A8%E6%B3%95.md/</guid>
      <description>&lt;p&gt;摘要：Git rebase 的使用方法。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;commit-合并&#34;&gt;commit 合并&lt;/h2&gt;&#xA;&lt;p&gt;当多个commit存在时，提交MR会出现很多的commit，review会很困难，这时可以将多个commit合并为一个commit。&lt;/p&gt;&#xA;&lt;p&gt;命令说明：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git rebase -i  [startpoint]  [endpoint] &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;其中-i的意思是&amp;ndash;interactive，即弹出交互式的界面让用户编辑完成合并操作，[startpoint] [endpoint] 则指定了一个编辑区间，如果不指定[endpoint]，则该区间的终点默认是当前分支HEAD所指向的commit(注：该区间指定的是一个前开后闭的区间)。&#xA;在查看到了log日志后，我们运行以下命令：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;git rebase -i 36224db&#xA;or&#xA;git rebase -i HEAD~3 # 合并最近三次commit&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;每一个commit id 前面的pick表示指令类型，git 为我们提供了以下几个命令:&#xA;pick：保留该commit（缩写:p）&#xA;reword：保留该commit，但我需要修改该commit的注释（缩写:r）&#xA;edit：保留该commit, 但我要停下来修改该提交(不仅仅修改注释)（缩写:e）&#xA;squash：将该commit和前一个commit合并（缩写:s）&#xA;fixup：将该commit和前一个commit合并，但我不要保留该提交的注释信息（缩写:f）&#xA;exec：执行shell命令（缩写:x）&#xA;drop：我要丢弃该commit（缩写:d）&lt;/p&gt;&#xA;&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shel&#34;&gt;git log&#xA;&#xA;commit 4ab2734f3380fbdace8620f461cd04c7993b6b0b (HEAD -&amp;gt; master)&#xA;Author: archieyao &amp;lt;archieyao@tencent.com&amp;gt;&#xA;Date:   Mon Aug 9 16:38:25 2021 +0800&#xA;&#xA;    add something 2&#xA;&#xA;commit 60d0bbbe094c0b93903ab995879d30246bbf331e&#xA;Author: archieyao &amp;lt;archieyao@tencent.com&amp;gt;&#xA;Date:   Mon Aug 9 16:38:02 2021 +0800&#xA;&#xA;    add something 1&#xA;&#xA;commit 1c3c12316449cf4f340c68e22c70caa60178ba5c&#xA;Author: archieyao &amp;lt;archieyao@tencent.com&amp;gt;&#xA;Date:   Mon Aug 9 16:37:43 2021 +0800&#xA;&#xA;    add something&#xA;&#xA;commit 7a9ab6f445ce0c7525a5dce3ca15fe600282553b&#xA;Author: archieyao &amp;lt;archieyao@tencent.com&amp;gt;&#xA;Date:   Mon Aug 9 09:31:11 2021 +0800&#xA;&#xA;    [update] readme&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;现在合并最近三次的commit。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Git工程拆分</title>
      <link>https://qiref.github.io/post/2021/07/08/git%E5%B7%A5%E7%A8%8B%E6%8B%86%E5%88%86/</link>
      <pubDate>Thu, 08 Jul 2021 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/07/08/git%E5%B7%A5%E7%A8%8B%E6%8B%86%E5%88%86/</guid>
      <description>&lt;p&gt;摘要：Git将工程按目录拆分。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# /project/&#xA;# ----/test/&#xA;# 将test目录抽成单独的工程&#xA;cd /project/test&#xA;&#xA;# 拆分子目录&#xA;$ git subtree split -P test -b test-new-br&#xA;$ mkdir ../test-new-br&#xA;$ cd ../test-new-br&#xA;&#xA;# 创建子工程&#xA;$ git init&#xA;$ git pull ../project test-new-br&#xA;# git log 可以看到历史commit&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&amp;#x1f635;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernates中的pod</title>
      <link>https://qiref.github.io/post/2021/06/29/kubernates%E4%B8%AD%E7%9A%84pod/</link>
      <pubDate>Tue, 29 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/29/kubernates%E4%B8%AD%E7%9A%84pod/</guid>
      <description>&lt;p&gt;摘要：运行在Kubernates中的容器：pod。由于不能将多个进程聚集在一个单独的容器中，我们需要一种更高级的结构将容器绑定在一起，将它们作为一个单元进行管理，这就是pod诞生的原因。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;pod基本概念&#34;&gt;pod基本概念&lt;/h2&gt;&#xA;&lt;p&gt;pod是Kubernetes中最重要的概念，pod是Kubernetes中部署的最小单元，一个pod中可以有一个或多个容器，pod有自己独立的私有IP和主机名。&lt;/p&gt;&#xA;&lt;p&gt;Kubernetes 集群中的 Pod 主要有两种用法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;运行单个容器的 Pod。&amp;ldquo;每个 Pod 一个容器&amp;quot;模型是最常见的 Kubernetes 用例； 在这种情况下，可以将 Pod 看作单个容器的包装器，并且 Kubernetes 直接管理 Pod，而不是容器。&lt;/li&gt;&#xA;&lt;li&gt;运行多个协同工作的容器的 Pod。 Pod 可能封装由多个紧密耦合且需要共享资源的共处容器组成的应用程序。 这些位于同一位置的容器可能形成单个内聚的服务单元，一个pod中的容器共享网络和volume，并且pod中的容器共享相同的命名空间。（由于一个pod中的容器共享网络，因此也就共享端口和IP。）&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;一般情况下，如果不是多个容器需要共用net或volume，尽可能地把不同的容器放到不同的pod中，新建一个pod不需要耗费很多资源，Kubernetes可以很方便地对pod进行管理和扩容、缩容等操作，这种方式可以更好地利用基础资源。&lt;/p&gt;&#xA;&lt;p&gt;总结来说，pod就是逻辑上的主机。&lt;/p&gt;&#xA;&lt;h2 id=&#34;pod生命周期&#34;&gt;pod生命周期&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Pending：表示pod已经被同意创建，正在等待kube-scheduler选择合适的节点创建，一般是在准备镜像；&lt;/li&gt;&#xA;&lt;li&gt;Running：表示pod中所有的容器已经被创建，并且至少有一个容器正在运行或者是正在启动或者是正在重启；&lt;/li&gt;&#xA;&lt;li&gt;Succeeded：表示所有容器已经成功终止，并且不会再启动；&lt;/li&gt;&#xA;&lt;li&gt;Failed：表示pod中所有容器都是非0（不正常）状态退出；&lt;/li&gt;&#xA;&lt;li&gt;Unknown：表示无法读取Pod状态，通常是kube-controller-manager无法与Pod通信。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;创建pod流程&#34;&gt;创建pod流程&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;客户端提交Pod的配置信息（可以是yaml文件定义好的信息）到kube-apiserver；&lt;/li&gt;&#xA;&lt;li&gt;Apiserver收到指令后，通知给controller-manager创建一个资源对象；&lt;/li&gt;&#xA;&lt;li&gt;Controller-manager通过api-server将pod的配置信息存储到ETCD数据中心中；&lt;/li&gt;&#xA;&lt;li&gt;Kube-scheduler检测到pod信息会开始调度预选，会先过滤掉不符合Pod资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行pod的节点，然后将pod的资源配置单发送到node节点上的kubelet组件上。&lt;/li&gt;&#xA;&lt;li&gt;Kubelet根据scheduler发来的资源配置单运行pod，运行成功后，将pod的运行信息返回给scheduler，scheduler将返回的pod运行状况的信息存储到etcd数据中心。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;删除pod流程&#34;&gt;删除pod流程&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;pod从service的endpoint列表中被移除；&lt;/li&gt;&#xA;&lt;li&gt;如果该pod定义了一个停止前的钩子，其会在pod内部被调用，停止钩子一般定义了如何优雅的结束进程；&lt;/li&gt;&#xA;&lt;li&gt;进程被发送TERM信号（kill -14）；&lt;/li&gt;&#xA;&lt;li&gt;当超过优雅退出的时间后，Pod中的所有进程都会被发送SIGKILL信号（kill -9）。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;pod常用命令&#34;&gt;pod常用命令&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kubectl describe po cluster-admin-0 -n default # 获取指定namespaces下的pod详情，可以看出container信息&#xA;kubectl get pods --all-namespaces # 获取所有namespaces下的pod&#xA;kubectl get pods -n default # -n 获取指定namaspaces下的pod&#xA;kubectl get pod podname -nkube-system -oyaml # 获取pod的详情，-oyaml 以yaml格式输出，也可以 -ojson&#xA;kubectl exec -it taskcenter-0 -c loglistener -noceanus /bin/bash # 进入某个pod下的cotainer&#xA;kubectl logs tke-log-agent-2687c -c loglistener # 获取某个pod下cotainer的log，也可以加 -f 参数，类似于 tail -f&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;创建pod的方式&#34;&gt;创建pod的方式&lt;/h2&gt;&#xA;&lt;p&gt;pod本身不具备故障重启以及副本等功能，一般使用其他的资源创建pod。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker构建Go工程镜像</title>
      <link>https://qiref.github.io/post/2021/06/23/docker%E6%9E%84%E5%BB%BAgo%E5%B7%A5%E7%A8%8B%E9%95%9C%E5%83%8F/</link>
      <pubDate>Wed, 23 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/23/docker%E6%9E%84%E5%BB%BAgo%E5%B7%A5%E7%A8%8B%E9%95%9C%E5%83%8F/</guid>
      <description>&lt;p&gt;摘要：Docker构建Go工程镜像。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;工程&#34;&gt;工程&lt;/h2&gt;&#xA;&lt;p&gt;工程是一个比较简单的Http server的demo，现在将这个工程构建为docker镜像。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;import (&#xA;    &amp;quot;fmt&amp;quot;&#xA;    &amp;quot;log&amp;quot;&#xA;    &amp;quot;net/http&amp;quot;&#xA;)&#xA;&#xA;func Init() {&#xA;    log.Println(&amp;quot;start server&amp;quot;)&#xA;    http.HandleFunc(&amp;quot;/hello_world&amp;quot;, HelloWorld)&#xA;    http.Handle(&amp;quot;/test_handle&amp;quot;, &amp;amp;TestHandleStruct{content: &amp;quot;test handle&amp;quot;})&#xA;    if err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil); err != nil {&#xA;        log.Println(&amp;quot;start server on 8080&amp;quot;)&#xA;    }&#xA;    log.Fatal(&amp;quot;start server failed.&amp;quot;)&#xA;}&#xA;&#xA;func main() {&#xA;    // 启动HTTP服务&#xA;    server.Init()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;构建&#34;&gt;构建&lt;/h2&gt;&#xA;&lt;p&gt;需要在工程根目录下新建一个Dockerfile&lt;/p&gt;&#xA;&lt;p&gt;内容如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-docker&#34;&gt;# 拉取Go语言的版本&#xA;FROM golang:1.16&#xA;&#xA;# 在容器内设置工作目录&#xA;WORKDIR /app&#xA;&#xA;# 把文件复制到当前工作目录&#xA;COPY . .&#xA;&#xA;FROM alpine:latest as prod&#xA;&#xA;# 设置GOPROXY的环境变量&#xA;ENV GOPROXY=&amp;quot;https://goproxy.cn&amp;quot;&#xA;&#xA;# 编译项目&#xA;#RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64  go build -o ./bin/go_http_server_demo ./src/main/main.go&#xA;&#xA;ADD ./bin/go_http_server_demo ./&#xA;&#xA;# 暴露端口&#xA;EXPOSE 8080&#xA;&#xA;# 可执行文件&#xA;CMD [&amp;quot;./go_http_server_demo&amp;quot;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;然后到根目录下编译项目，注意编译时要根据当前机器的类型设置环境变量：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Docker入门</title>
      <link>https://qiref.github.io/post/2021/06/21/docker%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 21 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/21/docker%E5%85%A5%E9%97%A8/</guid>
      <description>&lt;p&gt;摘要：Docker简单使用。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言开发，并遵从 Apache2.0 协议开源。&#xA;Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。&#xA;容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。&lt;/p&gt;&#xA;&lt;p&gt;Docker下载地址：&lt;a href=&#34;https://www.docker.com/get-started&#34;&gt;https://www.docker.com/get-started&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;安装完成后，才可以执行docker的相关命令。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$ docker system info&#xA;&#xA;Client:&#xA; Context:    default&#xA; Debug Mode: false&#xA; Plugins:&#xA;  buildx: Build with BuildKit (Docker Inc., v0.5.1-docker)&#xA;  compose: Docker Compose (Docker Inc., 2.0.0-beta.3)&#xA;  scan: Docker Scan (Docker Inc., v0.8.0)&#xA;&#xA;Server:&#xA; Containers: 0&#xA;  Running: 0&#xA;  Paused: 0&#xA;  Stopped: 0&#xA; Images: 0&#xA; Server Version: 20.10.7&#xA; Storage Driver: overlay2&#xA;  Backing Filesystem: extfs&#xA;  Supports d_type: true&#xA;  Native Overlay Diff: true&#xA;  userxattr: false&#xA; Logging Driver: json-file&#xA; Cgroup Driver: cgroupfs&#xA; Cgroup Version: 1&#xA; Plugins:&#xA;  Volume: local&#xA;  Network: bridge host ipvlan macvlan null overlay&#xA;  Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog&#xA; Swarm: inactive&#xA; Runtimes: runc io.containerd.runc.v2 io.containerd.runtime.v1.linux&#xA; Default Runtime: runc&#xA; Init Binary: docker-init&#xA; containerd version: d71fcd7d8303cbf684402823e425e9dd2e99285d&#xA; runc version: b9ee9c6314599f1b4a7f497e1f1f856fe433d3b7&#xA; init version: de40ad0&#xA; Security Options:&#xA;  seccomp&#xA;   Profile: default&#xA; Kernel Version: 5.10.25-linuxkit&#xA; Operating System: Docker Desktop&#xA; OSType: linux&#xA; Architecture: x86_64&#xA; CPUs: 6&#xA; Total Memory: 1.941GiB&#xA; Name: docker-desktop&#xA; ID: TA2L:IL5R:BGA2:7NS2:RE5C:LOZ6:7RHP:275V:F5OQ:KAJP:QHWN:VOQU&#xA; Docker Root Dir: /var/lib/docker&#xA; Debug Mode: false&#xA; HTTP Proxy: http.docker.internal:3128&#xA; HTTPS Proxy: http.docker.internal:3128&#xA; Registry: https://index.docker.io/v1/&#xA; Labels:&#xA; Experimental: false&#xA; Insecure Registries:&#xA;  127.0.0.0/8&#xA; Live Restore Enabled: false&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;mac上停止docker服务：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Kubernates组件</title>
      <link>https://qiref.github.io/post/2021/06/21/kubernates%E7%BB%84%E4%BB%B6/</link>
      <pubDate>Mon, 21 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/21/kubernates%E7%BB%84%E4%BB%B6/</guid>
      <description>&lt;p&gt;摘要：Kubernates基础概念及其组件。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;Kubernetes是一个开源的容器编排引擎，用来对容器化应用进行自动化部署、扩缩容和管理，简称K8s，K8s 这个缩写是因为k和s之间有八个字符。Google 在 2014 年开源了 Kubernetes 项目。&lt;/p&gt;&#xA;&lt;p&gt;&lt;img src=&#34;https://qiref.github.io/assets/img/components-of-kubernetes.svg&#34; alt=&#34;kubernetes&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;控制面组件&#34;&gt;控制面组件&lt;/h2&gt;&#xA;&lt;h3 id=&#34;kube-apiserver&#34;&gt;kube-apiserver&lt;/h3&gt;&#xA;&lt;p&gt;apiserver是 Kubernetes 控制面的组件， 该组件公开了 Kubernetes API。&lt;/p&gt;&#xA;&lt;h3 id=&#34;etcd&#34;&gt;etcd&lt;/h3&gt;&#xA;&lt;p&gt;etcd 是兼具一致性和高可用性的键值数据库，可以作为保存 Kubernetes 所有集群数据的后台数据库。&lt;/p&gt;&#xA;&lt;h3 id=&#34;kube-scheduler&#34;&gt;kube-scheduler&lt;/h3&gt;&#xA;&lt;p&gt;负责监视新创建的、未指定运行节点（node）的 Pods，选择节点让 Pod 在上面运行。&lt;/p&gt;&#xA;&lt;p&gt;调度决策考虑的因素包括单个 Pod 和 Pod 集合的资源需求、硬件/软件/策略约束、亲和性和反亲和性规范、数据位置、工作负载间的干扰和最后时限。&lt;/p&gt;&#xA;&lt;h3 id=&#34;kube-controller-manager&#34;&gt;kube-controller-manager&lt;/h3&gt;&#xA;&lt;p&gt;从逻辑上讲，每个控制器都是一个单独的进程， 但是为了降低复杂性，它们都被编译到同一个可执行文件，并在一个进程中运行。&lt;/p&gt;&#xA;&lt;p&gt;这些控制器包括:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;节点控制器（Node Controller）: 负责在节点出现故障时进行通知和响应&lt;/li&gt;&#xA;&lt;li&gt;任务控制器（Job controller）: 监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成&lt;/li&gt;&#xA;&lt;li&gt;端点控制器（Endpoints Controller）: 填充端点(Endpoints)对象(即加入 Service 与 Pod)&lt;/li&gt;&#xA;&lt;li&gt;服务帐户和令牌控制器（Service Account &amp;amp; Token Controllers）: 为新的命名空间创建默认帐户和 API 访问令牌&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;cloud-controller-manager&#34;&gt;cloud-controller-manager&lt;/h3&gt;&#xA;&lt;p&gt;云控制器管理器是指嵌入特定云的控制逻辑的 控制平面组件。 云控制器管理器允许您链接集群到云提供商的应用编程接口中， 并把和该云平台交互的组件与只和您的集群交互的组件分离开。&#xA;cloud-controller-manager 仅运行特定于云平台的控制回路。 如果你在自己的环境中运行 Kubernetes，或者在本地计算机中运行学习环境， 所部署的环境中不需要云控制器管理器。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言实现httpServer</title>
      <link>https://qiref.github.io/post/2021/06/19/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0httpserver/</link>
      <pubDate>Sat, 19 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/19/go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0httpserver/</guid>
      <description>&lt;p&gt;摘要：使用Go语言原生包实现Http Server。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;启动一个http-server&#34;&gt;启动一个Http Server&lt;/h2&gt;&#xA;&lt;p&gt;使用Go语言原生的net/http库可以很简单实现一个http server。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;log.Println(&amp;quot;start server&amp;quot;)&#xA;if err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil); err != nil {&#xA;    log.Println(&amp;quot;start server on 8080&amp;quot;)&#xA;}&#xA;log.Fatal(&amp;quot;start server failed.&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;没错，只要这么几行代码，就开启了一个http server，监听8080端口。&lt;/p&gt;&#xA;&lt;h2 id=&#34;接收http请求&#34;&gt;接收Http请求&lt;/h2&gt;&#xA;&lt;h3 id=&#34;httphandlefunc&#34;&gt;http.HandleFunc&lt;/h3&gt;&#xA;&lt;p&gt;开启了Http server后，无法处理Http请求这个就是个空的Server，下面给它加上处理Http Request的能力。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func init() {&#xA;    log.Println(&amp;quot;start server&amp;quot;)&#xA;    http.HandleFunc(&amp;quot;/hello_world&amp;quot;, HelloWorld)&#xA;    if err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, nil); err != nil {&#xA;        log.Println(&amp;quot;start server on 8080&amp;quot;)&#xA;    }&#xA;    log.Fatal(&amp;quot;start server failed.&amp;quot;)&#xA;}&#xA;&#xA;func HelloWorld(w http.ResponseWriter, r *http.Request) {&#xA;    _, err := w.Write([]byte(&amp;quot;hello world&amp;quot;))&#xA;    if err != nil {&#xA;        log.Println(err)&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;&lt;code&gt;http.HandleFunc(&amp;quot;/hello_world&amp;quot;, HelloWorld)&lt;/code&gt; 这行代码指定了一个路由对应的方法，然后访问&lt;a href=&#34;http://127.0.0.1:8080/hello_world&#34;&gt;http://127.0.0.1:8080/hello_world&lt;/a&gt; 可以得到hello world的字符串，这段字符串也是&lt;code&gt;HelloWorld(w http.ResponseWriter, r *http.Request)&lt;/code&gt; 函数的输出。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言反射</title>
      <link>https://qiref.github.io/post/2021/06/17/go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Thu, 17 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/17/go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84/</guid>
      <description>&lt;p&gt;摘要：理解Go语言的反射机制，反射是指在程序运行期对程序本身进行访问和修改的能力。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;反射基础信息&#34;&gt;反射基础信息&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func reflectDemo() {&#xA;    str := &amp;quot;reflect&amp;quot;&#xA;    fmt.Println(reflect.ValueOf(str))&#xA;    fmt.Println(reflect.TypeOf(str))&#xA;}&#xA;// 结果&#xA;// reflect&#xA;// string&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;reflect.ValueOf()获取数据运行时的值。&#xA;reflect.TypeOf()获取数据类型信息。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Type values are comparable, such as with the == operator,&#xA;// so they can be used as map keys.&#xA;// Two Type values are equal if they represent identical types.&#xA;type Type interface {&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// To compare two Values, compare the results of the Interface method.&#xA;// Using == on two Values does not compare the underlying values&#xA;// they represent.&#xA;type Value struct {&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;从源码中可以看出，Type是个interface，而Value是个struct。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言defer、panic、recover</title>
      <link>https://qiref.github.io/post/2021/06/15/go%E8%AF%AD%E8%A8%80deferpanicrecover/</link>
      <pubDate>Tue, 15 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/15/go%E8%AF%AD%E8%A8%80deferpanicrecover/</guid>
      <description>&lt;p&gt;摘要：理解Go语言defer、panic、recover。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;defer&#34;&gt;defer&lt;/h2&gt;&#xA;&lt;p&gt;Go 语言的 defer 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源，总结一句话就是完成函数执行完的收尾工作。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func DeferDemo() {&#xA;    defer fmt.Println(&amp;quot;this is defer println&amp;quot;)&#xA;    fmt.Println(&amp;quot;this is println&amp;quot;)&#xA;}&#xA;// 输出&#xA;// this is println&#xA;// this is defer println&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;运行以上代码每次都是第二个println先输出，然后才是defer关键字修饰的println输出。&lt;/p&gt;&#xA;&lt;p&gt;如果有多个defer，输出顺序又会如何？&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func MultiDeferDemo() {&#xA;    for i := 0; i &amp;lt; 5; i++ {&#xA;        defer fmt.Println(&amp;quot; defer &amp;quot;, i)&#xA;    }&#xA;}&#xA;// 输出&#xA;// defer  4&#xA;// defer  3&#xA;// defer  2&#xA;// defer  1&#xA;// defer  0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;每次最先输出的都是循环的最后一个println，可以得出：多个defer，运行顺序遵循LIFO规则。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言包管理</title>
      <link>https://qiref.github.io/post/2021/06/10/go%E8%AF%AD%E8%A8%80%E5%8C%85%E7%AE%A1%E7%90%86/</link>
      <pubDate>Thu, 10 Jun 2021 10:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/10/go%E8%AF%AD%E8%A8%80%E5%8C%85%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;p&gt;摘要：Go语言包管理。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;包使用规范&#34;&gt;包使用规范&lt;/h2&gt;&#xA;&lt;p&gt;包的习惯用法：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;包名一般是小写的，使用一个简短且有意义的名称。&lt;/li&gt;&#xA;&lt;li&gt;包名一般要和所在的目录同名，也可以不同，包名中不能包含- 等特殊符号。&lt;/li&gt;&#xA;&lt;li&gt;包一般使用域名作为目录名称，这样能保证包名的唯一性，比如 GitHub 项目的包一般会放到GOPATH/src/github.com/userName/projectName 目录下。&lt;/li&gt;&#xA;&lt;li&gt;包名为 main 的包为应用程序的入口包，编译不包含 main 包的源码文件时不会得到可执行文件。&lt;/li&gt;&#xA;&lt;li&gt;一个文件夹下的所有源码文件只能属于同一个包，同样属于同一个包的源码文件不能放在多个文件夹下。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Go 语言中，所有的定义，比如函数、变量、结构体等，如果首字母是大写，那么就可以被其他包使用；同一包下，不存在引用问题。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;h2 id=&#34;基于包的封装&#34;&gt;基于包的封装&lt;/h2&gt;&#xA;&lt;p&gt;在Go语言中封装就是把抽象出来的字段和对字段的操作封装在一起，数据被保护在内部，程序的其它包只能通过被授权的方法，才能对字段进行操作。&lt;/p&gt;&#xA;&lt;p&gt;封装的好处：&#xA;隐藏实现细节；&#xA;可以对数据进行验证，保证数据安全合理。&lt;/p&gt;&#xA;&lt;p&gt;封装的实现步骤：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;将结构体、字段的首字母小写；&lt;/li&gt;&#xA;&lt;li&gt;给结构体所在的包提供一个工厂模式的函数，首字母大写，类似一个构造函数；&lt;/li&gt;&#xA;&lt;li&gt;提供一个首字母大写的 Set 方法（类似其它语言的 public），用于对属性判断并赋值；&lt;/li&gt;&#xA;&lt;li&gt;提供一个首字母大写的 Get 方法（类似其它语言的 public），用于获取属性的值。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;包的初始化&#34;&gt;包的初始化&lt;/h2&gt;&#xA;&lt;p&gt;每个包都允许有一个 init 函数，当这个包被导入时，会执行该包的这个 init 函数，做一些初始化任务。&#xA;对于 init 函数的执行有两点需要注意:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;init 函数优先于 main 函数执行&lt;/li&gt;&#xA;&lt;li&gt;在一个包引用链中，包的初始化是深度优先的。比如，有这样一个包引用关系：main→A→B→C，那么初始化顺序为&#xA;C.init→B.init→A.init→main&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;封装引用实例&#34;&gt;封装引用实例&lt;/h2&gt;&#xA;&lt;p&gt;建立如下工程结构，在main包中需要访问model包中的内容。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;project&#xA;|---src&#xA;    |---main&#xA;        -main.go&#xA;    |---model&#xA;        -student.go&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;student.go&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;type student struct {&#xA;    Name      string&#xA;    idCardNum string // 私有，外部包不可访问&#xA;    Age       int8&#xA;}&#xA;&#xA;func NewStudent(stuName string, age int8) *student {&#xA;    return &amp;amp;student{&#xA;        Name: stuName,&#xA;        Age:  age,&#xA;    }&#xA;}&#xA;&#xA;// 定义结构体方法&#xA;func (stu *student) SetIdCardNum(idCN string) {&#xA;    stu.idCardNum = idCN&#xA;}&#xA;&#xA;// 定义结构体方法&#xA;func (stu *student) GetIdCardNum() string {&#xA;    return stu.idCardNum&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;main.go&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言channel</title>
      <link>https://qiref.github.io/post/2021/06/09/go%E8%AF%AD%E8%A8%80channel/</link>
      <pubDate>Wed, 09 Jun 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/09/go%E8%AF%AD%E8%A8%80channel/</guid>
      <description>&lt;p&gt;摘要：Go语言中，协程之间通过channel相互通信，可以从一个Go协程将值发送到通道，然后在别的协程中接收。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;channel-定义&#34;&gt;channel 定义&lt;/h2&gt;&#xA;&lt;p&gt;定义channel的语法为：make(chan val-type)，val-type就是需要传递值的类型。 &lt;code&gt;chan1 &amp;lt;- val&lt;/code&gt; 表示将val发送到channel chann1中， &lt;code&gt;r := &amp;lt;- chann1&lt;/code&gt;表示从chann1中读取消息。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Ping(c *chan string, s string) {&#xA;    *c &amp;lt;- s&#xA;}&#xA;&#xA;func Pong(c *chan string) string {&#xA;    return &amp;lt;-*c&#xA;}&#xA;&#xA;// main&#xA;func main() {&#xA;&#xA;    c := make(chan string)&#xA;    go Ping(&amp;amp;c, &amp;quot;ping&amp;quot;)&#xA;    go func() {&#xA;        pong := Pong(&amp;amp;c)&#xA;        fmt.Println(pong)&#xA;    }()&#xA;&#xA;    time.Sleep(time.Second * 2)&#xA;}&#xA;&#xA;// 结果&#xA;// ping&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;需要注意的是，向通道中发送消息和从通道中接收消息，都是阻塞的，如果发送和接收不是成对出现，就会发生错误。&#xA;将上文中代码改成这样：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;c := make(chan string)&#xA;Ping(&amp;amp;c, &amp;quot;ping&amp;quot;)&#xA;//go func() {&#xA;//    pong := Pong(&amp;amp;c)&#xA;//    fmt.Println(pong)&#xA;//}()&#xA;&#xA;time.Sleep(time.Second * 2)&#xA;&#xA;//fatal error: all goroutines are asleep - deadlock!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;channel方向&#34;&gt;channel方向&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func pong(ping &amp;lt;-chan string, pong chan&amp;lt;- string) {&#xA;    msg := &amp;lt;-ping&#xA;    pong &amp;lt;- msg&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;在chan的定义中，箭头的方向是固定的，&lt;code&gt;&amp;lt;-&lt;/code&gt;箭头方向只能向左。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言接口</title>
      <link>https://qiref.github.io/post/2021/06/05/go%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 05 Jun 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/05/go%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3/</guid>
      <description>&lt;p&gt;摘要：Go支持接口，接口是方法特征的命名集合。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h1 id=&#34;go语言接口&#34;&gt;go语言接口&lt;/h1&gt;&#xA;&lt;p&gt;go语言中有接口的概念，接口是方法特征的命名集合。它把所有的具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。&lt;/p&gt;&#xA;&lt;p&gt;注意，实现了这些方法就算实现了这个接口。&lt;/p&gt;&#xA;&lt;h2 id=&#34;定义接口&#34;&gt;定义接口&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 定义geometry接口&#xA;type geometry interface {&#xA;    area() float64&#xA;    peri() float64&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;接口的定义也比较简单。定义和实现规则如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;/* 定义接口 */&#xA;type interface_name interface {&#xA;   method_name1 [return_type]&#xA;   method_name2 [return_type]&#xA;   method_name3 [return_type]&#xA;   ...&#xA;   method_namen [return_type]&#xA;}&#xA;&#xA;/* 定义结构体 */&#xA;type struct_name struct {&#xA;   /* variables */&#xA;}&#xA;&#xA;/* 实现接口方法 */&#xA;func (struct_name_variable struct_name) method_name1() [return_type] {&#xA;   /* 方法实现 */&#xA;}&#xA;...&#xA;func (struct_name_variable struct_name) method_namen() [return_type] {&#xA;   /* 方法实现*/&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;实现接口&#34;&gt;实现接口&lt;/h2&gt;&#xA;&lt;p&gt;Go语言中接口的实现都是隐式的，默认实现了接口的所有方法就隐式地实现了接口。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言指针</title>
      <link>https://qiref.github.io/post/2021/06/05/go%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</link>
      <pubDate>Sat, 05 Jun 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/05/go%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</guid>
      <description>&lt;p&gt;摘要：Go支持指针，允许在程序中通过引用传递值或者数据结构。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;go语言中的指针和C语言中的指针类似，但比C语言中的指针更简单。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Go语言取地址符号是&amp;amp;，放到变量前会返回对应变量的内存地址&#xA;var i1 int = 1&#xA;var j = i1&#xA;&#xA;fmt.Println(&amp;amp;i1)&#xA;fmt.Println(&amp;amp;j)&#xA;&#xA;// 定义指针变量 var var_name *var_type&#xA;s := &amp;quot;sss&amp;quot;&#xA;p := 2181&#xA;&#xA;var ip *string = &amp;amp;s&#xA;var port *int = &amp;amp;p&#xA;&#xA;fmt.Println(*ip)&#xA;fmt.Println(*port)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;变量、指针和地址三者的关系是，每个变量都拥有地址，指针的值就是地址。&lt;/p&gt;&#xA;&lt;p&gt;通过&lt;code&gt;&amp;amp;&lt;/code&gt; 获取对应变量的内存地址。 通过&lt;code&gt;*&lt;/code&gt; 获取指针的值，也就是指针取值。取地址操作符 &lt;code&gt;&amp;amp;&lt;/code&gt; 和取值操作符 &lt;code&gt;*&lt;/code&gt; 是一对互补操作符，&lt;code&gt;&amp;amp;&lt;/code&gt; 取出地址，&lt;code&gt;*&lt;/code&gt; 根据地址取出地址指向的值。&lt;/p&gt;&#xA;&lt;p&gt;变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;对变量进行取地址操作使用&amp;amp;操作符，可以获得这个变量的指针变量。&lt;/li&gt;&#xA;&lt;li&gt;指针变量的值是指针地址。&lt;/li&gt;&#xA;&lt;li&gt;对指针变量进行取值操作使用*操作符，可以获得指针变量指向的原变量的值。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;通过new创建指针&#34;&gt;通过New()创建指针&lt;/h2&gt;&#xA;&lt;p&gt;Go语言还提供了另外一种方法来创建指针变量，格式如下：&#xA;new(type) 这个type可以为int。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// create ptr by new()&#xA;func createPtr() {&#xA;    str := new(string)&#xA;    *str = &amp;quot;ssss&amp;quot;&#xA;&#xA;    fmt.Println(&amp;quot;str is : &amp;quot;, str)&#xA;    fmt.Println(&amp;quot;*str is : &amp;quot;, *str)&#xA;&#xA;    // str is :  0xc000116050&#xA;    // *str is :  ssss&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;new() 函数可以创建一个对应类型的指针，创建过程会分配内存，被创建的指针指向默认值。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言goroutine</title>
      <link>https://qiref.github.io/post/2021/06/03/go%E8%AF%AD%E8%A8%80goroutine/</link>
      <pubDate>Thu, 03 Jun 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/03/go%E8%AF%AD%E8%A8%80goroutine/</guid>
      <description>&lt;p&gt;摘要：Go语言goroutine&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;goroutine协程&#34;&gt;goroutine协程&lt;/h2&gt;&#xA;&lt;p&gt;Go 协程 在执行上来说是轻量级的线程。go语言层面并不支持多进程或多线程，但是协程更好用，协程被称为用户态线程，不存在CPU上下文切换问题，效率非常高。&lt;/p&gt;&#xA;&lt;p&gt;go语言中启动一个协程非常简单，只需要在执行函数前加上go关键字，就可以启用goroutine。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {&#xA;&#xA;    // 使用匿名函数启用goroutine&#xA;    go func() {&#xA;        fmt.Println(&amp;quot;goroutine&amp;quot;)&#xA;    }()&#xA;&#xA;    // 调用函数启用goroutine&#xA;    go func1()&#xA;}&#xA;&#xA;func func1() {&#xA;    fmt.Println(&amp;quot;f1() was called.&amp;quot;)&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;没错就是这么简单，在go语言中，goroutine会被放到运行队列runtime.runqput中，然后由调度器调度。并非是每一个协程都会有一个对应的线程去执行，协程比线程的粒度更细。&lt;/p&gt;&#xA;&lt;p&gt;但是上述代码并不会有输出结果，因为还没等func1()函数执行完成，main()就已经执行完成了。所以在main()函数执行完成之前sleep一下就可以看到func1()的执行结果。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;time.Sleep(time.Second * 1)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;waitgroup&#34;&gt;WaitGroup&lt;/h2&gt;&#xA;&lt;p&gt;sleep肯定是不靠谱的，go语言中可以等待协程执行完成后再回到主线程。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 定义全局变量&#xA;var WG = sync.WaitGroup{}&#xA;&#xA;func main() {&#xA;    WG.Add(1)&#xA;    go func1()&#xA;    WG.Wait()&#xA;}&#xA;&#xA;func func1() {&#xA;    fmt.Println(&amp;quot;f1() was called.&amp;quot;)&#xA;    WG.Done()&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;在调用func1()之前，调用全局变量WG.Add()方法，然后启用goroutine调用func1()，然后调用WG.Wait()函数进行等待，fun1()调用结束后，调用WG.Done()。&#xA;通过试验可以发现：Add()方法中的数值与Done()方法的数量应该保持一致。当Add(2)时，Done()方法应该执行两次。直到 WaitGroup 计数器恢复为 0； 即所有协程的工作都已经完成。&#xA;看源码可以发现，Done()与Add()实际上是一个函数。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// Done decrements the WaitGroup counter by one.&#xA;func (wg *WaitGroup) Done() {&#xA;    wg.Add(-1)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;多个goroutine如何执行&#34;&gt;多个goroutine如何执行&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func main() {&#xA;    loop := 5&#xA;    WG.Add(loop)&#xA;    for i := 0; i &amp;lt; loop; i++ {&#xA;        go func2(i)&#xA;    }&#xA;    WG.Wait()&#xA;}&#xA;&#xA;// define func2&#xA;func func2(i int) {&#xA;    fmt.Println(&amp;quot;func2() was called. i is : &amp;quot;, i)&#xA;    WG.Done()&#xA;}&#xA;&#xA;// 运行结果：&#xA;//func2() was called. i is : 4&#xA;//func2() was called. i is : 2&#xA;//func2() was called. i is : 3&#xA;//func2() was called. i is : 0&#xA;//func2() was called. i is : 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;每个goroutine的运行并不规则，每个协程在并发执行。&amp;#x1f914;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言基本数据结构</title>
      <link>https://qiref.github.io/post/2021/06/01/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Tue, 01 Jun 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/06/01/go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>&lt;p&gt;摘要：Go语言基本数据结构&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;数组&#34;&gt;数组&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;strings := [3]string{&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;2&amp;quot;}&#xA;intArray := [8]int{1, 2, 3, 4, 5, 5, 5, 55}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;定义两个数组,&lt;code&gt;fmt.Println(len(strings))&lt;/code&gt; 可以使用&lt;code&gt;len()&lt;/code&gt;函数得到数组的长度，&lt;code&gt;strings[1]&lt;/code&gt;可以获取指定数组下标的元素。&lt;/p&gt;&#xA;&lt;p&gt;所以通过以下方式可以遍历数组：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;for i := 0; i &amp;lt; len(strings); i++ {&#xA;    fmt.Println(strings[i])&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;下文提供了更加优雅的方式。&lt;/p&gt;&#xA;&lt;h2 id=&#34;slice&#34;&gt;slice&lt;/h2&gt;&#xA;&lt;p&gt;Go数组的长度不可变，Go提供了一种内置类型切片:slice，与数组相比，切片的长度不是固定的，可以动态扩容、添加元素。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;slice1 := make([]string, 2)&#xA;fmt.Println(slice1)&#xA;&#xA;slice1[0] = &amp;quot;22&amp;quot;&#xA;slice1[1] = &amp;quot;222&amp;quot;&#xA;fmt.Println(slice1)&#xA;&#xA;slice1 = append(slice1, &amp;quot;33&amp;quot;, &amp;quot;44&amp;quot;, &amp;quot;55&amp;quot;)&#xA;fmt.Println(slice1)&#xA;fmt.Println(len(slice1))&#xA;&#xA;// 裁剪，从index 2 到index 4&#xA;sliceSub := slice1[2:4]&#xA;fmt.Println(sliceSub)&#xA;&#xA;// 裁剪，从index 2 到最后&#xA;sliceSub2 := slice1[2:]&#xA;fmt.Println(sliceSub2)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;make()&lt;/code&gt; 方法可以构建一个slice，并可以指定初始化大小和容量；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;len()&lt;/code&gt; 可以获取slice的大小；&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;append()&lt;/code&gt; 可以想slice中添加元素；&lt;/li&gt;&#xA;&lt;li&gt;可以通过裁剪，下标移动等方式删除slice。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;slice从头部删除&#34;&gt;slice从头部删除&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = []int{1, 2, 3}&#xA;a = a[1:] // 删除开头1个元素&#xA;a = a[N:] // 删除开头N个元素&#xA;&#xA;a = append(a[:0], a[1:]...) // 删除开头1个元素&#xA;a = append(a[:0], a[N:]...) // 删除开头N个元素&#xA;&#xA;a = a[:copy(a, a[1:])] // 删除开头1个元素&#xA;a = a[:copy(a, a[N:])] // 删除开头N个元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;slice从中间删除&#34;&gt;slice从中间删除&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = append(a[:i], a[i+1:]...) // 删除中间1个元素&#xA;a = append(a[:i], a[i+N:]...) // 删除中间N个元素&#xA;a = a[:i+copy(a[i:], a[i+1:])] // 删除中间1个元素&#xA;a = a[:i+copy(a[i:], a[i+N:])] // 删除中间N个元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;slice从尾部删除&#34;&gt;slice从尾部删除&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;a = a[:len(a)-1] // 删除尾部1个元素&#xA;a = a[:len(a)-N] // 删除尾部N个元素&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;slice-扩容&#34;&gt;slice 扩容&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;slice2 := make([]string, 1, 1)&#xA;// cap()函数, 计算slice长度可以达到多少&#xA;fmt.Println(&amp;quot;cap(slice1) is :&amp;quot;, cap(slice1))&#xA;&#xA;slice2[0] = &amp;quot;0&amp;quot;&#xA;&#xA;slice2 = append(slice2, &amp;quot;3&amp;quot;)&#xA;fmt.Println(&amp;quot;cap(slice2) is :&amp;quot;, cap(slice2))&#xA;&#xA;numbers := []int{0, 1, 2, 3, 4, 5}&#xA;&#xA;numbers = append(numbers, 6)&#xA;&#xA;fmt.Println(numbers)&#xA;fmt.Println(cap(numbers))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;通过&lt;code&gt;cap()&lt;/code&gt;函数可以获取slice的容量，容量是&lt;code&gt;make()&lt;/code&gt;函数的第三个参数，超过设置的容量再往slice中添加元素就会使slice扩容。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go语言变量</title>
      <link>https://qiref.github.io/post/2021/05/31/go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/</link>
      <pubDate>Mon, 31 May 2021 21:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2021/05/31/go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/</guid>
      <description>&lt;p&gt;摘要：Go语言变量&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;Go语言中的变量定义相对严格，当定义一个局部变量为使用时，会编译报错，在go语言中，无需要多余的代码。但全局变量除外，定义全局变量允许暂不使用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;全局变量&#34;&gt;全局变量&lt;/h2&gt;&#xA;&lt;p&gt;全局变量可以被全局访问&lt;/p&gt;&#xA;&lt;p&gt;定义全局变量：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// global variable&#xA;var x, y int&#xA;&#xA;var (&#xA;    a int&#xA;    b bool&#xA;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;基本常量&#34;&gt;基本常量&lt;/h2&gt;&#xA;&lt;p&gt;常量一经被定义后无法被重新赋值，常量可以定义为全局的，也可以定义为局部的。&lt;/p&gt;&#xA;&lt;p&gt;定义常量：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;// 这是一个常量&#xA;const CONST1 = 111&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;iota常量&#34;&gt;iota常量&lt;/h2&gt;&#xA;&lt;p&gt;iota，特殊常量，可以认为是一个可以被编译器修改的常量。&#xA;iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;const (&#xA;    a = iota&#xA;    b = iota&#xA;    c = iota&#xA;)&#xA;&#xA;// 以上写法可以简写为&#xA;const (&#xA;    d = iota&#xA;    e&#xA;    f&#xA;)&#xA;&#xA;fmt.Println(a, b, c)&#xA;fmt.Println(d, e, f)&#xA;&#xA;// 输出结果：&#xA;&#xA;// 0 1 2&#xA;// 0 1 2 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;iota常量可以恢复计数&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL执行计划</title>
      <link>https://qiref.github.io/post/2020/10/21/mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</link>
      <pubDate>Wed, 21 Oct 2020 11:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2020/10/21/mysql%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92/</guid>
      <description>&lt;h2 id=&#34;什么是sql执行计划&#34;&gt;什么是SQL执行计划&lt;/h2&gt;&#xA;&lt;p&gt;EXPLAIN命令是查看查询优化器如何决定执行查询的主要的方法，学会解释EXPLAIN将帮助我们了解SQL优化器是如何工作的。执行计划可以告诉我们SQL如何使用索引，连接查询的执行顺序，查询的数据行数。&#xA;要使用EXPLAIN,只需要在查询的SELECT关键字之前增加EXPLAIN这个词。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sql&#34;&gt;MySQL [dev]&amp;gt; explain select * from TableName where Name like &#39;%c&#39;;&#xA;+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+&#xA;| id | select_type | table        | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |&#xA;+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+&#xA;|  1 | SIMPLE      | ClusterGroup | NULL       | ALL  | NULL          | NULL | NULL    | NULL |  254 |    11.11 | Using where |&#xA;+----+-------------+--------------+------------+------+---------------+------+---------+------+------+----------+-------------+&#xA;1 row in set, 1 warning (0.01 sec)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;执行计划参数说明&#34;&gt;执行计划参数说明&lt;/h2&gt;&#xA;&lt;h3 id=&#34;id&#34;&gt;id&lt;/h3&gt;&#xA;&lt;p&gt;是一位数字，表示select语句的顺序。&#xA;id值相同时，执行顺序从上到下。id值不同时，id值大的先执行。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Centos搭建公共yum源</title>
      <link>https://qiref.github.io/post/2019/12/14/centos%E6%90%AD%E5%BB%BA%E5%85%AC%E5%85%B1yum%E6%BA%90/</link>
      <pubDate>Sat, 14 Dec 2019 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2019/12/14/centos%E6%90%AD%E5%BB%BA%E5%85%AC%E5%85%B1yum%E6%BA%90/</guid>
      <description>&lt;p&gt;摘要：记录在Centos7中如何挂载ISO镜像作yum源，并借助http服务作公共yum源。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;p&gt;部署yum私服&#xA;上传centos镜像文件到服务器&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;mount -t iso9660 -o loop&#xA;centos-7-x86_64-dvd-1511.iso /mnt/cdrom/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;（卸载：umoutn /mnt/cdrom)&lt;/p&gt;&#xA;&lt;p&gt;挂载成功！&#xA;将软件链接到http服务发布路径下&#xA;确定当前服务器是否安装了httpd服务&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ln -s /mnt/cdrom/ /var/www/html/CentOS7 &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;检查http服务&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl status httpd.service &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;启动HTTP服务器&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;systemctl enable httpd.service&#xA;systemctl start httpd.service&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;界面查看&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;cd /etc/yum.repos.d/&#xA;mkdir bak&#xA;mv centos-* bak&#xA;vi CentOS-Base.repo&#xA;&#xA;[base]&#xA;name=CentOS-$releasever - Base&#xA;baseurl=http://192.168.67.15/CentOS7/&#xA;gpgcheck=1&#xA;gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;分发到所有服务器&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;scp -r /etc/yum.repos.d/  hadoop-01:/etc/&#xA;scp -r /etc/yum.repos.d/  hadoop-02:/etc/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;检查是否正成功安装yum 源&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;yum clean all&#xA;yum makecache&#xA;yum list&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;如果能看到软件列表则说明安装成功。&lt;/p&gt;</description>
    </item>
    <item>
      <title>逆波兰表达式算法</title>
      <link>https://qiref.github.io/post/2019/09/04/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Wed, 04 Sep 2019 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2019/09/04/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%97%E6%B3%95/</guid>
      <description>&lt;p&gt;摘要：将中缀表达式转化为后缀表达式，以及计算后缀表达式的算法。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&#xA;import org.slf4j.Logger;&#xA;import org.slf4j.LoggerFactory;&#xA;&#xA;import java.util.HashSet;&#xA;import java.util.Scanner;&#xA;import java.util.Stack;&#xA;&#xA;/**&#xA; * @author YaoQi&#xA; * Date: 2019/1/5 15:45&#xA; * Modified:&#xA; * Description: 中缀表达式转后缀表达式&#xA; */&#xA;public class InfixToSuffixHandler {&#xA;&#xA;    private static final Logger logger = LoggerFactory.getLogger(InfixToSuffixHandler.class);&#xA;&#xA;    private static HashSet&amp;lt;Character&amp;gt; opStr = new HashSet&amp;lt;&amp;gt;();&#xA;&#xA;    static {&#xA;        logger.info(&amp;quot;Initialization operator&amp;quot;);&#xA;        opStr.add(&#39;+&#39;);&#xA;        opStr.add(&#39;-&#39;);&#xA;        opStr.add(&#39;*&#39;);&#xA;        opStr.add(&#39;/&#39;);&#xA;        logger.info(&amp;quot;Initialization finished&amp;quot;);&#xA;    }&#xA;&#xA;    /**&#xA;     * 判断字符是否为操作符&#xA;     *&#xA;     * @param c 字符&#xA;     * @return&#xA;     */&#xA;    private static boolean isOpStr(char c) {&#xA;        return opStr.contains(c);&#xA;    }&#xA;&#xA;    /**&#xA;     * 判断字符是否为操作数&#xA;     *&#xA;     * @param c 字符&#xA;     * @return&#xA;     */&#xA;    private static boolean isOperand(char c) {&#xA;        return c &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; c &amp;lt;= &#39;9&#39;;&#xA;    }&#xA;&#xA;    /**&#xA;     * 得到当前操作符的优先级&#xA;     *&#xA;     * @param c 操作符&#xA;     * @return&#xA;     */&#xA;    private static int priority(char c) {&#xA;        switch (c) {&#xA;            case &#39;*&#39;:&#xA;            case &#39;/&#39;:&#xA;                return 3;&#xA;            case &#39;+&#39;:&#xA;            case &#39;-&#39;:&#xA;                return 2;&#xA;            case &#39;(&#39;:&#xA;                return 1;&#xA;            default: {&#xA;                logger.error(&amp;quot;c: {} is not operator marks&amp;quot;, c);&#xA;                return 0;&#xA;            }&#xA;        }&#xA;    }&#xA;&#xA;    /**&#xA;     * 用后缀表达式求值&#xA;     *&#xA;     * @param suffixExpr 后缀表达式&#xA;     * @return&#xA;     */&#xA;    public static int numberCalculate(String suffixExpr) {&#xA;        Stack&amp;lt;Integer&amp;gt; count = new Stack&amp;lt;&amp;gt;();&#xA;        char c;&#xA;        int number1, number2;&#xA;        for (int i = 0; i &amp;lt; suffixExpr.length(); i++) {&#xA;            if (isOperand(c = suffixExpr.charAt(i))) {&#xA;                count.push(c - &#39;0&#39;);&#xA;            } else {&#xA;                number2 = count.pop();&#xA;                number1 = count.pop();&#xA;                switch (c) {&#xA;                    case &#39;+&#39;:&#xA;                        count.push(number1 + number2);&#xA;                        break;&#xA;                    case &#39;-&#39;:&#xA;                        count.push(number1 - number2);&#xA;                        break;&#xA;                    case &#39;*&#39;:&#xA;                        count.push(number1 * number2);&#xA;                        break;&#xA;                    case &#39;/&#39;:&#xA;                        count.push(number1 / number2);&#xA;                        break;&#xA;                    default:&#xA;                        break;&#xA;                }&#xA;            }&#xA;        }&#xA;        return count.pop();&#xA;    }&#xA;&#xA;&#xA;    /**&#xA;     * 将中缀表达式转化为后缀表达式&#xA;     *&#xA;     * @param expression 中缀表达式&#xA;     * @return 返回后缀表达式&#xA;     */&#xA;    public static StringBuilder getSuffixExpression(String expression) {&#xA;        //保存已将建立的后缀表达式&#xA;        StringBuilder suffixExpr = new StringBuilder();&#xA;        //操作符栈&#xA;        Stack&amp;lt;Character&amp;gt; opStr = new Stack&amp;lt;&amp;gt;();&#xA;        //输入表达式某个位置的字符&#xA;        char c;&#xA;        //运算符栈中弹出的字符&#xA;        char pop;&#xA;        for (int i = 0; i &amp;lt; expression.length(); i++) {&#xA;            c = expression.charAt(i);&#xA;            //如果当前字符为操作数&#xA;            if (isOperand(c)) {&#xA;                suffixExpr.append(c);&#xA;            } else if (isOpStr(c)) {&#xA;                //如果当前字符为操作符&#xA;                if (opStr.isEmpty()) {&#xA;                    opStr.push(c);&#xA;                } else {&#xA;                    while (!opStr.isEmpty() &amp;amp;&amp;amp; priority(opStr.peek()) &amp;gt;= priority(c)) {&#xA;                        pop = opStr.pop();&#xA;                        suffixExpr.append(pop);&#xA;                    }&#xA;                    opStr.push(c);&#xA;                }&#xA;            } else if (&#39;(&#39; == c) {&#xA;                //如果当前字符为‘(’&#xA;                opStr.push(c);&#xA;            } else if (&#39;)&#39; == c) {&#xA;                //如果当前字符为‘)’&#xA;                while ((pop = opStr.pop()) != &#39;(&#39;) {&#xA;                    suffixExpr.append(pop);&#xA;                }&#xA;            } else {&#xA;                logger.error(&amp;quot;c: {} is not valid in {}&amp;quot;, c, expression);&#xA;            }&#xA;        }&#xA;        while (!opStr.isEmpty()) {&#xA;            suffixExpr.append(opStr.pop());&#xA;        }&#xA;        System.out.println(&amp;quot;转换后的后缀表达式为：&amp;quot; + suffixExpr);&#xA;        return suffixExpr;&#xA;    }&#xA;&#xA;    public static void main(String[] args) {&#xA;        Scanner scan = new Scanner(System.in, &amp;quot;UTF-8&amp;quot;);&#xA;        //输入的表达式&#xA;        String expression = scan.nextLine();&#xA;        // 生成后缀表达式&#xA;        StringBuilder suffixExpr = getSuffixExpression(expression);&#xA;        System.out.println(&amp;quot;后缀表达式计算的结果为：&amp;quot; + numberCalculate(suffixExpr.toString()));&#xA;&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;tips&#34;&gt;tips&lt;/h3&gt;&#xA;&lt;p&gt;一般的代数表达式都是中缀表达式，也就是操作数在操作符两边，后缀表达式（逆波兰表达式）就是操作符在操作数后面。&lt;/p&gt;</description>
    </item>
    <item>
      <title>spark学习笔记-RDD基础算子</title>
      <link>https://qiref.github.io/post/2019/07/27/spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-rdd%E5%9F%BA%E7%A1%80%E7%AE%97%E5%AD%90/</link>
      <pubDate>Sat, 27 Jul 2019 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2019/07/27/spark%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-rdd%E5%9F%BA%E7%A1%80%E7%AE%97%E5%AD%90/</guid>
      <description>&lt;p&gt;摘要：学习spark过程中的笔记，记录spark中的基础算子，以及RDD的基本概念。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;spark-transform-operation&#34;&gt;spark transform operation&lt;/h2&gt;&#xA;&lt;p&gt;源码地址：&lt;a href=&#34;https://github.com/YaoQi17/sparkLearning/tree/master/sparkRDD&#34;&gt;https://github.com/YaoQi17/sparkLearning/tree/master/sparkRDD&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;&#xA;&lt;p&gt;RDD(Resilient Distributed Dataset) 弹性分布式数据集，是一组分布式的数据集合，里面的元素可并行计算，可分区；&#xA;RDD允许用户在执行多个查询时显示地将工作集缓存在内存中，例如persist()；&lt;/p&gt;&#xA;&lt;h3 id=&#34;创建方式&#34;&gt;创建方式&lt;/h3&gt;&#xA;&lt;p&gt;创建RDD的两种方式：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;读取外界文件&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;外界文件不局限于系统文件，包括HDFS、HBase等&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;sparkSession.sparkContext.textFile(&amp;quot;sparkRDD/src/main/resources/data.txt&amp;quot;)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;通过并行化的方式创建&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val sparkSession = getDefaultSparkSession&#xA;val dataArray = Array(1, 2, 3, 4, 5, 6)&#xA;// 创建一个RDD&#xA;val rdd = sparkSession.sparkContext.parallelize(dataArray)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;通过并行化的方式创建还可以指定分区的数量&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;/** Distribute a local Scala collection to form an RDD.&#xA;   *&#xA;   * @note Parallelize acts lazily. If `seq` is a mutable collection and is altered after the call&#xA;   * to parallelize and before the first action on the RDD, the resultant RDD will reflect the&#xA;   * modified collection. Pass a copy of the argument to avoid this.&#xA;   * @note avoid using `parallelize(Seq())` to create an empty `RDD`. Consider `emptyRDD` for an&#xA;   * RDD with no partitions, or `parallelize(Seq[T]())` for an RDD of `T` with empty partitions.&#xA;   * @param seq Scala collection to distribute&#xA;   * @param numSlices number of partitions to divide the collection into&#xA;   * @return RDD representing distributed collection&#xA;   */&#xA;  def parallelize[T: ClassTag](&#xA;      seq: Seq[T],&#xA;      numSlices: Int = defaultParallelism): RDD[T] = withScope {&#xA;    assertNotStopped()&#xA;    new ParallelCollectionRDD[T](this, seq, numSlices, Map[Int, Seq[String]]())&#xA;  }&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h3 id=&#34;rdd编程&#34;&gt;RDD编程&lt;/h3&gt;&#xA;&lt;p&gt;RDD中包含两种类型的算子：Transformation和Action；&lt;/p&gt;</description>
    </item>
    <item>
      <title>SpringBoot HBase</title>
      <link>https://qiref.github.io/post/2019/07/11/springboot-hbase/</link>
      <pubDate>Thu, 11 Jul 2019 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2019/07/11/springboot-hbase/</guid>
      <description>&lt;p&gt;摘要:记录自己写的一个基于SpringBoot操作HBase的组件，支持kerberos认证方式访问，本文相当于API文档。&lt;/p&gt;&#xA;&lt;h2 id=&#34;hbase-组件接口文档&#34;&gt;HBase 组件接口文档&lt;/h2&gt;&#xA;&lt;p&gt;源码地址：&lt;a href=&#34;https://github.com/YaoQi17/HBase-Component&#34;&gt;https://github.com/YaoQi17/HBase-Component&lt;/a&gt;&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;使用说明&#34;&gt;使用说明&lt;/h2&gt;&#xA;&lt;p&gt;基本概念&lt;/p&gt;&#xA;&lt;p&gt;table: 表&lt;/p&gt;&#xA;&lt;p&gt;columnFamily:列族，一个表下可以有多个列族，但是不建议设置多个列族，HBase建议设计长窄型的表而不是短宽型。&lt;/p&gt;&#xA;&lt;p&gt;qualifier:列，一个列族下可以有多列，一个表中的列可以是不对齐的，但是这样效率不高，同一张表中的列最好是相同的。&lt;/p&gt;&#xA;&lt;p&gt;cell:一列数据下的一个单元格，一个列下可以有多个单元格，根据版本号区分，默认每次读取最新版本的数据，cell下的存储是数据本身。&lt;/p&gt;&#xA;&lt;p&gt;row: 行，多列数据组成一行，一行中有多个qualifier。&lt;/p&gt;&#xA;&lt;p&gt;rowKey: 行健，用于唯一标识一行数据，一行下有多列，行健的设计直接关系到查询的效率。&lt;/p&gt;&#xA;&lt;h3 id=&#34;hbase配置&#34;&gt;HBase配置&lt;/h3&gt;&#xA;&lt;p&gt;以下配置为最基础配置，缺一不可。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;HBase:&#xA;  conf:&#xA;    quorum: 192.168.80.234:2181,192.168.80.235:2181,192.168.80.241:2181&#xA;    znodeParent: /hbase-unsecure&#xA;    #如果有更多配置，写在config下，例如：&#xA;    #config:&#xA;    #  key: value&#xA;    #  key: value&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;如果需要更多配置，需要在config中配置，以key-value的形式书写。&lt;/p&gt;&#xA;&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;&#xA;&lt;p&gt;quorum是HBase中zookeeper的配置，znodeParent是HBase配置在zookeeper中的路径。&lt;/p&gt;&#xA;&lt;h2 id=&#34;简单示例&#34;&gt;简单示例&lt;/h2&gt;&#xA;&lt;p&gt;引入组件jar包：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;dependency&amp;gt;&#xA;    &amp;lt;groupId&amp;gt;com.semptian.hbase.component&amp;lt;/groupId&amp;gt;&#xA;    &amp;lt;artifactId&amp;gt;hbase-component&amp;lt;/artifactId&amp;gt;&#xA;    &amp;lt;version&amp;gt;1.0.1-SNAPSHOT&amp;lt;/version&amp;gt;&#xA;&amp;lt;/dependency&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;在需要的地方注入HBaseOperations接口，该接口的实现类是HBaseTemplate，通过这个类来操作HBase。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Autowired&#xA;    private HBaseOperations hBaseDao;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;查询一条数据，通过rowKey查询：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public void testQueryTable() {&#xA;        Result result = hBaseDao.queryByTableNameAndRowKey(&#xA;            &amp;quot;LBS&amp;quot;, 9223372036854775803L);&#xA;        System.out.println(result.isEmpty());&#xA;        result.listCells().forEach(cell -&amp;gt; {&#xA;            System.out.println(&#xA;            &amp;quot;row:&amp;quot; + Bytes.toLong(CellUtil.cloneRow(cell)) + &#xA;            &amp;quot;,family:&amp;quot;+ Bytes.toString(CellUtil.cloneFamily(cell)) +&#xA;            &amp;quot;, qualifier: &amp;quot; + Bytes.toString(CellUtil.cloneQualifier(cell)) +&#xA;            &amp;quot;, value:&amp;quot; + Bytes.toString(CellUtil.cloneValue(cell)));&#xA;        });&#xA;    }&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h2 id=&#34;表的基本操作&#34;&gt;表的基本操作&lt;/h2&gt;&#xA;&lt;h3 id=&#34;新建表&#34;&gt;新建表&lt;/h3&gt;&#xA;&lt;p&gt;创建表通过HBaseTemplate就可以实现，HBaseTemplate类中带有这个方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>工厂模式</title>
      <link>https://qiref.github.io/post/2019/07/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 11 Jul 2019 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2019/07/11/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;p&gt;摘要：详细结束工厂模式（Factory Pattern）的使用，以及在Java中的实现方式。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;&#xA;&lt;p&gt;工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。工厂模式主要是解决创建对象的问题，典型的应用就是在spring中的IOC，反转控制，反转控制就是把创建对象的权限交给框架，所以spring就是一个生产对象的工厂。&lt;/p&gt;&#xA;&lt;h2 id=&#34;思路&#34;&gt;思路&lt;/h2&gt;&#xA;&lt;p&gt;工厂模式的思路就是设计一个产生对象的机制，让生产对象的过程交给第三方，在工厂模式中，不会对客户端暴露创建逻辑，并且使用通用接口接收新创建的对象。&lt;/p&gt;&#xA;&lt;h3 id=&#34;实现过程&#34;&gt;实现过程&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;新建抽象的接口&lt;/li&gt;&#xA;&lt;li&gt;新建具体的实体类，实现抽象的接口&lt;/li&gt;&#xA;&lt;li&gt;创建实例化对象的工厂&lt;/li&gt;&#xA;&lt;li&gt;在客户端中通过工厂创建具体的实体对象，对象可以用抽象接口接收。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;这种方式是最简单的实现方式：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 创建接口&#xA;public interface Shape {&#xA;    void draw();&#xA;}&#xA;&#xA;// 创建实体类Circle&#xA;public class Circle implements Shape {&#xA;    @Override&#xA;    public void draw() {&#xA;        System.out.println(&amp;quot;drawing a circle&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;// 创建实体类Rectangle&#xA;public class Rectangle implements Shape {&#xA;    @Override&#xA;    public void draw() {&#xA;        System.out.println(&amp;quot;drawing a Rectangle&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;// 创建实体类Square &#xA;public class Square implements Shape {&#xA;    @Override&#xA;    public void draw() {&#xA;        System.out.println(&amp;quot;drawing a square&amp;quot;);&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;然后创建工厂类，生成对应的实体类。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Git学习笔记</title>
      <link>https://qiref.github.io/post/2019/06/16/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sun, 16 Jun 2019 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2019/06/16/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>&lt;p&gt;摘要：学习Git的一些笔记，记录了Git的一些常见命令，以及Git中文件的生命周期。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96&#34;&gt;git文件状态变化&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%8A%B6%E6%80%81%E8%AF%B4%E6%98%8E&#34;&gt;状态说明：&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2&#34;&gt;状态转换:&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%AD%A3%E5%B8%B8%E6%B5%81%E7%A8%8B&#34;&gt;正常流程&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git-clone-%E4%BB%8E%E8%BF%9C%E7%A8%8B%E6%8B%89%E4%B8%80%E4%B8%AA%E5%B7%A5%E7%A8%8B%E4%B8%8B%E6%9D%A5&#34;&gt;git clone 从远程拉一个工程下来&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6&#34;&gt;增加一个文件&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git-status-%E6%9F%A5%E7%9C%8B%E7%8A%B6%E6%80%81&#34;&gt;git status 查看状态&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git-add-%E6%8A%8A%E6%96%87%E4%BB%B6%E4%BB%8Euntracked--staged&#34;&gt;git add 把文件从Untracked&amp;ndash;&amp;gt;Staged&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git-rm---cached&#34;&gt;git rm &amp;ndash;cached&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git-commit-%E6%8F%90%E4%BA%A4&#34;&gt;git commit 提交&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git-push-%E6%8A%8Amaster%E5%88%86%E6%94%AF%E7%9A%84%E5%86%85%E5%AE%B9%E6%8F%90%E4%BA%A4%E5%88%B0%E8%BF%9C%E7%AB%AF&#34;&gt;git push 把master分支的内容提交到远端&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git-diff-%E6%9F%A5%E7%9C%8B%E5%8F%98%E5%8C%96&#34;&gt;git diff 查看变化&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B&#34;&gt;操作实例&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%9B%9E%E6%BB%9A%E8%BF%98%E6%B2%A1%E6%9C%89commit%E7%9A%84%E6%96%87%E4%BB%B6&#34;&gt;回滚还没有commit的文件&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B-1&#34;&gt;操作实例&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%9B%9E%E6%BB%9A%E6%9F%90%E4%B8%AA%E6%8F%90%E4%BA%A4&#34;&gt;回滚某个提交&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%93%8D%E4%BD%9C%E5%AE%9E%E4%BE%8B-2&#34;&gt;操作实例&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C&#34;&gt;分支操作&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF&#34;&gt;查看分支&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%88%9B%E5%BB%BA%E5%88%86%E6%94%AF&#34;&gt;创建分支&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E6%94%AF%E4%B8%8A%E5%A2%9E%E5%8A%A0%E5%86%85%E5%AE%B9&#34;&gt;分支上增加内容&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%8E%A8%E9%80%81%E5%88%86%E6%94%AF%E5%88%B0%E8%BF%9C%E7%A8%8B&#34;&gt;推送分支到远程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%B8%A4%E4%B8%AA%E5%88%86%E6%94%AF%E8%BF%9B%E8%A1%8C%E6%AF%94%E8%BE%83&#34;&gt;两个分支进行比较&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E6%94%AF%E5%90%88%E5%B9%B6%E5%88%B0master%E4%B8%8A&#34;&gt;分支合并到master上&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%BB%8E%E8%BF%9C%E7%A8%8B%E6%8B%89%E4%B8%80%E4%B8%AA%E5%88%86%E6%94%AF&#34;&gt;从远程拉一个分支&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#tag%E6%93%8D%E4%BD%9C&#34;&gt;tag操作&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%85%B6%E4%BB%96&#34;&gt;其他&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git%E8%A6%86%E7%9B%96%E6%9C%AC%E5%9C%B0%E4%BF%AE%E6%94%B9pull-%E8%BF%9C%E7%A8%8B&#34;&gt;git覆盖本地修改，pull 远程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git%E4%BF%AE%E6%94%B9%E4%B8%8A%E4%B8%80%E6%AC%A1commit-message&#34;&gt;git修改上一次commit message&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#git%E9%87%8D%E5%91%BD%E5%90%8D%E5%88%86%E6%94%AF&#34;&gt;git重命名分支&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;git文件状态变化&#34;&gt;git文件状态变化&lt;/h2&gt;&#xA;&lt;h3 id=&#34;状态说明&#34;&gt;状态说明：&lt;/h3&gt;&#xA;&lt;p&gt;Untracked: 刚新加的文件，还没有纳入git管理范围&lt;/p&gt;&#xA;&lt;p&gt;UnModified: 已经committed的文件&lt;/p&gt;&#xA;&lt;p&gt;Modified: 已经committed的文件，通过vi等修改后，就变成Modified&lt;/p&gt;&#xA;&lt;p&gt;Staged: git add 后的文件&lt;/p&gt;&#xA;&lt;h3 id=&#34;状态转换&#34;&gt;状态转换:&lt;/h3&gt;&#xA;&lt;p&gt;Untracked-&amp;gt;Staged: 通过git add 来完成&lt;/p&gt;&#xA;&lt;p&gt;UnModified-&amp;gt;Modified: 修改文件内容来完成，比如vi命令&lt;/p&gt;&#xA;&lt;p&gt;Modified-&amp;gt;Staged: 通过git add 来完成&lt;/p&gt;</description>
    </item>
    <item>
      <title>SpringBoot中使用AOP</title>
      <link>https://qiref.github.io/post/2019/06/16/springboot%E4%B8%AD%E4%BD%BF%E7%94%A8aop/</link>
      <pubDate>Sun, 16 Jun 2019 00:18:23 +0000</pubDate>
      <guid>https://qiref.github.io/post/2019/06/16/springboot%E4%B8%AD%E4%BD%BF%E7%94%A8aop/</guid>
      <description>&lt;p&gt;摘要：Spring中如何使用注解实现面向切面编程，以及如何使用自定义注解。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;场景&#34;&gt;场景&lt;/h2&gt;&#xA;&lt;p&gt;比如用户登录，每个请求发起之前都会判断用户是否登录，如果每个请求都去判断一次，那就重复地做了很多事情，只要是有重复的地方，就有优化的空间。现在就把重复的地方抽取出来，暂且称之为 &amp;quot; 拦截器 &amp;ldquo;，然后每次请求之前就先经过&amp;rdquo; 拦截器 &amp;ldquo;，这个编程的思想就可以称之为面向切面编程。AOP(Aspect  Oriented Program)&lt;/p&gt;&#xA;&lt;p&gt;最典型的应用就是事务管理和权限验证，还有日志统计，下文中的案例就是接口执行时间的统计。&lt;/p&gt;&#xA;&lt;h2 id=&#34;spring中使用aop基于注解&#34;&gt;spring中使用AOP（基于注解）&lt;/h2&gt;&#xA;&lt;p&gt;不得不说注解是个很巧妙的设计，使用很少量的信息描述数据，这类数据称之为元数据，描述数据的数据。关于注解的理解，这里有个传送门：http://www.importnew.com/10294.html&lt;/p&gt;&#xA;&lt;p&gt;下面的案例是在springBoot中进行的，直观地感受一下如何使用注解完成AOP。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;@Service&#xA;public class UserService {&#xA;&#xA;    public void getUser() {&#xA;        //To do something&#xA;        System.out.println(&amp;quot;getUser() has been called&amp;quot;);&#xA;        try {&#xA;            Thread.sleep(1000);&#xA;        } catch (InterruptedException e) {&#xA;            e.printStackTrace();&#xA;        }&#xA;    }&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;切面是这样定义的：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;&#xA;@Component&#xA;@Aspect&#xA;public class LoggerAspect {&#xA;    /**&#xA;     * getUser()执行之前执行&#xA;     */&#xA;    @Before(&amp;quot;execution(* com.springboot.demo.service.UserService.getUser(..))&amp;quot;)&#xA;    public void callBefore() {&#xA;        System.out.println(&amp;quot;before call method&amp;quot;);&#xA;        System.out.println(&amp;quot;begin........................&amp;quot;);&#xA;    }&#xA;&#xA;    /**&#xA;     * getUser()执行之后执行&#xA;     */&#xA;    @After(&amp;quot;execution(* com.springboot.demo.service.UserService.getUser(..))&amp;quot;)&#xA;    public void callAfter() {&#xA;        System.out.println(&amp;quot;after call method&amp;quot;);&#xA;        System.out.println(&amp;quot;end..............................&amp;quot;);&#xA;    }&#xA;}&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;来个单元测试验证一下：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
