<!DOCTYPE html>
<html lang="cn-zh">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>容器网络原理分析 | 大道至简</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PGMJFXZJRT"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>

<script>
hljs.configure({languages: []});
hljs.initHighlightingOnLoad();
</script>

<link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css"  rel="stylesheet">

<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PGMJFXZJRT');
</script>
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">容器网络原理分析</span></h1>

<h2 class="date">2025/05/30</h2>
<p class="terms">
  
  
  
  
  
</p>
</div>



<main>
<h2 id="单主机容器通信">单主机容器通信</h2>
<p>在容器环境中，启动两个container，C1，C2，默认情况下，C1 和 C2 网络是通的，但是在 C1 和 C2 中，都分配了自己的 IP；</p>
<pre><code class="language-bash"># 启动两个容器环境

# 172.17.0.3
docker run -d --name containerA nginx:alpine

# 172.17.0.2
docker run -d --name containerB nginx:alpine

# 登录containerA ping containerB，网络能通
docker exec -it containerA sh

# ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.076 ms
64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.061 ms
64 bytes from 172.17.0.2: seq=2 ttl=64 time=0.062 ms
</code></pre>
<p>为什么在两个 container 中，网络都是互通的呢？</p>
<p>在 contaner 中，查看网络配置：</p>
<pre><code class="language-bash">docker exec -it containerA sh
ifconfig
eth0      Link encap:Ethernet  HWaddr 02:42:AC:11:00:03
          inet addr:172.17.0.3  Bcast:172.17.255.255  Mask:255.255.0.0
          inet6 addr: fe80::42:acff:fe11:3/64 Scope:Link
          inet6 addr: fd00:dead:beef:c0:0:242:ac11:3/80 Scope:Global
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:275 errors:0 dropped:0 overruns:0 frame:0
          TX packets:139 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:19546 (19.0 KiB)  TX bytes:9854 (9.6 KiB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)

route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0
</code></pre>
<p>从容器中的配置来看：</p>
<ol>
<li>contaner 中所有的流量都会通过 eth0 走到 172.17.0.1 这个网关上；</li>
<li>目标地址在 172.17.0.0/16 子网内的流量直接通过 eth0 接口发送，无需网关；</li>
</ol>
<h3 id="docker0">docker0</h3>
<p>先来看 172.17.0.1 这个IP， 在宿主机上，查看本地网络配置，可以看到一个 docker0 的网卡， 地址就是 172.17.0.1;</p>
<pre><code class="language-bash">ifconfig
docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        inet6 fd00:dead:beef:c0::1  prefixlen 80  scopeid 0x0&lt;global&gt;
        inet6 fe80::42:7fff:fe7c:680f  prefixlen 64  scopeid 0x20&lt;link&gt;
        ether 02:42:7f:7c:68:0f  txqueuelen 0  (Ethernet)
        RX packets 440  bytes 25146 (24.5 KiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 22  bytes 2492 (2.4 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
...
</code></pre>
<p>也就是说，在容器中，所有的地址都能经过这个网关，也就是容器的流量都经过了 docker0 网桥；</p>
<p>通过在容器中，查看 ARP 缓存也能验证：</p>
<pre><code class="language-bash">arp -n
? (172.17.0.1) at 02:42:7f:7c:68:0f [ether]  on eth0 # 对应了docker0网桥的mac地址 02:42:7f:7c:68:0f
</code></pre>
<p>再回首看容器内的两条路由规则：</p>
<pre><code class="language-bash">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0 
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0 
</code></pre>
<p>既然 docker0 已经接管了容器内的所有网络请求，为什么还需要第二条路由规则？而且第二条路由规则看上去好像还没经过 docker0 网桥！（Gateway: 0.0.0.0）</p>
<p>先来分析一下第二条路由，访问的网络网段刚好跟docker0网桥的网段是一样的：<code>inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</code></p>
<p>那就是说，容器之间网络访问，不需要走网关 172.17.0.1；</p>
<p>在 containerA 中访问 containerB：</p>
<pre><code class="language-bash">docker exec -it containerA sh
/ # ping 172.17.0.2 
PING 172.17.0.2 (172.17.0.2): 56 data bytes
64 bytes from 172.17.0.2: seq=0 ttl=64 time=0.054 ms
64 bytes from 172.17.0.2: seq=1 ttl=64 time=0.063 ms
</code></pre>
<p>在没做任何配置的情况下，发现默认网络是通的，并且在containerA arp 缓存中，甚至能看到 containerB 的 mac 地址！</p>
<pre><code class="language-bash">arp -n
? (172.17.0.2) at 02:42:ac:11:00:02 [ether]  on eth0 # containerB 的地址
? (172.17.0.1) at 02:42:7f:7c:68:0f [ether]  on eth0 # 对应了docker0网桥的mac地址 02:42:7f:7c:68:0f
</code></pre>
<p>那么肯定有类似于交换机的一个设备存在，连接了同一个宿主机下的容器网络；</p>
<p>再去宿主机上看看网络：</p>
<pre><code class="language-bash">ip a
...
# lo ..
# eth0 ..
...
3: docker0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:7f:7c:68:0f brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fd00:dead:beef:c0::1/80 scope global
       valid_lft forever preferred_lft forever
    inet6 fe80::42:7fff:fe7c:680f/64 scope link
       valid_lft forever preferred_lft forever
9: veth63935af@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default
    link/ether be:4b:ea:af:8a:e5 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet6 fe80::bc4b:eaff:feaf:8ae5/64 scope link
       valid_lft forever preferred_lft forever
11: veth66c7042@if10: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue master docker0 state UP group default
    link/ether 3e:10:f6:aa:69:2d brd ff:ff:ff:ff:ff:ff link-netnsid 1
    inet6 fe80::3c10:f6ff:feaa:692d/64 scope link
       valid_lft forever preferred_lft forever
</code></pre>
<p>发现网络设备在启动容器之后有变化，veth63935af@if8 veth66c7042@if10 启动两个容器之后，多了这两个设备；</p>
<p>抓包分析一下：</p>
<pre><code class="language-bash">tcpdump -i veth63935af -nn -c 5
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on veth63935af, link-type EN10MB (Ethernet), snapshot length 262144 bytes

</code></pre>
<p>分别尝试在containerA 和 containerB 中发起网络请求：</p>
<pre><code class="language-bash"># 访问 172.17.0.0 网段，走第二条路由规则
docker exec containerA ping 172.17.0.1
docker exec containerB ping 172.17.0.1
</code></pre>
<p>在 containerB 中发起请求时，能得到如下网络请求：</p>
<pre><code class="language-bash">tcpdump -i veth63935af -nn -c 5
tcpdump: verbose output suppressed, use -v[v]... for full protocol decode
listening on veth63935af, link-type EN10MB (Ethernet), snapshot length 262144 bytes

21:06:31.563378 IP 172.17.0.2 &gt; 172.17.0.1: ICMP echo request, id 109, seq 0, length 64
21:06:31.563436 IP 172.17.0.1 &gt; 172.17.0.2: ICMP echo reply, id 109, seq 0, length 64
21:06:32.563537 IP 172.17.0.2 &gt; 172.17.0.1: ICMP echo request, id 109, seq 1, length 64
21:06:32.563565 IP 172.17.0.1 &gt; 172.17.0.2: ICMP echo reply, id 109, seq 1, length 64
21:06:33.563644 IP 172.17.0.2 &gt; 172.17.0.1: ICMP echo request, id 109, seq 2, length 64
5 packets captured
6 packets received by filter
0 packets dropped by kernel
</code></pre>
<p>containerB 的 IP 就是 172.17.0.2 ，veth63935af 设备监听到 ICMP 网络请求，说明此设备就是作用于 containerB！</p>
<h3 id="veth-pair">veth pair</h3>
<p>veth pair 是什么？
veth（Virtual Ethernet Device）是Linux内核提供的一种虚拟网络设备，总是成对出现，因此称为 veth pair。它们像一条网线的两端：</p>
<p>一端发送数据，另一端立即接收。
被用于连接两个不同的网络命名空间（network namespace），实现网络通信。</p>
<p>进一步分析一下跟 containerB 相关 veth pair 设备，在宿主机上查看一下这个设备：</p>
<pre><code class="language-bash">ip  link show veth63935af
9: veth63935af@if8: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; 
    mtu 1500 qdisc noqueue master docker0 state UP mode DEFAULT group default
    link/ether be:4b:ea:af:8a:e5 brd ff:ff:ff:ff:ff:ff link-netnsid 0
</code></pre>
<p>在容器中，查看一下 eth0 设备：</p>
<pre><code class="language-bash">ip  link show eth0
8: eth0@if9: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff
</code></pre>
<p>可以发现：宿主机中的 veth63935af 的一端对应的就是 containerB 中的 eth0 设备；</p>
<ul>
<li>9: veth63935af@if8</li>
<li>8: eth0@if9</li>
</ul>
<p>基于 veth pair 的特性，总是成对出现，连接两个端点，一端在容器中的 eth0 ，还有一端的是连接到哪里了呢？ 通过查看宿主机上的设备信息，提到了 docker0，又是这个！</p>
<p>查看一下 docker0 设备信息：</p>
<p><code>brctl showstp</code> 是 Linux 网桥管理工具中的关键命令，用于显示网桥的 生成树协议（Spanning Tree Protocol, STP）状态信息。</p>
<pre><code class="language-bash">brctl showstp docker0
docker0
 bridge id        8000.02427f7c680f
 designated root    8000.02427f7c680f
 root port           0            path cost           0
 max age          20.00            bridge max age          20.00
 hello time           2.00            bridge hello time       2.00
 forward delay          15.00            bridge forward delay      15.00
 ageing time         300.00
 hello timer           0.00            tcn timer           0.00
 topology change timer       0.00            gc timer         241.48
 flags

veth63935af (1)
 port id        8001            state             forwarding
 designated root    8000.02427f7c680f    path cost           2
 designated bridge    8000.02427f7c680f    message age timer       0.00
 designated port    8001            forward delay timer       0.00
 designated cost       0            hold timer           0.00
 flags

veth66c7042 (2)
 port id        8002            state             forwarding
 designated root    8000.02427f7c680f    path cost           2
 designated bridge    8000.02427f7c680f    message age timer       0.00
 designated port    8002            forward delay timer       0.00
 designated cost       0            hold timer           0.00
 flags
</code></pre>
<p>有很明确的信息，docker0 网桥连接了 veth63935af veth66c7042 这两 个veth pair 设备。所以在第二条路由规则中，可以得出容器网络的拓扑图：</p>
<p><img src="/assets/img/docker0-1.svg" alt="docker0 网桥拓扑"></p>
<pre><code class="language-bash">brctl showmacs docker0
port no    mac addr        is local?    ageing timer
 2    3e:10:f6:aa:69:2d    yes           0.00
 1    be:4b:ea:af:8a:e5    yes           0.00
...


ip -br link
veth63935af@if8  UP  be:4b:ea:af:8a:e5 &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;
veth66c7042@if10 UP  3e:10:f6:aa:69:2d &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt;
...
</code></pre>
<p>通过查看 docker0 网桥学习到的mac地址，也可以发现，docker0 保存了 veth pari 设备在宿主机上的 mac 地址，并且视为本地地址，也进一步验证了，veth pair 的一端连接到了 docker0 网桥。</p>
<p>同时，以上信息也可以得出，连接了 veth pair 设备的 docker0 直接作用在二层网络，因为 docker0 中直接保存了 veth pair 的 mac 地址，相当于一个交换机，直连了容器网络中的各个容器；</p>
<h3 id="heading"></h3>

</main>

  <footer>
  
  <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "qiref" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

  
  <hr/>
  © powered by <a href="https://gohugo.io/">Hugo</a> &amp; <a href="https://github.com/yihui/hugo-xmin">Xmin</a>  2017 &ndash; 2025 | <a href="https://github.com/qiref">Github</a>
  
  </footer>
  </body>
</html>

