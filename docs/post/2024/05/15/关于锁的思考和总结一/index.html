<!DOCTYPE html>
<html lang="cn-zh">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>关于锁的思考和总结(一) | 大道至简</title>
    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-PGMJFXZJRT"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/highlight.min.js"></script>

<script>
hljs.configure({languages: []});
hljs.highlightAll();
</script>

<link href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.11.1/styles/github.min.css"  rel="stylesheet">

<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-PGMJFXZJRT');
</script>

<link rel="stylesheet" href="/css/custom.css">
<link rel="stylesheet" href="/css/heatmap.css">
  </head>

  <body>
    <nav>
    <ul class="menu">
      
      <li><a href="/">Home</a></li>
      
      <li><a href="/post/">Posts</a></li>
      
      <li><a href="/tags/">Tags</a></li>
      
      <li><a href="/about/">About</a></li>
      
      <li><a href="/note/">Note</a></li>
      
      <li><a href="/index.xml">Subscribe</a></li>
      
      <li class="search-container">
        <input type="text" id="search-input" placeholder="⌘ K" autocomplete="off">
        <div id="search-results"></div>
      </li>
    </ul>
    <hr/>
    </nav>

<div class="article-meta">
<h1><span class="title">关于锁的思考和总结(一)</span></h1>

<h2 class="date">2024/05/15</h2>
<p class="terms">
  
  
  
  
  Tags: <a href="/tags/lock">Lock</a> <a href="/tags/mutex">Mutex</a> <a href="/tags/cas">CAS</a> <a href="/tags/go">Go</a> 
  
  
</p>
</div>



<main>
<pre><code class="language-go">func add (a *int) *int { 
  *a++ // 线程不安全
  return a
}
</code></pre>
<p>这是一段很典型的线程不安全的代码示例, 在并发场景下, a 的结果是不确定的, 大概率会小于 1000, 原因是 <code>a++</code> 并非原子操作, 会存在同时有两个协程读取到 a 的值是相同的情况, 执行 <code>a++</code>之后再重新回写时, a的值也是相同的, 想要变为线程安全, 就需要在操作临界资源之前加锁;</p>
<h2 id="mutex">Mutex</h2>
<p>在操作共享资源之前加锁, 然后操作完临界资源之后释放锁, 保证同时只有一个协程操作临界资源;</p>
<pre><code class="language-go">var mu sync.Mutex
func addSafe(a *int) *int {
  mu.Lock() // 加锁
  defer mu.Unlock() // 释放锁
  *a++
  return a
}
</code></pre>
<p>锁在多线程或多进程环境中实现资源的互斥访问。当一个线程或进程想要访问某个共享资源（如数据结构、文件等）时，它必须首先尝试获取该资源对应的锁。如果锁未被其他线程或进程占用，那么请求的线程或进程将获得锁并继续执行；否则，它将等待，直到锁被释放。</p>
<pre><code class="language-go">// If the lock is already in use, the calling goroutine
// blocks until the mutex is available.
func (m *Mutex) Lock() {
  // Fast path: grab unlocked mutex.
  if atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked) {
    if race.Enabled {
      race.Acquire(unsafe.Pointer(m))
    }
    return
  }
  // Slow path (outlined so that the fast path can be inlined)
  m.lockSlow()
}

type Mutex struct {
  state int32 // state 表示当前互斥锁的状态
  sema  uint32 // sema 是用于控制锁状态的信号量
}
</code></pre>
<p>在 <code>golang</code> 的实现中, 如果通过 <code>CompareAndSwapInt32</code> 也就是 <code>CAS</code> 能获取到锁, 表明协程已经能拿到锁了, 此时直接返回;</p>
<p>如果通过 <code>CAS</code> 无法拿到锁, 说明有其他协程拿到锁还未释放, 这时候的选择就会很多了, 可以原地重试, 也就是自旋的特性, 也可以进入队列等待, 等待被唤醒;</p>
<p>一般来说, 编程语言的实现中, 会优先选择自旋, 因为此时还是在用户态, 但是并发量很大时, 自旋反而会降低性能.</p>
<pre><code class="language-go">// lockSlow() 代码片段
...
if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
  if old&amp;(mutexLocked|mutexStarving) == 0 {
    break // locked the mutex with CAS
  }
  // If we were already waiting before, queue at the front of the queue.
  queueLifo := waitStartTime != 0
  if waitStartTime == 0 {
    waitStartTime = runtime_nanotime()
  }
  runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)
 ...
}
</code></pre>
<p>当 <code>CAS</code> 和自旋之后依然没有获取到锁, 为了防止大批量协程自旋, <code>lockSlow()</code> 中, <code>runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)</code>  给出了一种新的方式去获取锁, 从入参来看, 传入了一个信号量, 是否需要 <code>LIFO</code> 的队列, 和一个值, 实现思路大概是如果没获取到锁, 就进入等待队列, 等待被唤醒;</p>
<pre><code class="language-go">// func runtime_SemacquireMutex(addr *uint32, lifo bool, skipframes int32)
TEXT runtime·runtime_SemacquireMutex(SB), NOSPLIT, $0-12
    MOVL addr+0(FP), BP  // 将互斥锁的地址加载到 BP 寄存器
    MOVL lifo+4(FP), AX  // 将 lifo 参数加载到 AX 寄存器
    MOVL skipframes+8(FP), CX  // 将 skipframes 参数加载到 CX 寄存器

    // 尝试原子地获取互斥锁
acquire:
    MOVL $1, SI          // 将 SI 寄存器设置为 1
    XCHGL SI, 0(BP)      // 使用 XCHGL 指令原子地交换 SI 和互斥锁的值
    TESTL SI, SI         // 检查 SI 寄存器的值（即原互斥锁的值）
    JZ acquired          // 如果 SI 寄存器的值为 0，表示互斥锁已被获取，跳转到 acquired 标签

    // 互斥锁已被占用，阻塞当前协程（goroutine）
    MOVL BP, 0(SP)       // 将互斥锁的地址存储到栈上
    MOVL AX, 4(SP)       // 将 lifo 参数存储到栈上
    MOVL CX, 8(SP)       // 将 skipframes 参数存储到栈上
    CALL runtime·semacquire1(SB)  // 调用 semacquire1 函数阻塞当前协程
    JMP acquire          // 当协程被唤醒时，跳回到 acquire 标签尝试再次获取互斥锁

acquired:
    // 互斥锁已被成功获取，执行后续代码
    // ...
    RET
</code></pre>
<h2 id="cas">CAS</h2>
<p><code>Mutex</code> 加锁为什么会影响性能呢? 基于<code>Mutex</code>的原理: 当一个线程尝试获取已被其他线程持有的锁时，它将被阻塞。阻塞的线程会进入睡眠状态，等待锁被释放, 当锁被释放时，操作系统会唤醒等待锁的线程, 使其重新尝试获取锁. 一般来说, 等待的线程会放到队列中等待, 以保障后续唤醒的顺序。</p>
<p>这里耗时的主要原因是线程被阻塞进入睡眠状态, 而后又被唤醒, 这些操作都需要切换到内核态 ,如果说线程在没获取到锁时不进入睡眠状态, 而是原地重试, 那是不是就能提高效率呢? 这就是 <code>CAS</code> 的思路, 先来看看 <code>golang</code> 中对 <code>CAS</code> 的相关实现:</p>
<pre><code class="language-go">// CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.
// Consider using the more ergonomic and less error-prone [Int32.CompareAndSwap] instead.
func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
</code></pre>
<p>这种只有函数声明，没有函数实现的，通常意味着函数的实现在<code>golang</code>汇编中, 也就是还是需要借助系统的能力实现 <code>CAS</code>, 从汇编指令上看, 对于 addr 来说, 如果 addr == old , 就把 addr 设置为 new;</p>
<p>在 X86 架构下:</p>
<pre><code class="language-go">// func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
TEXT runtime·CompareAndSwapInt32(SB), NOSPLIT, $0-13
    MOVL addr+0(FP), BP  // 将目标地址加载到 BP 寄存器
    MOVL old+4(FP), AX   // 将 old 参数加载到 AX 寄存器
    MOVL new+8(FP), CX   // 将 new 参数加载到 CX 寄存器

    // 使用 CMPXCHGL 指令原子地比较和交换值
    MOVL AX, 0(BP)       // 将 AX 寄存器的值存储到目标地址
    LOCK CMPXCHGL CX, 0(BP)  // 原子地比较和交换目标地址和 CX 寄存器的值

    // 设置返回值
    SETE AL                // 如果比较和交换成功，将 AL 寄存器设置为 1（true），否则设置为 0（false）
    MOVB AL, swapped+12(FP)  // 将 AL 寄存器的值存储到返回值中
    RET
</code></pre>
<p>这段汇编中, 最重要的一点就是 <code>LOCK CMPXCHGL</code> , <code>LOCK</code> 前缀用于确保指令在执行过程中不会被其他处理器或线程中断。当 LOCK 前缀与 CMPXCHGL 指令结合使用时，确保了在比较和交换操作数的过程中，内存位置的值不会被其他处理器或线程修改，从而实现了原子性。</p>
<p>从 <code>CompareAndSwapInt32</code> 函数的返回结果来看, 执行函数可能会失败, 也就是没获取到锁, 往往这种情况会进行重试, 直到执行完成, 也就是自旋的特性; 当然这种自旋是在用户态, 无需切换到内核态, 因此性能上相对更好;</p>
<p>比如在 <code>java</code> 语言中对于 <code>CAS</code> 的使用:</p>
<pre><code class="language-java">public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

    return var5;
}
</code></pre>
<h3 id="aba-问题">ABA 问题</h3>
<pre><code class="language-go">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
</code></pre>
<p>在 CAS 中, 对于 addr 来说, 如果 addr == old , 就把 addr 设置为 new, 在此过程中, 依然存在问题;</p>
<ol>
<li>当线程 T1 进入 CAS 之前, 读取了一个 old 值, 假设为 A;</li>
<li>线程 T1 时间片耗尽, 线程 T2 开始执行;</li>
<li>T2 执行 CAS, 把 addr 设置为 B, 然后又执行 CAS , 把 addr 修改回 A;</li>
<li>当 T1 继续执行时, 发现 addr 依然为 old A, T1 会认为 addr 没有被修改过;</li>
</ol>
<p>如果要解决 ABA 问题, 一个可行的思路就是给数据加上一个版本号, 不仅是对比数据的值, 还需要对比数据的版本号, 这个思路其实就是从最底层的资源做了隔离, 在并发的场景中, 如果对数据正确性要求很高, 临界资源兜底策略很重要;</p>
<h3 id="大批量线程自旋问题">大批量线程自旋问题</h3>
<p>基于 CAS 的特性, 没有修改成功可以进行重试, 也就是自旋, 如果在线程数量很多的场景下, 反而会影响性能, 因为会有大量的线程不断自旋, 而且随着线程数量, 自旋的影响会持续放大, 因此在 Java 中, <code>synchronized</code> 会随着并发量的增加, 会有锁升级的机制, 在golang 的 Mutex 实现中, 也是从 CAS 逐渐升级到最后阻塞线程.</p>
<h2 id="总结">总结</h2>
<ul>
<li>
<p>从编程语言的锁的实现上来看, 从用户态很难实现锁的机制, 因为线程调度是由内核完成的, 不确定当前线程何时耗尽时间片, 如果读到临界资源还没来得及写入, 此时中断, 其他线程获取到 CPU 时间片后, 会读取到相同的临界资源, 当临界资源被修改后, 之前线程拿到的临界资源还是历史值, 此时再修改就是基于错误的值进行修改;</p>
</li>
<li>
<p>当借助系统调用时, 会进入内核态, 无论是 <code>XCHGL</code> 还是 <code>CMPXCHGL</code> , 这些指令都是原子操作; 从操作系统的角度而言, 锁的本质就是一个内存中的标识, 锁的竞争就是通过原子指令去修改这个标识位, 修改成功则表现为获取到了锁, 修改失败则可以自行决定, 自旋或者阻塞, 表现为不同的锁的形式, 自旋锁, 排他锁;</p>
</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81">https://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81</a></p>
<p><a href="https://www.infoq.com/presentations/go-locks/">https://www.infoq.com/presentations/go-locks/</a></p>
<p><a href="https://time.geekbang.org/column/article/377913">https://time.geekbang.org/column/article/377913</a></p>
<p><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#mutex">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/#mutex</a></p>

</main>

  <footer>
  
<script src="https://utteranc.es/client.js"
        repo="qiref/qiref.github.io"
        issue-term="pathname"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


<script>
(function() {
  const searchInput = document.getElementById('search-input');
  const searchResults = document.getElementById('search-results');
  if (!searchInput || !searchResults) return;
  
  let searchIndex = null;
  let activeIndex = -1;
  let isResultsVisible = false;

  
  async function loadSearchIndex() {
    if (searchIndex) return searchIndex;
    try {
      const response = await fetch('/index.json');
      const data = await response.json();
      searchIndex = data.pages || [];
      return searchIndex;
    } catch (e) {
      console.error('Failed to load search index:', e);
      return [];
    }
  }

  
  function search(query) {
    if (!searchIndex || !query.trim()) return [];
    const q = query.toLowerCase();
    return searchIndex.filter(page => {
      const title = (page.title || '').toLowerCase();
      const content = (page.content || '').toLowerCase();
      return title.includes(q) || content.includes(q);
    }).slice(0, 10);
  }

  
  function highlight(text, query) {
    if (!query) return text;
    const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
    return text.replace(regex, '<mark>$1</mark>');
  }

  
  function showResults() {
    searchResults.style.display = 'block';
    isResultsVisible = true;
  }

  
  function hideResults() {
    searchResults.style.display = 'none';
    isResultsVisible = false;
    activeIndex = -1;
  }

  
  function updateActiveItem() {
    const items = searchResults.querySelectorAll('.search-result-item');
    items.forEach((item, index) => {
      if (index === activeIndex) {
        item.classList.add('active');
      } else {
        item.classList.remove('active');
      }
    });
  }

  
  function renderResults(results, query) {
    activeIndex = -1;
    if (!results.length) {
      hideResults();
      return;
    }
    const html = results.map(page => {
      const title = highlight(page.title || 'Untitled', query);
      let summary = page.summary || page.content || '';
      summary = summary.substring(0, 100) + (summary.length > 100 ? '...' : '');
      return `<a class="search-result-item" href="${page.url}">
        <div class="search-result-title">${title}</div>
        <div class="search-result-summary">${summary}</div>
      </a>`;
    }).join('');
    searchResults.innerHTML = html;
    showResults();
  }

  
  let debounceTimer;
  function debounce(fn, delay) {
    return function(...args) {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => fn.apply(this, args), delay);
    };
  }

  
  searchInput.addEventListener('input', debounce(async function() {
    const query = this.value.trim();
    if (!query) {
      hideResults();
      return;
    }
    await loadSearchIndex();
    const results = search(query);
    renderResults(results, query);
  }, 200));

  
  searchInput.addEventListener('keydown', function(e) {
    if (!isResultsVisible) return;
    
    const items = searchResults.querySelectorAll('.search-result-item');
    const itemCount = items.length;
    if (itemCount === 0) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        e.stopPropagation();
        activeIndex = (activeIndex + 1) % itemCount;
        updateActiveItem();
        break;
      case 'ArrowUp':
        e.preventDefault();
        e.stopPropagation();
        activeIndex = activeIndex <= 0 ? itemCount - 1 : activeIndex - 1;
        updateActiveItem();
        break;
      case 'Enter':
        if (activeIndex >= 0 && items[activeIndex]) {
          e.preventDefault();
          window.location.href = items[activeIndex].href;
        }
        break;
      case 'Escape':
        e.preventDefault();
        hideResults();
        break;
    }
  });

  
  searchInput.addEventListener('focus', async function() {
    const query = this.value.trim();
    if (query) {
      await loadSearchIndex();
      const results = search(query);
      renderResults(results, query);
    }
  });

  
  document.addEventListener('click', function(e) {
    if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
      hideResults();
    }
  });

  
  document.addEventListener('keydown', function(e) {
    if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
      e.preventDefault();
      searchInput.focus();
      searchInput.select();
    }
  });
})();
</script>
  
  <hr/>
  © powered by <a href="https://gohugo.io/">Hugo</a> &amp; <a href="https://github.com/yihui/hugo-xmin">Xmin</a>  2017 &ndash; 2025 | <a href="https://github.com/qiref">Github</a>
  
  </footer>
  </body>
</html>

